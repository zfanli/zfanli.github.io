(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["post8"],{"1c7f":function(n,t){n.exports={attributes:{title:"关于乐观锁和悲观锁的笔记",subtitle:"乐观锁和悲观锁的概念，暂且做个笔记。",date:"2017-11-26T13:53:35.000Z",tags:["SQL","Database"]},body:"\n边记录博客边进行实践果然效率不够。想了想还是决定先把重要的点摘录一下留给以后深究，目前段专心于应用层的研究和实践吧。\n\n### 绕不开的话题，并发\n\n并发是一个应用不可避免的话题，有用户有操作就存在并发。比如一篇文章的点赞数，评论的点赞数，点击量，等等。我们要将这些数据正确无误的更新到数据库里的话，就需要制定合适的并发策略。\n\n数据库层面我们需要考虑使用什么锁来处理并发的数据保存。我们需要选择使用乐观锁还是悲观锁。\n\n### 什么是乐观锁？什么是悲观锁？\n\n方便理解，我们先说悲观锁。\n\n悲观锁（Pessimistic Lock）是数据库的一项功能。通过`select...for update`的形式获得悲观锁，在这个事务提交之后释放锁。\n\n获得悲观锁的事务未提交之前，其他事务无法查询被锁住的数据。\n\n这里有一个点需要注意，获得悲观锁时如果使用了索引（如指定主键）的情况获得的是行锁，即其他事务还可以访问同一个表的其他数据。相反，如果获得悲观锁时没有使用索引，将获得表锁，即其他事务将不能访问这张表。\n\n为了减少影响提高效率，应该尽量使用索引。\n\n悲观锁类似于 synchronized 关键字。一个事务将要更新一条数据时，先宣布“我要修改它！”，其他事务这时也需要修改同样的数据，但是后来者看到这个宣言就默默的等第一个事务结束，然后再做出同样的宣言，让其后的事务等待。坏处也很明显，在数据库层多了加锁和解锁两个步骤，一定程度消耗了资源降低了效率。\n\n以上就是悲观锁，而乐观锁并不是数据库的功能。\n\n乐观锁（Optimistic Lock）是一种思路，不像悲观锁堵塞线程，乐观锁乐观的认为目标数据每一次都没有被修改，所以只再更新的步骤匹配一次元数据。通常是在表里加一个版本字段，或者时间戳，每次更新的时候匹配一次是否符合预期，否则就不执行更新。或者在更新点赞数的场合，我选择每次匹配更新前的数据是否与之前 check 时一致，否则就不执行更新。\n\n乐观锁没有加锁与解锁的步骤，但是如果修改的对象被修改，根据不同的场合可能会增加读写量。\n\n### 乐观锁与悲观锁的应用场景\n\n我做了一个简单测试，使用乐观锁和悲观锁进行点赞数的累加测试。发现在并发量没有达到一定规模的时候区别并不大。\n\n点赞数从 0 累加到 100 和从 0 累加到 1000 的测试中，乐观锁和悲观锁的效率相差无几。但是从读写量上来看明显乐观锁远多于悲观锁，这取决于并发的每个请求的间隔时间。\n\n而当点赞数从 0 累加到 10000 时，乐观锁由于并发量的激增导致重复读写量也大幅上升，乐观锁使用了悲观锁两倍的时间才完成累加操作。\n\n通过测试结果可以看出，悲观锁适合并发量中上且集中的场合，可以有效的控制读写量并正确的将数据持久化到数据库。\n\n而乐观锁适合并发量中等以下且相对间隔较长的场合，请求越分散效率越高。\n\n### 结束\n\n这也就是记了一个点，留待以后深究。\n",frontmatter:"title: 关于乐观锁和悲观锁的笔记\nsubtitle: 乐观锁和悲观锁的概念，暂且做个笔记。\ndate: 2017-11-26 21:53:35 +8\ntags:\n  - SQL\n  - Database"}}}]);
//# sourceMappingURL=post8.d3b8577e.js.map