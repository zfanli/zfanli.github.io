<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1004. Max Consecutive Ones III (Medium)</title>
    <url>/post/leetcode/1004-Max-Consecutive-Ones-III-Medium/</url>
    <content><![CDATA[<p>给定一个二进制数组 <code>nums</code>（元素的值为 <code>0</code> 或 <code>1</code>），求最长的连续的 <code>1</code> 的长度。</p>
<p>有趣的地方在于你有 <code>k</code> 次机会将 <code>0</code> 翻转为 <code>1</code>，你需要找出最合适的时机使用这些机会。</p>
<p>“连续”是这道题的关键字，看上去我们可以使用滑动窗口来解决这道题。</p>
<span id="more"></span>

<h2 id="思路-1，滑动窗口"><a href="#思路-1，滑动窗口" class="headerlink" title="思路 1，滑动窗口"></a>思路 1，滑动窗口</h2><p>提示说的很清楚，题目要求找出最长的连续出现的 <code>1</code>，那么用 2 个指针实现一个滑动窗口是一个合适的选择。</p>
<p>用一个数组储存所有遇到 <code>0</code> 的位置，当数组长度超过 <code>k</code>，将左边指针设为第一个 <code>0</code> 位置的下一位，并将第一个 <code>0</code> 从数组删除。</p>
<p>每一步都保存一下当前连续的最大值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, i, zeros = <span class="number">0</span>, <span class="number">0</span>, []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] == <span class="number">0</span>:</span><br><span class="line">                zeros.append(j)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(zeros) &gt; k:</span><br><span class="line">                    i = zeros.pop(<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, j - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，滑动窗口-内存优化"><a href="#思路-2，滑动窗口-内存优化" class="headerlink" title="思路 2，滑动窗口+内存优化"></a>思路 2，滑动窗口+内存优化</h2><p>我们可以优化思路 1 的数组方法，仅使用一个计数器来提醒我们是否需要将左边的指针移动到下一个位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">while</span> nums[i] != <span class="number">0</span>:</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, j - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
        <tag>Sliding Window</tag>
        <tag>Prefix Sum</tag>
      </tags>
  </entry>
  <entry>
    <title>101. Symmetric Tree (Easy)</title>
    <url>/post/leetcode/101-Symmetric-Tree-Easy/</url>
    <content><![CDATA[<p>检查给定的二叉树是否对称。如果 root 的左右子树互为镜像，那么这棵树是一棵对称树。</p>
<p>这道题实际上需要我们同时遍历两棵树，来判断它们是否对称。</p>
<p>我们尝试从递归、迭代以及 DFS 和 BFS 等角度来尝试解决这道题。</p>
<span id="more"></span>

<h2 id="思路-1，递归，"><a href="#思路-1，递归，" class="headerlink" title="思路 1，递归，"></a>思路 1，递归，</h2><p>Top-Down 做法。</p>
<p>实际上我们需要对两棵子树同时进行前序遍历，而要确认它们是否对称，需要我们对遍历顺序做一点修改：</p>
<ul>
<li>左子树：root -&gt; left -&gt; right</li>
<li>右子树：root -&gt; right -&gt; left</li>
</ul>
<p>由于遍历过程是同步的，在每一次遍历中我们都要进行下面的操作以确定当前是否依然对称：</p>
<ul>
<li>当前 2 个节点的值是否相等；</li>
<li>左左节点和右右节点是否相等；</li>
<li>左右节点和右左节点是否相等。</li>
</ul>
<p>上述步骤中从上至下，一旦遇到 False，程序就会一步一步退出递归流程，给出结果。</p>
<p>这是一个 DFS 算法，我们会一条路径一条路径的检查整棵树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            <span class="comment"># if one of the nodes does not exist</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">return</span> left == right</span><br><span class="line">            <span class="comment"># if nodes are not equal</span></span><br><span class="line">            <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># check their children symmetrically</span></span><br><span class="line">            <span class="keyword">return</span> dfs(left.left, right.right) <span class="keyword">and</span> dfs(left.right, right.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root.left, root.right)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，迭代"><a href="#思路-2，迭代" class="headerlink" title="思路 2，迭代"></a>思路 2，迭代</h2><p>使用 Stack 数据结构，我们可以把递归过程改成迭代过程。</p>
<p>和递归过程每次传递 2 个参数类似，迭代过程我们用 Stack 每次保存俩个需要对比的节点。</p>
<p>与递归过程的差异体现在 False 的处理，迭代过程中一旦遇到失败的情况，我们可以直接返回结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        stack = [[root.left, root.right]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            left, right = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.append([left.left, right.right])</span><br><span class="line">            stack.append([left.right, right.left])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="思路-3，BFS"><a href="#思路-3，BFS" class="headerlink" title="思路 3，BFS"></a>思路 3，BFS</h2><p>不同的算法针对不同的数据存在不同的效率。如果两棵树的层级数不同，或者靠下层的数据出现差异时，使用 DFS 是高效的，因为每次我们会遍历一整条路径，一旦层级和叶子节点有差异，我们可以快速得到结果并结束程序。</p>
<p>另一方面，如果两棵树的结构没有差异，数据的差异可能出现在树的中段位置，那么相对来说 BFS 会更加高效。</p>
<p>从我提交的结果来看，目前这道题的测试数据是偏向于 BFS 的，Python3 实现的 BFS 平均在 24ms 左右，而 DFS 在 36ms 左右。</p>
<p>下面是 BFS 实现的思路，与之前相同，我们同时遍历两棵树，仅在遍历顺序上做出一点修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        ltree, rtree = [root.left], [root.right]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ltree <span class="keyword">and</span> rtree:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(ltree) != <span class="built_in">len</span>(rtree):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ltree)):</span><br><span class="line">                left, right = ltree.pop(<span class="number">0</span>), rtree.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                ltree.append(left.left)</span><br><span class="line">                ltree.append(left.right)</span><br><span class="line">                rtree.append(right.right)</span><br><span class="line">                rtree.append(right.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>102. Binary Tree Level Order Traversal (Medium)</title>
    <url>/post/leetcode/102-Binary-Tree-Level-Order-Traversal-Medium/</url>
    <content><![CDATA[<p>遍历树的方式除了通常的前序遍历、中序遍历和后序遍历之外，还有本题的层序遍历。</p>
<p>层序遍历的顺序是从左到右依次遍历同层级到节点，然后在进入下一层级重复这个过程，直到不再存在下一层级。这是一个典型的宽度优先搜索（BFS）算法。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>完成层序遍历，我们可以利于先进先出的队列来记录每一个层级的节点数。</p>
<p>具体过程如下：</p>
<ul>
<li>将 root 放入队列，开始进入迭代；</li>
<li>每次迭代开始先取得队列的长度，这个长度表示当前层级的节点数；</li>
<li>循环依次取出所有当前层级的节点，将其子节点按照左右顺序放入队列，并将当前节点的值存入新的列表；</li>
<li>将列表放入答案列表，重复迭代直到队列清空。</li>
</ul>
<p>需要注意的一点是，虽然我们在放入子节点的时候会进行存在判定，但是 root 本身也存在为空（None）的情况，下面代码中我们新建了一个 Dummy 节点来处理这个问题，将 root 作为 Dummy 节点的子节点，然后在放入子节点的过程中进行存在判定，这样就规避了 root 节点本身不存在的问题。</p>
<p>最终在返回结果时，将位于数组 0 位置的 Dummy 节点的值删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        ans, queue = [], [TreeNode(-<span class="number">1</span>, root)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            lst, n = [], <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                lst.append(node.val)</span><br><span class="line">            ans.append(lst)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>

<hr>
<p>bk，旧思路，这个方法会额外创建 log n 个新数组，这个额外空间其实没有必要。</p>
<ul>
<li>同级的元素全都放到一个数组；</li>
<li>按照顺序提取元素的值放到答案数组；</li>
<li>同时将存在的子节点放到新的数组；</li>
<li>重复这个过程直到不存在任何子节点；</li>
<li>此时答案数组已经编辑完成。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        ans, lv = [], [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(lv) != <span class="number">0</span>:</span><br><span class="line">            _ans, _lv = [], []</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> lv:</span><br><span class="line">                <span class="keyword">if</span> n:</span><br><span class="line">                    _ans.append(n.val)</span><br><span class="line">                    _lv.append(n.left)</span><br><span class="line">                    _lv.append(n.right)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(_ans) &gt; <span class="number">0</span>:</span><br><span class="line">                ans.append(_ans)</span><br><span class="line">            lv = _lv</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>BFS</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>104. Maximum Depth of Binary Tree (Easy)</title>
    <url>/post/leetcode/104-Maximum-Depth-of-Binary-Tree-Easy/</url>
    <content><![CDATA[<p>求二叉树的最大深度。二叉树的深度指的是其节点的最大层数。</p>
<p>这是一道简单题，但是可以视作是 Top-Down 和 Bottom-Up 方法的教学题。</p>
<p>我们应用 DFS 来处理之道题，来看看自上而下与自下而上方法的区别。</p>
<span id="more"></span>

<h2 id="思路-1，Top-Down，递归"><a href="#思路-1，Top-Down，递归" class="headerlink" title="思路 1，Top-Down，递归"></a>思路 1，Top-Down，递归</h2><p>在递归过程中，我们先根据当前层的深度更新结果，然后针对子节点进行递归调用，重复这个过程直到遍历完整棵树。这是从上至下的解题方法，顺序体现在我们何时处理当前节点的值。</p>
<p>这个思路可以解决问题，但是从逻辑上来说，如果存在子节点，那么当前节点的深度肯定不是最终答案，Top-Down 方法或许不是最符合这道题目逻辑的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">node, depth</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, depth)</span><br><span class="line">            traverse(node.left, depth + <span class="number">1</span>)</span><br><span class="line">            traverse(node.right, depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        traverse(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，Bottom-Up，递归"><a href="#思路-2，Bottom-Up，递归" class="headerlink" title="思路 2，Bottom-Up，递归"></a>思路 2，Bottom-Up，递归</h2><p>在从下至上的方法中，我们先去计算以当前节点开始其子节点的最大深度，在结果的基础上 +1 作为当前节点的深度结束递归过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(traverse(node.left),</span><br><span class="line">                           traverse(node.right))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> traverse(root)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>1047. Remove All Adjacent Duplicates In String (Easy)</title>
    <url>/post/leetcode/1047-Remove-All-Adjacent-Duplicates-In-String-Easy/</url>
    <content><![CDATA[<p>给定一个由英文小写字母组成的字符串 <code>s</code>，要求去重并返回结果。去重的条件是 2 个字符必须接邻且相等。</p>
<p>这道题的难点在于去重之后的字符串可能会产生新的重复。使用 Stack 可以方便的解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用 Stack 依次确认每一个字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] == c:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>1048. Longest String Chain (Medium)</title>
    <url>/post/leetcode/1048-Longest-String-Chain-Medium/</url>
    <content><![CDATA[<p>给定一个由英文小写字母组成的字符串数组 <code>words</code>，你需要从中挑选单词构成满足下面定义的词汇链（word chain），找到能构成的最长词汇链，返回其长度。</p>
<ul>
<li>词汇链（word chain）指一个字符串数组中，每个字符串都是后一个字符串的前置（predecessor），如果数组只有一个字符串，这个词汇链长度为 <code>1</code>；</li>
<li>前置（predecessor）指一个字符串 A 满足仅向其中添加一个字符可以构成字符串 B 的条件，此时字符串 A 称之为字符串 B 的前置。<ul>
<li>比如 <code>&quot;abc&quot;</code> 是 <code>&quot;abac&quot;</code> 的前置, 而 <code>&quot;cba&quot;</code> 不是 <code>&quot;bcad&quot;</code> 的前置。</li>
</ul>
</li>
</ul>
<p>我们用 DFS 和 DP 两个思路解决这个问题。</p>
<span id="more"></span>

<h2 id="思路-1，hash-table-memoization"><a href="#思路-1，hash-table-memoization" class="headerlink" title="思路 1，hash table + memoization"></a>思路 1，hash table + memoization</h2><p>明确一下要找出最长的链，我们需要完成下面的步骤才能最终确认：</p>
<ul>
<li>遍历所有 word，找到所有可能的 predecessor</li>
<li>遍历所有的 predecessor，找到它的所有可能的 predecessor；如此反复</li>
</ul>
<p>我们可以观察到如果有两个词找到同一个词能作为它的 predecessor，这个被找到的对象就发生了重复计算。我们可以用 memoization 解决这个问题。</p>
<p>此外，寻找 predecessor 的过程也可以用 Hash Table 来进行加速。具体的做法是，我们使用一个 Map 来做 memoization，用 word 作为 key，value 储存它的 predecessor 的数量。</p>
<p>针对每一个词，我们枚举出它的所有可能的 predecessor，到 Hash 表中进行匹配，如果值在表中存在则用这个词继续进行枚举过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestStrChain</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            memo[w] = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">w</span>):</span></span><br><span class="line">            <span class="keyword">if</span> memo[w] != -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> memo[w]</span><br><span class="line">            c = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w)):</span><br><span class="line">                _w = w[:i] + w[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> _w <span class="keyword">in</span> memo:</span><br><span class="line">                    c = <span class="built_in">max</span>(c, dfs(_w))</span><br><span class="line">            memo[w] = c + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> memo[w]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            dfs(w)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(memo)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(memo.values())</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，DP"><a href="#思路-2，DP" class="headerlink" title="思路 2，DP"></a>思路 2，DP</h2><p>思路 1 的非递归版本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestStrChain</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        words.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x))</span><br><span class="line">        dp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            c = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w)):</span><br><span class="line">                _w = w[:i] + w[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> _w <span class="keyword">in</span> dp:</span><br><span class="line">                    c = <span class="built_in">max</span>(c, <span class="number">1</span> + dp[_w])</span><br><span class="line">            dp[w] = c</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp.values())</span><br></pre></td></tr></table></figure>

<p>此外还有按长度分组 Hash 等方法，但性能上比上面两个思路没有优势，逻辑还更加复杂了，就不讨论了。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
        <tag>Hash Table</tag>
        <tag>Two Pointers</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</title>
    <url>/post/leetcode/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium/</url>
    <content><![CDATA[<p><code>No.106</code> 的镜像问题。你需要从一棵树的<code>前序遍历</code>数据和<code>中序遍历</code>数据中尝试重新构建出这棵二叉树。</p>
<p>之前我们尝试基于<code>中序遍历</code>和<code>后序遍历</code>的数据来还原这棵树，这次是<code>前序遍历</code>和<code>中序遍历</code>。</p>
<p>其中区别在于遍历结果中根节点是在开始还是在结束，我们可以应用相同的思路来解决这道题，注意处理顺序的细微差别。</p>
<span id="more"></span>

<h2 id="思路-1，递归-哈希表"><a href="#思路-1，递归-哈希表" class="headerlink" title="思路 1，递归 + 哈希表"></a>思路 1，递归 + 哈希表</h2><p>同样的思路，我们基于前序遍历的数据构建树，用中序遍历的数据确认节点的位置关系。</p>
<ul>
<li><code>前序遍历</code>：根节点、左节点、右节点</li>
<li><code>中序遍历</code>：左节点、根节点、右节点</li>
</ul>
<p>将构建树的问题分解为在知道根节点的情况下判断它是否有左右节点的问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        inordermap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inorder)):</span><br><span class="line">            inordermap[inorder[i]] = i</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">start, end</span>):</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            node = TreeNode(preorder.pop(<span class="number">0</span>))</span><br><span class="line">            middle = inordermap[node.val]</span><br><span class="line">            node.left = dfs(start, middle - <span class="number">1</span>)</span><br><span class="line">            node.right = dfs(middle + <span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，递归，无哈希表"><a href="#思路-2，递归，无哈希表" class="headerlink" title="思路 2，递归，无哈希表"></a>思路 2，递归，无哈希表</h2><p>我们可以采取遍历检查的方法，用元素的相对位置来做到思路 1 的判断。</p>
<p>在思路 1 中，实际起作用的关键代码是 <code>if start &gt; end:</code>，如果下一个节点的值落在这个区间之内则表示其为左节点 or 右节点。</p>
<p>但实际上我们不关注这个值具体是什么，来换个角度考虑一下：</p>
<ul>
<li>我们先从前序遍历结果中取出第一个值，构建一个节点；</li>
<li>接着我们需要判断前序遍历结果第二个值是否是第一个值的左节点；<ul>
<li>将前序遍历第二个值与中序遍历的第一个值对比；</li>
<li>如果两个值不相等，由于中序遍历先左节点在根节点的顺序，据此可以判断出存在左节点；</li>
<li>而如果两个值相等，那么也就没有左节点存在的空间；</li>
<li>对于存在左节点的情况，我们继续重复这个递归过程；</li>
</ul>
</li>
<li>这时已经判断完左节点；</li>
<li>我们要额外的信息来判断右节点是否存在；<ul>
<li>我们从左到右对中序遍历进行递归遍历；</li>
<li>要知道有没有右节点，首先我们要知道检查到哪个位置为止；</li>
<li>这个位置即边界，要确定这个边界，首先要确定当前有没有父节点；</li>
<li>如果当前没有父节点，这是树的根节点，尝试构建右节点；</li>
<li>如果存在父节点，判断父节点的值是否和前序遍历下一个值相等；</li>
<li>如果相等，我们已到达边界，不存在任何右节点；</li>
<li>如果不相等，还未到达边界，尝试构建右节点；</li>
<li>这里还有一个重要的细节，如果决定父节点？<ul>
<li>首先递归入口有两处：构建左节点和构建右节点时；</li>
<li>构建左节点时：中序遍历当前节点往左都是其左节点，所以当前节点是边界；</li>
<li>构建右节点时：中序遍历当前节点到父节点为止的区间是右节点，所以父节点是边界；</li>
</ul>
</li>
</ul>
</li>
<li>这时遍历完了右节点，当前节点遍历结束；</li>
<li>返回当前节点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        self.indexpre = self.indexin = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">parent</span>):</span></span><br><span class="line">            <span class="keyword">if</span> self.indexin == <span class="built_in">len</span>(inorder):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            node = TreeNode(preorder[self.indexpre])</span><br><span class="line">            self.indexpre += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># if current pre value != current in value,</span></span><br><span class="line">            <span class="comment"># the left child exists</span></span><br><span class="line">            <span class="keyword">if</span> node.val != inorder[self.indexin]:</span><br><span class="line">                node.left = dfs(node)</span><br><span class="line"></span><br><span class="line">            self.indexin += <span class="number">1</span></span><br><span class="line">            <span class="comment"># we&#x27;ve come to the right side,</span></span><br><span class="line">            <span class="comment"># if there&#x27;re more nodes exist before the parent node,</span></span><br><span class="line">            <span class="comment"># the right child exists</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> parent <span class="keyword">or</span> parent.val != inorder[self.indexin]:</span><br><span class="line">                node.right = dfs(parent)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，迭代"><a href="#思路-3，迭代" class="headerlink" title="思路 3，迭代"></a>思路 3，迭代</h2><p>思路 2 可以从递归逻辑转化成迭代逻辑，由于同样逻辑递归算法存在调用栈，算上其使用的额外空间后，对内存空间的使用要高于迭代算法，所以对递归算法的优化可以考虑能否将其转化为迭代算法。</p>
<p>和递归方法不同，在迭代版本中我们使用一个 Stack 来管理当前处理的节点。使用 Stack 的目的是管理当前还未遍历完的节点，这一步相当于将递归过程扁平化了。我们在便利根节点的做节点时，发现左节点有自己的左节点，所以我们将其放入栈中，先处理左节点自己的左节点，然后将其丢出栈，继续往后处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        indexpre, indexin = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        stack, parent = [root], <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>].val == inorder[indexin]:</span><br><span class="line">                parent = stack.pop()</span><br><span class="line">                indexin += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> indexin == <span class="built_in">len</span>(inorder):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            node = TreeNode(preorder[indexpre])</span><br><span class="line">            indexpre += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> parent:</span><br><span class="line">                parent.right = node</span><br><span class="line">            <span class="keyword">elif</span> stack:</span><br><span class="line">                stack[-<span class="number">1</span>].left = node</span><br><span class="line"></span><br><span class="line">            stack.append(node)</span><br><span class="line">            parent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Tree</tag>
        <tag>Binary Tree</tag>
        <tag>Hash Table</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</title>
    <url>/post/leetcode/106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Medium/</url>
    <content><![CDATA[<p>你需要从一棵树的<code>中序遍历</code>数据和<code>后序遍历</code>数据中尝试重新构建出这棵二叉树。</p>
<p>要从树的遍历结果逆向还原这棵树，扁平的 1D 数组的信息量是不够的，但是如果有两个不同的遍历结果做参考，我们可以根据树的遍历过程进行逆向操作。</p>
<p>这道题是使用已知的<code>中序遍历</code>和<code>后序遍历</code>的结果来尝试逆向遍历树的过程。</p>
<span id="more"></span>

<h2 id="思路-1，递归"><a href="#思路-1，递归" class="headerlink" title="思路 1，递归"></a>思路 1，递归</h2><p>已知给定的两组数据的排序方式是中序遍历和后序遍历。</p>
<ul>
<li><code>中序遍历</code>：左节点 -&gt; 根节点 -&gt; 右节点</li>
<li><code>后序遍历</code>：左节点 -&gt; 右节点 -&gt; 根节点</li>
</ul>
<p>在知道根节点的情况比较容易去构建一棵二叉树，所以我们以后序遍历的数据为基础进行树的构建。</p>
<p>但是后序遍历的数据无法告诉我们下一个节点是根节点的左节点还是右节点，这时我们需要到中序遍历的数据中进行检查，如果下一个节点在中序遍历中出现在根节点的左侧，则它是根节点的左节点，反之则是根节点的右节点。</p>
<p>递归过程中，一旦我们明确如何寻找根节点和其左右节点，重复这个过程我们就可以构建整棵树。我们给这个思路补充一些细节：</p>
<ul>
<li>我们要依序检查中序遍历中每个值的下标，为了避免重复计算，我们将中序遍历的值和下标放到一张哈希表，方便下标查询；</li>
<li>根据后序遍历的特性，我们从后序遍历数据的末尾取出（<code>pop</code>）一个值，构建一个节点；</li>
<li>找到根节点的值在中序遍历中的下标位置 <code>middle</code>，这时我们得到两个区间 <code>[start, middle - 1]</code> 和 <code>[middle + 1, end]</code>：<ul>
<li><code>[middle + 1, end]</code>：这个区间构成根节点的右子树，如果存在，我们继续依序从后序遍历数据中取出（<code>pop</code>）下一个根节点的值，细分区间直到遍历完这个区间；</li>
<li><code>[start, middle - 1]</code>：这个区间构成根节点的左子树，按照顺序，右节点遍历结束后，剩下的数据将构成左节点；</li>
</ul>
</li>
<li>我们按照中序遍历数据的下标位置来判断是否还存在下一个节点，如果 <code>middle</code> 和起始位置或结束位置重合则相应的左节点和右节点不存在。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        idx = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># make a hash table to map each value with its index,</span></span><br><span class="line">        <span class="comment"># just for reducing the cost of the index searching</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inorder)):</span><br><span class="line">            idx[inorder[i]] = i</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">start, end</span>):</span></span><br><span class="line">            <span class="comment"># fail case</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="comment"># build root node</span></span><br><span class="line">            node = TreeNode(postorder.pop())</span><br><span class="line">            <span class="comment"># find the middle point</span></span><br><span class="line">            middle = idx[node.val]</span><br><span class="line">            <span class="comment"># build right subtree if exists</span></span><br><span class="line">            node.right = dfs(middle + <span class="number">1</span>, end)</span><br><span class="line">            <span class="comment"># build left subtree if exists</span></span><br><span class="line">            node.left = dfs(start, middle - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，递归，无哈希表"><a href="#思路-2，递归，无哈希表" class="headerlink" title="思路 2，递归，无哈希表"></a>思路 2，递归，无哈希表</h2><p>思路 1 使用一个哈希表做下标映射，实际上这个额外的空间使用存在优化的空间。</p>
<p>在思路 2 中我们使用 2 个指针来对当前的处理进行判断。这个方法和思路 1 还有一点不同，这次我们不再直接修改参数数组。</p>
<ul>
<li>初始化 2 个指针，分别指向中序遍历和后序遍历最后一个值；</li>
<li>在递归过程中，首先拿到后序遍历当前指向的值构建根节点；</li>
<li>将后序遍历指针向前推进一个单位；</li>
<li>判断是否存在右子树：<ul>
<li>根据后序遍历的顺序，我们从后往前推进，构建根节点之后首先要判断是否存在右子树；</li>
<li>根据中序遍历的顺序，如果我们判断中序遍历数据的当前位置不等于目前节点值，则表示存在右子树；</li>
<li>如果存在右子树则进行递归调用，注意右子树在中序遍历中的边界是当前节点；</li>
</ul>
</li>
<li>执行到这里表示右子树已经遍历完成，将中序遍历的指针向前推进一个单位；</li>
<li>判断是否存在左子树：<ul>
<li>判断左子树要考虑边界情况，在中序遍历中如果当前指向的值是父节点的值，则表示不存在左子树；</li>
<li>当然如果不存在父节点时，不需要考虑边界直接尝试构建左子树；</li>
<li>如果存在左子树则进行递归调用，注意左子树在中序遍历中的边界是父节点；</li>
</ul>
</li>
<li>结束递归，返回当前根节点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        self.idx_in = <span class="built_in">len</span>(inorder) - <span class="number">1</span></span><br><span class="line">        self.idx_post = <span class="built_in">len</span>(postorder) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">parent</span>):</span></span><br><span class="line">            <span class="keyword">if</span> self.idx_post &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            root = TreeNode(postorder[self.idx_post])</span><br><span class="line">            self.idx_post -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># current value of inorder != root</span></span><br><span class="line">            <span class="comment"># means the right subtree exists</span></span><br><span class="line">            <span class="keyword">if</span> inorder[self.idx_in] != root.val:</span><br><span class="line">                root.right = dfs(root)</span><br><span class="line"></span><br><span class="line">            self.idx_in -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># current value of inorder != parent</span></span><br><span class="line">            <span class="comment"># means the left subtree may exist</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> parent <span class="keyword">or</span> inorder[self.idx_in] != parent.val:</span><br><span class="line">                root.left = dfs(parent)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，迭代"><a href="#思路-3，迭代" class="headerlink" title="思路 3，迭代"></a>思路 3，迭代</h2><p>递归的调用栈也是额外空间占用，想要进一步优化空间复杂度，可以考虑使用迭代方式构建二叉树。</p>
<p>迭代思路基本和思路 2 一致。</p>
<ul>
<li>准备一个 Stack；</li>
<li>从后序遍历数据构建当前节点放入 Stack；</li>
<li>判断 Stack 顶部节点的值是否等于中序遍历当前的值；<ul>
<li>如果不等于，则表示存在右子树；</li>
<li>这时重复迭代过程将后序遍历下一个值设定为 Stack 顶部节点的右子树，并将其放入 Stack；</li>
<li>如果相等，右子树遍历完成，让 Stack 和中序遍历同时移动到下一个位置；</li>
<li>继续进行上个操作，直到 Stack 顶部的节点不再等于中序遍历当前的值；</li>
<li>将最后一个移出的值作为父节点；</li>
<li>构建后续节点时，如果存在父节点，则当前节点应该设定为父节点的左子树；</li>
</ul>
</li>
<li>将父节点重置，继续下一次迭代，直到所有值遍历结束。</li>
</ul>
<p>核心在于根据中序遍历的数据位置，对后序遍历数据进行迭代：</p>
<ul>
<li>当后序遍历的当前值不等于中序遍历的当前值：存在右子树；</li>
<li>当后续遍历的当前值等于中序遍历的当前值：后序遍历的下一个值是左子树的根节点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        root, parent = TreeNode(postorder.pop()), <span class="literal">None</span></span><br><span class="line">        stack = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> inorder:</span><br><span class="line">            <span class="comment"># skip visited nodes</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>].val == inorder[-<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># set the last visited node as parent</span></span><br><span class="line">                parent = stack.pop()</span><br><span class="line">                <span class="comment"># move on</span></span><br><span class="line">                inorder.pop()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># finish the process if no value left</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> inorder:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># build current node</span></span><br><span class="line">            curr = TreeNode(postorder.pop())</span><br><span class="line"></span><br><span class="line">            <span class="comment"># set current node as the left child if parent exists,</span></span><br><span class="line">            <span class="comment"># or set it as the right child of the top of the stack</span></span><br><span class="line">            <span class="keyword">if</span> parent:</span><br><span class="line">                parent.left = curr</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack[-<span class="number">1</span>].right = curr</span><br><span class="line"></span><br><span class="line">            stack.append(curr)</span><br><span class="line">            parent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>时间复杂度上三个方法差异不大，空间复杂度上迭代方法使用的内存空间是最小的，其次是思路 2 的空间优化方法。</p>
<p>这道题的重点在于观察和理解中序遍历和后序遍历在实际运用中的差异，并利用这个差异还原二叉树。可见，虽然这两种遍历顺序从逻辑上很好理解，但是实际运用过程中，数据层级的嵌套，结构的平衡性都会提高实际计算的复杂度。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Tree</tag>
        <tag>Binary Tree</tag>
        <tag>Hash Table</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>1074. Number of Submatrices That Sum to Target (Hard)</title>
    <url>/post/leetcode/1074-Number-of-Submatrices-That-Sum-to-Target-Hard/</url>
    <content><![CDATA[<p>矩阵求和问题。给定一个矩阵 <code>matrix</code> 和一个目标值 <code>target</code>，求和为 <code>target</code> 的子矩阵的数量。</p>
<p>这是典型的前缀和应用场景，我们分别用两种思路应用前缀和来解决这个问题。</p>
<span id="more"></span>

<h2 id="Understanding-the-Problem"><a href="#Understanding-the-Problem" class="headerlink" title="Understanding the Problem"></a>Understanding the Problem</h2><p>With solutions both in Python and Java.</p>
<p>这是一道困难题，先读题。</p>
<blockquote>
<p>Given a <code>matrix</code> and a <code>target</code>, return the number of non-empty submatrices that sum to target.</p>
<p>A submatrix <code>x1, y1, x2, y2</code> is the set of all cells <code>matrix[x][y]</code> with <code>x1 &lt;= x &lt;= x2</code> and <code>y1 &lt;= y &lt;= y2</code>.</p>
<p>Two submatrices (<code>x1, y1, x2, y2</code>) and (<code>x1&#39;, y1&#39;, x2&#39;, y2&#39;</code>) are different if they have some coordinate that is different: for example, if <code>x1</code> != <code>x1&#39;</code>.</p>
</blockquote>
<p>理解一下。</p>
<ul>
<li>参数是 1 个矩阵，一个目标值；</li>
<li>需要返回的是子矩阵的数量，这些子矩阵需要满足：<ul>
<li>非空；</li>
<li>和等于目标值。</li>
</ul>
</li>
</ul>
<p>看看例子。</p>
<p>Example 1:</p>
<p><img src="/images/leetcode/1074.eg.jpg" alt="1074.eg.jpg"></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The four 1x1 submatrices that only contain 0.</span><br></pre></td></tr></table></figure>

<p>这个例子中矩阵如图，需要找出所有和为 0 的子矩阵。可见只有四个角的元素满足，这四个子矩阵只能有一个元素。</p>
<p>Example 2:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Input: matrix = [[1,-1],[-1,1]], target = 0</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">y1</th>
<th align="center">y2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>x1</strong></td>
<td align="center">1</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center"><strong>x2</strong></td>
<td align="center">-1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>这个例子中，所有元素字面量都不为 0，所以排除 1x1 子矩阵之后，只有尺寸为 2x1 / 1x2 和 2x2 的子矩阵的和可能为 0。</p>
<p>我们来输出一下 2 个元素的组合（2x1/1x2），去除对角线的两种不满足条件的组合，可以发现剩余的四种组合的和都为 0。而唯一一种 2x2 的组合我们也能一眼看出来其和为 0，所以这个例子的答案是 5。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, <span class="built_in">sum</span>(x)) <span class="keyword">for</span> x <span class="keyword">in</span> combinations([<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>], <span class="number">2</span>)]</span><br><span class="line">[((<span class="number">1</span>, -<span class="number">1</span>), <span class="number">0</span>), ((<span class="number">1</span>, <span class="number">1</span>), <span class="number">2</span>), ((<span class="number">1</span>, -<span class="number">1</span>), <span class="number">0</span>), ((-<span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>), ((-<span class="number">1</span>, -<span class="number">1</span>), -<span class="number">2</span>), ((<span class="number">1</span>, -<span class="number">1</span>), <span class="number">0</span>)]</span><br></pre></td></tr></table></figure>

<p>Example 3:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Input: matrix = [[904]], target = 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p>当不存在满足条件的子矩阵时返回 0。</p>
<p>这道题的限制条件比较重要。</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= matrix.length &lt;= 100</code></li>
<li><code>1 &lt;= matrix[0].length &lt;= 100</code></li>
<li><code>-1000 &lt;= matrix[i] &lt;= 1000</code></li>
<li><code>-10^8 &lt;= target &lt;= 10^8</code></li>
</ul>
<p>矩阵的尺寸从最小一个元素到最大 100*100 个元素，并且元素的值可能为负数，这意味着没有取巧的办法，对于每一种子矩阵的组合我们都必须算出和才能断定是否符合条件。</p>
<h2 id="思路-amp-Solutions"><a href="#思路-amp-Solutions" class="headerlink" title="思路 &amp; Solutions"></a>思路 &amp; Solutions</h2><p><strong>递归方法（X 超时）</strong></p>
<p>乍一看题可能你会感觉没有思路，难道只能：</p>
<ul>
<li>遍历长宽得出所有子矩阵尺寸；</li>
<li>遍历每种尺寸去匹配可能出现的子矩阵，硬算矩阵和。</li>
</ul>
<p>（没错，我一开始这样做的…）</p>
<p>这样确实可以计算出答案，问题是计算量指数爆炸，100*100 的 input 必然超过时间限制。</p>
<p><strong>动态规划（DP）</strong></p>
<p>仔细一看这道题有给一个提示，也别客气直接来看看提示。</p>
<blockquote>
<p>Using a 2D prefix sum, we can query the sum of any submatrix in O(1) time. Now for each (r1, r2), we can find the largest sum of a submatrix that uses every row in [r1, r2] in linear time using a sliding window.</p>
</blockquote>
<p>提示给出的思路分为两步：</p>
<ul>
<li>求出矩阵每个元素的前缀和（prefix sum），这一步时间复杂度是 O(n)，但是后续查询某个子矩阵的和只需要 O(1)；</li>
<li>用滑动窗口（Sliding Window）遍历每一个子矩阵，检查和是否等于目标值。</li>
</ul>
<p>要应用这个思路，我们可以得到两种方法。</p>
<h3 id="方法一，计算矩阵所有元素的前缀和"><a href="#方法一，计算矩阵所有元素的前缀和" class="headerlink" title="方法一，计算矩阵所有元素的前缀和"></a>方法一，计算矩阵所有元素的前缀和</h3><ul>
<li>首先计算矩阵所有元素的前缀和；<ul>
<li>prefixSum[x][y] = matrix[x][y] + prefixSum[x-1][y] + prefixSum[x][y-1] - prefixSum[x-1][y-1]<ul>
<li><code>prefixSum[x][y]</code> -&gt; 以<code>(0, 0)</code>为左上角，矩阵中对应位置为右下角的子矩阵的和；</li>
<li><code>matrix[x][y]</code> -&gt; 矩阵对应位置的元素的值；</li>
<li><code>prefixSum[x-1][y]</code> -&gt; 矩阵上一行同列的值，这个值已经计算过了；</li>
<li><code>prefixSum[x][y-1]</code> -&gt; 矩阵上一列同行的值，这个值也已经计算过了；</li>
<li><code>prefixSum[x-1][y-1]</code> -&gt; 需要注意的是，这个值在上面两个子矩阵中被计算了两次，所以这里减去一次。</li>
</ul>
</li>
</ul>
</li>
<li>使用滑动窗口来遍历行或列；<ul>
<li>比如当遍历行时，对于 <code>(r1, r2)</code> （即第一行和第二行中的子矩阵）的情况，我们逐列遍历：<ul>
<li>初始化一个哈希表，初始化 <code>key</code> 为 0 时的值为 1，这一步是为了处理子矩阵的和刚好为目标值的情况；</li>
<li>我们查询 <code>((0,0), (1, 1))</code> 的和，并检查这个和减去目标值后的值在哈希表中对应的值；<ul>
<li>子矩阵的和减去目标值后的数，其实就是之前记录过的和为该值的子矩阵；</li>
<li>如果存在的话，那么意味着现在检查的这个子矩阵减去这个子矩阵，就能得到一个满足条件的子矩阵；</li>
<li>由于在下一步我们按列将每次检查的结果存入列哈希表中，哈希表的 <code>key</code> 对应的值是指 <code>key</code> 出现的次数；</li>
<li>这也就意味着如果同一个值出现了多次，那么就存在这么多子矩阵可以满足条件，所以我们将答案加上哈希表中对应的次数。</li>
</ul>
</li>
<li>将其作为 <code>key</code> 存入一个哈希表中，将值+<code>1（key</code> 不存在的情况设为 1）；</li>
<li>对行的组合重复这一步。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>下面是 Java 代码可以配合理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length,</span><br><span class="line">            cols = matrix[<span class="number">0</span>].length,</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化一个前缀和2D数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] prefixSum = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为避免处理数组越界，我们对第一行数据单独进行遍历</span></span><br><span class="line">        prefixSum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; cols; c++) &#123;</span><br><span class="line">            <span class="comment">// 对于第一行数据，当前值加等于前一个值</span></span><br><span class="line">            prefixSum[<span class="number">0</span>][c] = prefixSum[<span class="number">0</span>][c-<span class="number">1</span>] + matrix[<span class="number">0</span>][c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剩下的数据逐行逐列遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; rows; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">                <span class="comment">// 对应位置的前缀和等于上一行对应位置的值和上一列对应位置的值之和，减去重复计算的区域的值</span></span><br><span class="line">                prefixSum[r][c] = matrix[r][c] + prefixSum[r-<span class="number">1</span>][c]</span><br><span class="line">                    + (c == <span class="number">0</span> ? <span class="number">0</span> : prefixSum[r][c-<span class="number">1</span>] - prefixSum[r-<span class="number">1</span>][c-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算完前缀和，我们对行进行组合遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sr = <span class="number">0</span>; sr &lt; rows; sr++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> er = sr; er &lt; rows; er++) &#123;</span><br><span class="line">                <span class="comment">// 初始化一个哈希表来存储次数</span></span><br><span class="line">                Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">                    <span class="comment">// 计算第一列到当前列组成的矩阵的和</span></span><br><span class="line">                    <span class="keyword">int</span> cur = prefixSum[er][c] - (sr == <span class="number">0</span> ? <span class="number">0</span> : prefixSum[sr-<span class="number">1</span>][c]);</span><br><span class="line">                    <span class="comment">// 查询当前窗口中，需要减去的矩阵是否存在/存在几个</span></span><br><span class="line">                    <span class="keyword">if</span> (map.get(cur - target) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        ans += map.get(cur - target);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将当前矩阵的值存入哈希表，将次数+1</span></span><br><span class="line">                    map.put(cur, map.get(cur) == <span class="keyword">null</span> ? <span class="number">1</span> : map.get(cur) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二，仅按行或列计算前缀和"><a href="#方法二，仅按行或列计算前缀和" class="headerlink" title="方法二，仅按行或列计算前缀和"></a>方法二，仅按行或列计算前缀和</h3><ul>
<li>与方法一最大的区别在于，方法二不去计算一个 2D 矩阵的前缀和，而是逐行计算这一行的前缀和；</li>
<li>这个前缀和数组由循环外部的变量，变成列循环内部的变量，随着基础行的变化而重置；</li>
<li>除去计算前缀和的变化，在滑动窗口内的操作与方法一一致，因此降低了空间复杂度。</li>
</ul>
<p>下面是 Python 帮助理解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubmatrixSumTarget</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        rows, cols, ans = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> sr <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            colsum = [<span class="number">0</span>] * cols</span><br><span class="line">            <span class="keyword">for</span> er <span class="keyword">in</span> <span class="built_in">range</span>(sr, rows):</span><br><span class="line">                d, cur = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;, <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                    colsum[c] += matrix[er][c]</span><br><span class="line">                    cur += colsum[c]</span><br><span class="line">                    ans += d.get(cur-target, <span class="number">0</span>)</span><br><span class="line">                    d[cur] = d.get(cur, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一道困难的题，难点在于把计算计划到规定的复杂度中。</p>
<p>要得到答案，需要一些前置的知识：</p>
<ul>
<li>前缀和的应用；</li>
<li>动态规划的应用；</li>
<li>滑动窗口的应用。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Prefix Sum</tag>
        <tag>Hash Table</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>109. Convert Sorted List to Binary Search Tree (Medium)</title>
    <url>/post/leetcode/109-Convert-Sorted-List-to-Binary-Search-Tree-Medium/</url>
    <content><![CDATA[<p>你有一个链表的 <code>head</code> 元素，链表数组按照升序排列，现在你需要实现一个程序将其转换为高度平衡的二叉查找树。</p>
<p>对这道题来说，高度平衡的二叉树定义为所有节点的子节点深度相差不大于 1。</p>
<p>题目的难点在于你不知道链表的长度。我们从几个思路讨论如何解决这道题。</p>
<span id="more"></span>

<h2 id="思路-1，快慢指针"><a href="#思路-1，快慢指针" class="headerlink" title="思路 1，快慢指针"></a>思路 1，快慢指针</h2><p>比较简洁的解法是快慢指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree(head, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">tree</span><span class="params">(ListNode b, ListNode e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == e) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = b;</span><br><span class="line">        ListNode slow = b;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != e &amp;&amp; fast.next.next != e) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        root.left = tree(b, slow);</span><br><span class="line">        root.right = tree(slow.next, e);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python 强行和官方答案匹配。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span>(<span class="params">self, head: ListNode</span>) -&gt; TreeNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tree</span>(<span class="params">head, end</span>):</span></span><br><span class="line">            <span class="keyword">if</span> head == end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            fast = slow = head</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> fast.<span class="built_in">next</span> != end:</span><br><span class="line">                fast, slow = fast.<span class="built_in">next</span>, slow.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> fast.<span class="built_in">next</span> != end:</span><br><span class="line">                    fast = fast.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            root = TreeNode(slow.val)</span><br><span class="line">            root.left = tree(head, slow)</span><br><span class="line">            root.right = tree(slow.<span class="built_in">next</span>, end)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tree(head, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，-长度二分"><a href="#思路-2，-长度二分" class="headerlink" title="思路 2， 长度二分"></a>思路 2， 长度二分</h2><p>下面是基于长度二分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span>(<span class="params">self, head: ListNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        self.head, n = head, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">b, e</span>):</span></span><br><span class="line">            <span class="keyword">if</span> b &gt;= e:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            m = b + e &gt;&gt; <span class="number">1</span></span><br><span class="line">            left = dfs(b, m)</span><br><span class="line">            root = TreeNode(self.head.val, left)</span><br><span class="line">            self.head = self.head.<span class="built_in">next</span></span><br><span class="line">            root.right = dfs(m + <span class="number">1</span>, e)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, n)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
        <tag>Linked List</tag>
        <tag>Divider and Conquer</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>112. Path Sum (Easy)</title>
    <url>/post/leetcode/112-Path-Sum-Easy/</url>
    <content><![CDATA[<p>二叉树问题。求是否存在和目标值一致的路径和。</p>
<p>路径和指的是从根节点到叶子节点的路径的值相加的结果。</p>
<p>看上去这道题适合 DFS 一条路径一条路径的遍历解决。</p>
<span id="more"></span>

<h2 id="思路-1，递归，前序遍历"><a href="#思路-1，递归，前序遍历" class="headerlink" title="思路 1，递归，前序遍历"></a>思路 1，递归，前序遍历</h2><p>一层一层求和直到叶子节点，判断是否和目标一致。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node, curr</span>):</span></span><br><span class="line">            curr += node.val</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> curr == targetSum</span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">and</span> dfs(node.left, curr):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">and</span> dfs(node.right, curr):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，另一种前序遍历写法"><a href="#思路-2，另一种前序遍历写法" class="headerlink" title="思路 2，另一种前序遍历写法"></a>思路 2，另一种前序遍历写法</h2><p>相同思路，另一种写法。这次我们用解题函数自身作为 DFS 函数，也不再进行求和判断，相反我们每次遍历从目标值中减去遇到的值。</p>
<p>这两种方法没有本质区别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.val == targetSum:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.hasPathSum(root.left, targetSum - root.val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.hasPathSum(root.right, targetSum - root.val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="思路-3，迭代"><a href="#思路-3，迭代" class="headerlink" title="思路 3，迭代"></a>思路 3，迭代</h2><p>有递归的地方就有 Stack，来试试用迭代的方式实现这个过程。</p>
<p>迭代的方式注意点在于我们需要同时保存节点和累积值。</p>
<p>这个思路的逻辑看上去要更简洁。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        stack = [(root, root.val)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, val = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> val == targetSum:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, node.left.val + val))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, node.right.val + val))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>114. Flatten Binary Tree to Linked List (Medium)</title>
    <url>/post/leetcode/114-Flatten-Binary-Tree-to-Linked-List-Medium/</url>
    <content><![CDATA[<p>将二叉树结构数据扁平化为链表，采用前序遍历（pre-order traversal）顺序。</p>
<p>题目要求修改二叉树结构去构成数组，在这个限制下我们要对前序遍历做一些修改才能解决这道题。</p>
<span id="more"></span>

<h2 id="思路-1，有序递归"><a href="#思路-1，有序递归" class="headerlink" title="思路 1，有序递归"></a>思路 1，有序递归</h2><p>重复先左后右的递归，用递归方法实现 O(1) 的难点在于将右节点挂在左节点的末尾，这里我们将递归函数的返回值设为递归最后一个元素，来解决这个难题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_flatten</span>(<span class="params">node</span>):</span></span><br><span class="line">            left, right = node.left, node.right</span><br><span class="line">            <span class="keyword">if</span> left:</span><br><span class="line">                left = _flatten(left)</span><br><span class="line">                left.right = node.right</span><br><span class="line">                node.right = node.left</span><br><span class="line">                node.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> right:</span><br><span class="line">                right = _flatten(right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = left</span><br><span class="line">            <span class="keyword">return</span> right <span class="keyword">if</span> right <span class="keyword">else</span> node</span><br><span class="line"></span><br><span class="line">        _flatten(root)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，学习题解的思路"><a href="#思路-2，学习题解的思路" class="headerlink" title="思路 2，学习题解的思路"></a>思路 2，学习题解的思路</h2><p>如果我们发现有左节点，找到左节点最下端的右节点，将 root 的右节点挂在上面，将左节点替换为 root 的右节点，重置 root 的左节点为空，root 节点向右进一位，检查左节点，如此往复，直到最后一个左节点消失，二分树转链表结束。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                left = root.left</span><br><span class="line">                <span class="keyword">while</span> left.right:</span><br><span class="line">                    left = left.right</span><br><span class="line">                left.right = root.right</span><br><span class="line">                root.right = root.left</span><br><span class="line">                root.left = <span class="literal">None</span></span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，从下而上"><a href="#思路-3，从下而上" class="headerlink" title="思路 3，从下而上"></a>思路 3，从下而上</h2><p>和之前思路不同之处在于，这次我们从下而上的去将二叉树转化为链表，转化的顺序是 right -&gt; left -&gt; node，因为我们需要先 node，再 left，再 right 的顺序去组成这个链表。我们用递归来帮助完成这个过程，使用一个全局变量 <code>head</code> 来储存当前处理的节点，因为我们已经确保有序递归，所以 <code>head</code> 将从空（链表最后一个节点的子节点）开始，每次指向上一个节点，直到达到 <code>root</code> 节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                f(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                f(node.left)</span><br><span class="line">            node.left, node.right, self.head = <span class="literal">None</span>, self.head, node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            f(root)</span><br></pre></td></tr></table></figure>

<p>相同思路的 Java 代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) f(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) f(node.right);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) f(node.left);</span><br><span class="line">        node.left = <span class="keyword">null</span>; node.right = head; head = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JS 代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> flatten = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> f = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right) f(node.right);</span><br><span class="line">    <span class="keyword">if</span> (node.left) f(node.left);</span><br><span class="line">    (node.left = <span class="literal">null</span>), (node.right = head), (head = node);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (root) f(root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
        <tag>Stack</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>116. Populating Next Right Pointers in Each Node (Medium)</title>
    <url>/post/leetcode/116-Populating-Next-Right-Pointers-in-Each-Node-Medium/</url>
    <content><![CDATA[<p>你需要给一棵完全二叉树的每个一节点添加一个 <code>next</code> 指针，指向同一层的右边一个节点。</p>
<p>题目中完全二叉树的定义：所有叶子节点都在同一层，除了叶子节点外所有节点都拥有左右子节点，节点的数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目标是给所有节点的 <code>next</code> 赋值，如果不存在则为空，默认为空。</p>
<span id="more"></span>

<h2 id="思路-1，BFS"><a href="#思路-1，BFS" class="headerlink" title="思路 1，BFS"></a>思路 1，BFS</h2><p>我们需要知道每一层有多少节点才能完成这道题的目标，一个简单的宽度优先的层序遍历算法可以解决这道题。</p>
<p>具体可以参考 <code>No.102</code>，我们用一个 Stack 存每一层的节点，每一次迭代遍历完这一层的节点，同时放入下一层的节点。</p>
<p>这个简单的算法在时间复杂度上还有优化的空间，因为我们并未将完全二叉树这个特性纳入考虑的范围。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stack), <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                node = stack.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> i != <span class="number">1</span>:</span><br><span class="line">                    node.<span class="built_in">next</span> = stack[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack.append(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，DFS"><a href="#思路-2，DFS" class="headerlink" title="思路 2，DFS"></a>思路 2，DFS</h2><p>DFS 的思路中，我们只要知道 2 个相邻的节点，就能对所有节点进行遍历。</p>
<p>比如我们知道当前节点 <code>curr</code> 和它的下一个节点 <code>next</code>，要保证当前的节点和其子节点相互连接：</p>
<ul>
<li>需要将 <code>curr.next</code> 设置为 <code>next</code>；</li>
<li>需要将 <code>curr.left</code> 和 <code>curr.right</code> 作为参数继续递归；</li>
<li>需要将 <code>curr.right</code> 和 <code>next.left</code> 作为参数继续递归；</li>
<li>如果 <code>next</code> 不存在，需要将 <code>curr.right</code> 和 <code>None</code> 作为参数继续递归（因为需要递归子节点）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">curr, nxt</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> curr:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            curr.<span class="built_in">next</span> = nxt</span><br><span class="line">            dfs(curr.left, curr.right)</span><br><span class="line">            dfs(curr.right, nxt.left <span class="keyword">if</span> nxt <span class="keyword">else</span> <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">return</span> curr</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，BFS-空间优化"><a href="#思路-3，BFS-空间优化" class="headerlink" title="思路 3，BFS 空间优化"></a>思路 3，BFS 空间优化</h2><p>思路 1 和思路 2 效率上相差无几，区别仅在于遍历的顺序。但是使用 Stack 的 BFS 和使用递归调用栈的 DFS 算法都使用了额外的 O(n) 的空间。</p>
<p>由于树的节点多了一个 <code>next</code> 属性，让我们能知道当前节点的层级中下一个节点是谁，相当于每一层的节点连城一个链表，这个数据结构让我们可以避免使用 Stack 也能完成层序遍历。</p>
<p>具体的思路就是，只要我们知道 2 个父节点，我们就可以知道这一层的所有节点。</p>
<ul>
<li>从 <code>root</code> 的子节点开始迭代，我们先保留 <code>root.left</code> 的引用，这将作为下一层的开始位置；</li>
<li>根据完全二叉树的特性，我们判断当前节点和其左节点存在才进行遍历；</li>
<li>如果存在，现将当前节点的左右子节点关联，然后将右节点和当前节点的 <code>next.left</code> 关联；</li>
<li>将 <code>next</code> 设为当前节点继续遍历，直到不再存在 <code>next</code>；</li>
<li>这一层遍历节点，将最初保存的下一层开始位置设为当前节点继续迭代。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="comment"># start point of the next level</span></span><br><span class="line">            nxt = curr.left</span><br><span class="line">            <span class="comment"># because its a perfect binary tree,</span></span><br><span class="line">            <span class="comment"># only connect its children if any of them exists</span></span><br><span class="line">            <span class="keyword">while</span> curr <span class="keyword">and</span> curr.left:</span><br><span class="line">                curr.left.<span class="built_in">next</span> = curr.right</span><br><span class="line">                curr.right.<span class="built_in">next</span> = curr.<span class="built_in">next</span>.left <span class="keyword">if</span> curr.<span class="built_in">next</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># set up the start point of the next level</span></span><br><span class="line">            curr = nxt</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>思路 1 和思路 2 在时间复杂度和空间复杂度上相似，LeetCode 的测试集的结果也不相上下。</p>
<p>思路 3 优化了空间复杂度，在同样测试集下平均结果要比前两者稍好，但是目测测试集的数据量不会很大，所以根据系统资源情况执行结果偶尔会有波动。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>117. Populating Next Right Pointers in Each Node II (Medium)</title>
    <url>/post/leetcode/117-Populating-Next-Right-Pointers-in-Each-Node-II-Medium/</url>
    <content><![CDATA[<p>在 <code>No.116</code> 中我们解决了在完全二叉树的情况下将每一层的节点向右关联的需求，这道题需要解决同样的需求，但是 <code>input</code> 不再确保是完全二叉树了。也就是说，当前节点可能不存在左节点、右节点或者左右节点都不存在，它的相邻节点也是一样，甚至所谓“相邻”其实也隔了好几个分支。</p>
<p>我们需要加入更多条件分歧来解决这道题。</p>
<span id="more"></span>

<h2 id="思路-1，迭代-BFS"><a href="#思路-1，迭代-BFS" class="headerlink" title="思路 1，迭代 BFS"></a>思路 1，迭代 BFS</h2><p>尝试空间复杂度 O(1) 的算法解决这道题。</p>
<p>首先这道题虽然和 <code>No.116</code> 需求一致，但是由于数据的变化，我们需要先抛开它的解题思路，换一个角度思考一下这个问题。</p>
<p>这里有一个思考陷阱：不要去找下一个存在的节点。</p>
<p>或许你会拓展 116 的思路，在知道当前存在的节点的情况下，尝试寻找它的 <code>next</code> 应该是谁。但是这中间存在太多条件，与其穷举这些条件，不如换个思路：去“找”上一个存在的节点。</p>
<ul>
<li>实现一个 BFS 算法，我们按层序遍历，因为存在 <code>next</code> 属性绑定，省去 Stack 操作；</li>
<li>遍历这层每一个节点，如果其存在子节点；<ul>
<li>检查 <code>prev</code> 是否存在，如果存在则将当前子节点设置为它的 <code>next</code>；</li>
<li>将当前子节点为 <code>prev</code>，最为后面节点的前置；</li>
</ul>
</li>
<li>用一个变量保存每一层的第一个节点 <code>head</code>，如果这一层遍历结束，将 <code>head</code> 作为下一层迭代的开始。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        head, prev, curr = <span class="literal">None</span>, <span class="literal">None</span>, root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">while</span> curr:</span><br><span class="line">                <span class="keyword">if</span> curr.left:</span><br><span class="line">                    <span class="keyword">if</span> prev:</span><br><span class="line">                        <span class="comment"># connect currrent node with previous one</span></span><br><span class="line">                        prev.<span class="built_in">next</span> = curr.left</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># or set current one as the first one</span></span><br><span class="line">                        head = curr.left</span><br><span class="line">                    prev = curr.left</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> curr.right:</span><br><span class="line">                    <span class="keyword">if</span> prev:</span><br><span class="line">                        <span class="comment"># connect currrent node with previous one</span></span><br><span class="line">                        prev.<span class="built_in">next</span> = curr.right</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># or set current one as the first one</span></span><br><span class="line">                        head = curr.right</span><br><span class="line">                    prev = curr.right</span><br><span class="line"></span><br><span class="line">                <span class="comment"># iterate the next node</span></span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># setup the next level</span></span><br><span class="line">            curr = head</span><br><span class="line">            head = prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，DFS"><a href="#思路-2，DFS" class="headerlink" title="思路 2，DFS"></a>思路 2，DFS</h2><p>等等，题目提示递归是 OK 的， 对这道题我们可以不考虑调用栈的内存占用，“找下一个”的方法是可以实现的，何不试试这个方法？</p>
<p>对于每个跟节点我们需要处理：</p>
<ul>
<li>如果左节点存在：<ul>
<li>如果右节点存在，连接它们；</li>
<li>如果右节点不存在，连接左节点和下一个存在的节点；</li>
</ul>
</li>
<li>接着接触如果右节点存在：<ul>
<li>将右节点和下一个存在的节点连接；</li>
</ul>
</li>
<li>对右节点递归，顺序很重要：<ul>
<li>从上至下、从右往左遍历才能保证 <code>next</code> 被引用时指向正确的节点；</li>
</ul>
</li>
<li>对左节点递归。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                <span class="keyword">return</span> node.left</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> node.right</span><br><span class="line">            <span class="keyword">return</span> find(node.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    node.left.<span class="built_in">next</span> = node.right</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node.left.<span class="built_in">next</span> = find(node.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                node.right.<span class="built_in">next</span> = find(node.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">            dfs(node.right)</span><br><span class="line">            dfs(node.left)</span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>118. Pascal&#39;s Triangle (Easy)</title>
    <url>/post/leetcode/118-Pascal-s-Triangle-Easy/</url>
    <content><![CDATA[<p>杨辉三角问题。在杨辉三角中每个元素 <code>i</code> 的值由上一行同位置 <code>i</code> 的值加上上一行前一个位置 <code>i-1</code> 的值决定。</p>
<p>你需要实现一个程序接受一个行数，返回到这行位置的杨辉三角数组。枚举问题，DP 解决。</p>
<span id="more"></span>

<h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><p>杨辉三角，做完这题发现，这就是 DP 呀，简明扼要。思路就是用当前行计算下一行，每一个值都等于上一行相同位置加上前一位，注意首位两个特殊 case 即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">self, numRows: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        ans = [[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, numRows):</span><br><span class="line">            curr, nxt = ans[-<span class="number">1</span>], []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i - <span class="number">1</span> &lt; <span class="number">0</span> <span class="keyword">or</span> i == n:</span><br><span class="line">                    nxt.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nxt.append(curr[i - <span class="number">1</span>] + curr[i])</span><br><span class="line">            ans.append(nxt)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>1192. Critical Connections in a Network (Hard)</title>
    <url>/post/leetcode/1192-Critical-Connections-in-a-Network-Hard/</url>
    <content><![CDATA[<p>图论问题。一共有 <code>n</code> 台服务器，我们将存在于任意 2 台服务器之间链接定义为边，可以构成一张无向图。</p>
<p>给定一个 <code>connections</code> 数组定义这个服务器网络的所有链接（边），在这个网络上任何节点都可以直接或间接的相互访问。</p>
<p>关键链接指的是这个网络中的某一个节点如果被移除，将导致一部分服务器无法访问到另一部分。</p>
<p>要求找到所有关键链接。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>解题思路需要 review 和重新记录。理论上思路是依次尝试移除一个链接，然后检查所有服务器是否还能互联。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">criticalConnections</span>(<span class="params">self, n: <span class="built_in">int</span>, connections: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="comment"># make adjacency-list of connections</span></span><br><span class="line">        adj = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> connections:</span><br><span class="line">            adj[u].append(v)</span><br><span class="line">            adj[v].append(u)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># define dfs</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">u, prev, <span class="built_in">id</span>, ids, ans</span>):</span></span><br><span class="line">            ids[u] = <span class="built_in">id</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> adj[u]:</span><br><span class="line">                <span class="keyword">if</span> v == prev:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> ids[v] == -<span class="number">1</span>:</span><br><span class="line">                    ids[u] = <span class="built_in">min</span>(ids[u], dfs(v, u, <span class="built_in">id</span>+<span class="number">1</span>, ids, ans))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ids[u] = <span class="built_in">min</span>(ids[u], ids[v])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">id</span> != <span class="number">0</span> <span class="keyword">and</span> ids[u] == <span class="built_in">id</span>:</span><br><span class="line">                ans.append([u, prev])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ids[u]</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        ids = [-<span class="number">1</span>] * n</span><br><span class="line">        dfs(<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, ids, ans)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>Graph</tag>
        <tag>Biconnected Component</tag>
        <tag>Need Review</tag>
      </tags>
  </entry>
  <entry>
    <title>120. Triangle (Medium)</title>
    <url>/post/leetcode/120-Triangle-Medium/</url>
    <content><![CDATA[<p>你有一个三角形形状的 2D 数组，你需要找到从最顶层走到最底层的最短路径。</p>
<p>限制是每一步你只能下一层，且每一步你只能选择下一层的同下标位置或者下标 +1 位置。</p>
<blockquote>
<p>Given a <code>triangle</code> array, return the minimum path sum from top to bottom.</p>
<p>For each step, you may move to an adjacent number of the row below. More formally, if you are on index <code>i</code> on the current row, you may move to either index <code>i</code> or index <code>i + 1</code> on the next row.</p>
</blockquote>
<p>看看例子才能更好理解题目，这题看上去需要计算所有可能才能知道答案，或许是 DP 的用武之地。</p>
<span id="more"></span>

<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: The triangle looks like:</span><br><span class="line">   2</span><br><span class="line">  3 4</span><br><span class="line"> 6 5 7</span><br><span class="line">4 1 8 3</span><br><span class="line">The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: triangle = [[-10]]</span><br><span class="line">Output: -10</span><br></pre></td></tr></table></figure>

<p>Constraints:</p>
<p>1 &lt;= triangle.length &lt;= 200<br>triangle[0].length == 1<br>triangle[i].length == triangle[i - 1].length + 1<br>-104 &lt;= triangle[i][j] &lt;= 104</p>
<h2 id="思路-amp-Solutions"><a href="#思路-amp-Solutions" class="headerlink" title="思路 &amp; Solutions"></a>思路 &amp; Solutions</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span>(<span class="params">self, triangle: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">for</span> depth <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(triangle)):</span><br><span class="line">            lastsz = <span class="built_in">len</span>(triangle[depth-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">for</span> pos, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(triangle[depth]):</span><br><span class="line">                <span class="keyword">if</span> pos == <span class="number">0</span>:</span><br><span class="line">                    prev = triangle[depth-<span class="number">1</span>][pos]</span><br><span class="line">                <span class="keyword">elif</span> pos == lastsz:</span><br><span class="line">                    prev = triangle[depth-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    prev = <span class="built_in">min</span>(triangle[depth-<span class="number">1</span>][pos-<span class="number">1</span>], triangle[depth-<span class="number">1</span>][pos])</span><br><span class="line">                triangle[depth][pos] = x + prev</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(triangle[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>128. Longest Consecutive Sequence (Medium)</title>
    <url>/post/leetcode/128-Longest-Consecutive-Sequence-Medium/</url>
    <content><![CDATA[<p>你有一个未排序的整数数组 <code>nums</code>，你要在 O(n) 时间复杂度内找到最长的连续子序列，返回其长度</p>
<p><code>nums</code> 数组的元素可以构成诺干个连续的子数组，我们需要找到最大的子数组，返回其长度。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要找到最大的子数组，首先我们要找到子数组的第一个元素，可以将 <code>nums</code> 转成一个 HashSet，然后遍历它：</p>
<ul>
<li>查询每个元素的前一个值（<code>n - 1</code>）是否存在；<ul>
<li>存在则表示这个元素不是子数组的最小值，直接跳过；</li>
<li>不存在时，循环查询这个值的下一个值是否存在（<code>n + 1</code>），直到下一个值不存在为止；</li>
<li>在查询下一个值的过程中保持一个计数器，一直计数到不存在下一个值；</li>
<li>将其和全局变量取一个最大值；</li>
</ul>
</li>
<li>返回全局最大值。</li>
</ul>
<p>因为我们只在子数组的最小值开始遍历，所以能避免不需要的运算，让时间复杂度在 O(n)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, nums = <span class="number">0</span>, <span class="built_in">set</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> n + <span class="number">1</span> <span class="keyword">in</span> nums:</span><br><span class="line">                    n, count = n + <span class="number">1</span>, count + <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, count)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title>1302. Deepest Leaves Sum (Medium)</title>
    <url>/post/leetcode/1302-Deepest-Leaves-Sum-Medium/</url>
    <content><![CDATA[<p>求二叉树最深层的所有节点的值之和。二叉树层序遍历的应用场景。</p>
<p>虽然题目的 tag 包含 DFS，但是感觉用 DFS 思路比 BFS 还要复杂并且低效，所以这题我们只讨论 BFS 思路。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>计算每一层的和，直到最后一层完成计算，返回计算的和。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deepestLeavesSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                ans += node.val</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>135. Candy (Hard)</title>
    <url>/post/leetcode/135-Candy-Hard/</url>
    <content><![CDATA[<p>分糖果 🍬 问题。有 <code>n</code> 个小朋友站成一排，每个人被分配一个分值，现在你要给他们分糖果，有两个要求。</p>
<ol>
<li>每个小朋友至少要有一个糖果 🍬；</li>
<li>分数高的小朋友要比两边分数低的小朋友糖果 🍬 多。</li>
</ol>
<p>你需要找到一个分配方案需要最少的糖果 🍬 数量。</p>
<span id="more"></span>

<blockquote>
<p>做完后才意识到是一道 hard 难度的题。</p>
</blockquote>
<h2 id="思路-1，野路子-提取依赖。"><a href="#思路-1，野路子-提取依赖。" class="headerlink" title="思路 1，野路子 提取依赖。"></a>思路 1，<del>野路子</del> 提取依赖。</h2><p>最初的想法是根据左右位置的 <code>rating</code> 值决定当前位置的糖果数量，但是仅仅如此的话会由于无法预知后面的值是否被改变，从而造成漏算；要解决漏算，可以根据 <code>rating</code> 值计算出当前位置的糖果数量是否依赖左右的值，这样遍历一次列表之后我们就获得了所有位置的依赖。</p>
<p>接着我们准备一个递归函数来根据这些依赖，最终去计算糖果数量。</p>
<p>数据结构上，对于无依赖项，我们直接储存字面量（int），如果存在依赖则存入 list。</p>
<p>递归时，如果目标是字面量则直接返回，如果存在进一步的依赖则调用递归进一步计算。这样可以在 O(n) 时间内完成递归。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span>(<span class="params">self, ratings: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(ratings)</span><br><span class="line">        c = [-<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> ratings[i - <span class="number">1</span>] &lt; ratings[i]:</span><br><span class="line">                res.append(i - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> i &lt; n - <span class="number">1</span> <span class="keyword">and</span> ratings[i + <span class="number">1</span>] &lt; ratings[i]:</span><br><span class="line">                res.append(i + <span class="number">1</span>)</span><br><span class="line">            c[i] = <span class="number">1</span> <span class="keyword">if</span> <span class="built_in">len</span>(res) == <span class="number">0</span> <span class="keyword">else</span> res</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">idx</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">type</span>(c[idx]) == <span class="built_in">int</span>:</span><br><span class="line">                <span class="keyword">return</span> c[idx]</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> c[idx]:</span><br><span class="line">                res.append(cal(x) + <span class="number">1</span>)</span><br><span class="line">            c[idx] = <span class="built_in">max</span>(res)</span><br><span class="line">            <span class="keyword">return</span> c[idx]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cal(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(c)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，双列表。"><a href="#思路-2，双列表。" class="headerlink" title="思路 2，双列表。"></a>思路 2，双列表。</h2><p>换一个角度看下思路一，我们能发现从左到右遍历列表时，我们无法预知右边的值是否会变动，但是我们知道左边的值都是看过的，不会发生变动。于是，我们可以准备另一个列表从右到左的遍历一次列表，这样我们就获得了一个能确保右边值都考虑到了的数据。</p>
<p>要保证每个位置的糖果都符合题目要求，我们需要对两个列表相同位置的糖果取最大值，结果将是我们的答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span>(<span class="params">self, ratings: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(ratings)</span><br><span class="line">        left, right = [<span class="number">1</span>] * n, [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> ratings[i - <span class="number">1</span>] &lt; ratings[i]:</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; n - <span class="number">1</span> <span class="keyword">and</span> ratings[i + <span class="number">1</span>] &lt; ratings[i]:</span><br><span class="line">                right[i] = right[i + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            ans += <span class="built_in">max</span>(left[i], right[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，单列表。"><a href="#思路-3，单列表。" class="headerlink" title="思路 3，单列表。"></a>思路 3，单列表。</h2><p>思路 2 的优化版本，使用双列表时，实际上我们没有同时使用到它们，所以优化的思路就是在第二次遍历时对列表进行更新，而不是重新准备一个列表。</p>
<p>这样完成第二次遍历之后，列表的和就是答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span>(<span class="params">self, ratings: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(ratings)</span><br><span class="line">        c = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> ratings[i - <span class="number">1</span>] &lt; ratings[i]:</span><br><span class="line">                c[i] = c[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; n - <span class="number">1</span> <span class="keyword">and</span> ratings[i + <span class="number">1</span>] &lt; ratings[i]:</span><br><span class="line">                c[i] = <span class="built_in">max</span>(c[i], c[i + <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(c)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>1354. Construct Target Array With Multiple Sums (Hard)</title>
    <url>/post/leetcode/1354-Construct-Target-Array-With-Multiple-Sums-Hard/</url>
    <content><![CDATA[<p>构建目标数组问题。给你一个长度为 <code>n</code> 的目标数组 <code>target</code>，你需要从一个包含 <code>n</code> 个 <code>1</code> 的数组 <code>arr</code> 开始执行下面的过程：</p>
<ul>
<li>设当前的 <code>arr</code> 数组的和为 <code>x</code>；</li>
<li>选择 <code>0</code> 到 <code>n</code> 之间的一个下标 <code>i</code>，让 <code>arr[i]</code> 等于 <code>x</code>；</li>
<li>重复这个过程。</li>
</ul>
<p>判断最终能否构建出目标数组。</p>
<span id="more"></span>

<h2 id="Highlight"><a href="#Highlight" class="headerlink" title="Highlight:"></a>Highlight:</h2><ul>
<li>Backward from the max value</li>
<li>Mod operation on max value with rest sum to get replacement value</li>
<li>Push replacement value back to heap</li>
<li>Repeat the procedure until the max value becomes to 1, which means succeed</li>
<li>Or until the exception occurs and return <code>False</code><ul>
<li>when the rest sum is greater than the max value</li>
<li>when the rest sum less than 1</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPossible</span>(<span class="params">self, target: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">        total = <span class="built_in">sum</span>(target)</span><br><span class="line">        <span class="comment"># Transform min heap to max heap.</span></span><br><span class="line">        heap = [-x <span class="keyword">for</span> x <span class="keyword">in</span> target]</span><br><span class="line">        heapify(heap)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If the max value of heap is 1</span></span><br><span class="line">        <span class="keyword">while</span> -heap[<span class="number">0</span>] != <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># Get max value of current heap.</span></span><br><span class="line">            num = -heap[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># Get the rest sum except the max value.</span></span><br><span class="line">            total += heappop(heap)</span><br><span class="line">            <span class="comment"># print(num, total, heap)</span></span><br><span class="line">            <span class="keyword">if</span> total &gt;= num <span class="keyword">or</span> total == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># Get last replacement value.</span></span><br><span class="line">            <span class="comment"># It&#x27;s the point to reduce time complicity.</span></span><br><span class="line">            <span class="comment"># With using the mod operator, we avoid to iterate through every step.</span></span><br><span class="line">            num %= total</span><br><span class="line">            <span class="comment"># Add up the replacement and add to heap.</span></span><br><span class="line">            total += num</span><br><span class="line">            heappush(heap, -num <span class="keyword">or</span> -total)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Heap (Priority Queue)</tag>
      </tags>
  </entry>
  <entry>
    <title>1383. Maximum Performance of a Team (Hard)</title>
    <url>/post/leetcode/1383-Maximum-Performance-of-a-Team-Hard/</url>
    <content><![CDATA[<p>你需要从 <code>n</code> 个工程师中选择最多 <code>k</code> 位构成一个小组，并保证获得最好的绩效表现。</p>
<p>你有两个数组 <code>speed</code> 和 <code>efficiency</code> 分别表示每个工程师的速度和效率。</p>
<p>小组的绩效表现计算方法：小组所有成员的速度之和乘以小组成员效率的最小值。由于结果数组可能会非常大，将结果和 <code>10^9 + 7</code> 取模作为答案返回。</p>
<p>工程师的速度和效率是捆绑的，所以要知道答案，我们只能尝试将每一位工程师编入小组，可以使用贪心算法解决问题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>解题思路是先计算局部最优解，再计算全局的最优解，是典型的贪心算法的应用场景。但这道题困难之处在于需要保持两个排序，而意识到这个解决方案需要一定的直觉。</p>
<p>读完题我们可以了解到团队的表现计算公式为：<code>sum(speeds) * min(efficiencies)</code>，这里的细节是选择的团队成员最多可以达到<code>k</code>位，意味着当团队人数少于<code>k</code>能取得更好的表现时的结果可以作为局部最优解。</p>
<p>据此我们开始思考，暴力解法最大的问题在于做了很多没有意义的运算，如果能找到一个方法对暴力算法进行剪枝，我们就能更快的得到答案。这道题的瓶颈在于 <code>efficiency</code> 取其最小值，而换句话来说，如果我们指定了一个队员的 <code>efficiency</code> 为最小值，那么此时的局部最优解将会是所有效率高于这个队员的人之中速度最快的前 <code>k-1</code> 个人加上这个队员的速度（我们一共选了 <code>k</code> 个人），将结果乘以这个队员的效率（因为这个队员是最小值）。</p>
<p>要实现这个思路需要保持 2 个排序：</p>
<ul>
<li><code>efficiency</code> 降序：将队员按照效率以降序排序，这样遍历的时候当前的队员永远是效率低于前面队员的；</li>
<li><code>speed</code> 动态排序：按照效率遍历，每次挑选一个队员，动态计算出速度的排序，还需要关注几个细节：<ul>
<li><code>speed</code> 排序元素的长度达到 <code>k</code> 时意味着接下来如果我们加了一个队员，就一定要放走一个已有的队员，我们放走速度最慢的队员；</li>
<li>堆的数据结构非常适合 <code>speed</code> 排序，我们可以将新的值丢入堆中，每次从堆顶移出一个最小值。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPerformance</span>(<span class="params">self, n: <span class="built_in">int</span>, speed: <span class="type">List</span>[<span class="built_in">int</span>], efficiency: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        es = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(efficiency, speed), key=<span class="keyword">lambda</span> x: -x[<span class="number">0</span>])</span><br><span class="line">        ans, total, q = <span class="number">0</span>, <span class="number">0</span>, []</span><br><span class="line">        <span class="keyword">for</span> e, s <span class="keyword">in</span> es:</span><br><span class="line">            total, ans = total + s, <span class="built_in">max</span>(ans, (total + s) * e)</span><br><span class="line">            heapq.heappush(q, s)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(q) == k:</span><br><span class="line">                total -= heapq.heappop(q)</span><br><span class="line">        <span class="keyword">return</span> ans % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
        <tag>Heap (Priority Queue)</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>1423. Maximum Points You Can Obtain from Cards (Medium)</title>
    <url>/post/leetcode/1423-Maximum-Points-You-Can-Obtain-from-Cards-Medium/</url>
    <content><![CDATA[<p>抽卡求最大得分问题。有一堆卡排成一行，每张卡的卡面有其对应的分值，你有 <code>k</code> 次机会抽取卡片，每次机会中你可以选择抽取最左边的一张卡，或者抽取最右边的一张卡。你所抽取的所有卡片的分值之和是你的得分。求你能获得的最大分数。</p>
<span id="more"></span>

<h2 id="思路-1，滑动窗口"><a href="#思路-1，滑动窗口" class="headerlink" title="思路 1，滑动窗口"></a>思路 1，滑动窗口</h2><p>用滑动窗口检查 k 以外的连续元素的最小值，然后用数组和减去这个最小值。计算过程用 DP 简化，仅需计算数组前缀和。优势是思路简单，前缀和使用 in-place 不会占用额外空间。虽然思路简单，但是代码不算简洁。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScore</span>(<span class="params">self, cp: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(cp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Calculate prefix sum.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            cp[i] += cp[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == k:</span><br><span class="line">            <span class="keyword">return</span> cp[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        sz = n - k</span><br><span class="line">        m = cp[sz - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sz, n):</span><br><span class="line">            m = <span class="built_in">min</span>(m, cp[i] - cp[i - sz])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cp[-<span class="number">1</span>] - m</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，滑动窗口-V2"><a href="#思路-2，滑动窗口-V2" class="headerlink" title="思路 2，滑动窗口 V2"></a>思路 2，滑动窗口 V2</h2><p>就是直接按照提问的思路，计算所有组合并且求最大值，逻辑捋清楚之后也比较简单，这里只需要滑动窗口，每次减去离开窗口的值、加上进入窗口的值，然后取最大值。思路捋清楚后代码比较简洁.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScore</span>(<span class="params">self, cp: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = curr = <span class="built_in">sum</span>(cp[:k])</span><br><span class="line">        <span class="comment"># From k - 1 to 0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            curr += cp[i - k] - cp[i]</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, curr)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Sliding Window</tag>
        <tag>Prefix Sum</tag>
      </tags>
  </entry>
  <entry>
    <title>144. Binary Tree Preorder Traversal (Easy)</title>
    <url>/post/leetcode/144-Binary-Tree-Preorder-Traversal-Easy/</url>
    <content><![CDATA[<p>遍历树有三种方法，分别是前序 pre-order、中序 in-order 和后序 post-order 遍历。这道题是前序遍历。</p>
<p>前序遍历的递归写法没有难度。</p>
<span id="more"></span>

<h2 id="思路-1，递归"><a href="#思路-1，递归" class="headerlink" title="思路 1，递归"></a>思路 1，递归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            traverse(node.left)</span><br><span class="line">            traverse(node.right)</span><br><span class="line"></span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，遍历"><a href="#思路-2，遍历" class="headerlink" title="思路 2，遍历"></a>思路 2，遍历</h2><p>使用 stack 或队列按顺序记录需要检查的节点，需要关注的是：</p>
<ul>
<li>stack 是先进后出，要保证先左后右的顺序，需要先放入右 child，再放入左 child；</li>
<li>队列是先进先出，按正常顺序放入左右 child 即可。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans, stack = [], [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>145. Binary Tree Postorder Traversal (Easy)</title>
    <url>/post/leetcode/145-Binary-Tree-Postorder-Traversal-Easy/</url>
    <content><![CDATA[<p>遍历树通常有三种方法，分别是前序遍历（pre-order traversal）、中序遍历（in-order traversal）和后序遍历（post-order traversal）。这道题是后序遍历。</p>
<span id="more"></span>

<h2 id="思路-1，递归"><a href="#思路-1，递归" class="headerlink" title="思路 1，递归"></a>思路 1，递归</h2><p>三种递归遍历方式的区别仅在于处理的顺序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            traverse(node.left)</span><br><span class="line">            traverse(node.right)</span><br><span class="line">            ans.append(node.val)</span><br><span class="line"></span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，迭代遍历"><a href="#思路-2，迭代遍历" class="headerlink" title="思路 2，迭代遍历"></a>思路 2，迭代遍历</h2><p>后序遍历按照 left -&gt; right -&gt; root 的顺序遍历树，你会发现这和前序遍历相似，我们只需要将前序遍历方法中左右子节点的遍历顺序对调，并将其结果颠倒一下顺序，即可得到后序遍历的结果。</p>
<p>但是这样不够优雅。</p>
<p>我们延续 stack 的思路，通过观察我们知道要完成后序遍历，每次迭代过程中我们可以把当前节点、右节点、左节点按顺序放入 stack 中，针对当前节点，需要将其左右子节点置空表示已经遍历过。</p>
<p>我们的 Base Case 的条件是当前节点没有左右子节点，这表示该节点是叶子节点，或是已经遍历过的节点，针对这两种情况我们直接记录它的值。</p>
<p>重复这个过程，直到完成遍历。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans, stack = [], [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> curr:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left, right = curr.left, curr.right</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                ans.append(curr.val)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            curr.left, curr.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">            stack.append(curr)</span><br><span class="line">            stack.append(right)</span><br><span class="line">            stack.append(left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，迭代遍历，基于中序迭代遍历优化"><a href="#思路-3，迭代遍历，基于中序迭代遍历优化" class="headerlink" title="思路 3，迭代遍历，基于中序迭代遍历优化"></a>思路 3，迭代遍历，基于中序迭代遍历优化</h2><p>由于 root 的值是最后记录的，在当前节点存在右节点的情况，还需要将当前节点的右节点置空，重新存入 stack。在空间复杂度上比思路 2 而言没有太大优化。</p>
<p>这个思路下，我们先到达左节点的最下层左节点（即最后一个左节点，该节点的左节点为空），然后根据右节点发生下面分支：</p>
<ul>
<li>右节点不存在：The Base Case，这个节点是叶子节点或访问过的节点，记录它的值；</li>
<li>右节点存在：置空当前节点的右节点并存入 stack，将右节点标记为当前节点进入下一个迭代过程。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans, stack, curr = [], [], root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">or</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> curr:</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr = curr.left</span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> curr.right:</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                <span class="comment"># 置空当前节点的右节点，标记右节点为当前节点</span></span><br><span class="line">                curr.right, curr = <span class="literal">None</span>, curr.right</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            ans.append(curr.val)</span><br><span class="line">            <span class="comment"># 节点已经遍历完成，注意需要清空指针</span></span><br><span class="line">            curr = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts (Medium)</title>
    <url>/post/leetcode/1465-Maximum-Area-of-a-Piece-of-Cake-After-Horizontal-and-Vertical-Cuts-Medium/</url>
    <content><![CDATA[<p>切蛋糕问题。给你一个尺寸为 <code>h</code> x <code>w</code> 的矩形蛋糕，还有两个数组 <code>horizontalCuts</code> 和 <code>verticalCuts</code> 分别表示水平方式切的位置和垂直方向切的位置。</p>
<ul>
<li>水平切面的值从蛋糕的最上边开始计算；</li>
<li>相同的，垂直切面的值从蛋糕的最左边开始计算。</li>
</ul>
<p>求蛋糕切分之后的单块蛋糕的最大面积。因为结果可能是一个很大的数字，将其和 <code>109 + 7</code> 取模之和作为答案返回。</p>
<p>实际上是求两个数组的最大差之积，需要考虑的细节是四条边的值不在数组中，如果漏掉它们将不能得到正确答案。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将横切和竖切排序，不要忘记加上最大的长宽 <code>h</code> 和 <code>w</code>，对每条切线求出实际长度（当前长度减去前一条线的长度），保留最大值。对取得的最大长宽求面积，结果用 1e9 + 7 取模。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, h: <span class="built_in">int</span>, w: <span class="built_in">int</span>, horizontalCuts: <span class="type">List</span>[<span class="built_in">int</span>], verticalCuts: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        horizontalCuts.sort()</span><br><span class="line">        horizontalCuts.append(h)</span><br><span class="line">        verticalCuts.sort()</span><br><span class="line">        verticalCuts.append(w)</span><br><span class="line">        mh, mv = horizontalCuts[<span class="number">0</span>], verticalCuts[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(horizontalCuts) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            mh = <span class="built_in">max</span>(mh, horizontalCuts[i] - horizontalCuts[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(verticalCuts) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            mv = <span class="built_in">max</span>(mv, verticalCuts[i] - verticalCuts[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> (mh * mv) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>1480. Running Sum of 1d Array (Easy)</title>
    <url>/post/leetcode/1480-Running-Sum-of-1d-Array-Easy/</url>
    <content><![CDATA[<p>求动态和，也就是前缀和。让你熟悉一下什么是前缀和。</p>
<p>给定一个数组，根据下标遍历，将每个位置 <code>n</code> 的值更新为原数组位置 <code>0</code> 到 <code>n</code> 的和。</p>
<p>连续几天 Hard 题目突然蹦出来一道 Easy 还有点不适应，提交之前都在想肯定没这么简单，有那里没考虑到，结果就 Accepted 了。</p>
<span id="more"></span>

<h2 id="简直-leetcode-pstd。"><a href="#简直-leetcode-pstd。" class="headerlink" title="简直 leetcode pstd。"></a>简直 leetcode pstd。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runningSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Prefix Sum</tag>
      </tags>
  </entry>
  <entry>
    <title>150. Evaluate Reverse Polish Notation (Medium)</title>
    <url>/post/leetcode/150-Evaluate-Reverse-Polish-Notation-Medium/</url>
    <content><![CDATA[<p>演算反向波兰表示法。反向波兰表示法是一种为减少内存访问的使用 Stack 的演算表达法，这种方法按照先操作对象后操作符的方式表达算术运算。</p>
<p>所以我们讨论如何使用 Stack 解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>反向波兰表示法是一种使用 Stack 达到方便计算目的的一种数学方法。</p>
<p>使用递归或 Stack 都能简单的完成计算。使用 Stack 为例，算法过程如下：</p>
<ul>
<li>遍历 tokens<ul>
<li>遇到数字则加到栈顶</li>
<li>遇到操作符和取出栈顶的 2 个数字做运算，运算结果放回栈顶</li>
</ul>
</li>
<li>最终栈中存在的元素就是答案</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>&#125;:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(t))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right, left = stack.pop(), stack.pop()</span><br><span class="line">                <span class="comment"># print(left, t, right)</span></span><br><span class="line">                <span class="keyword">if</span> t == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.append(left + right)</span><br><span class="line">                <span class="keyword">elif</span> t == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.append(left - right)</span><br><span class="line">                <span class="keyword">elif</span> t == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stack.append(left * right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(trunc(left / right))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Stack</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>164. Maximum Gap (Hard)</title>
    <url>/post/leetcode/164-Maximum-Gap-Hard/</url>
    <content><![CDATA[<p>给定一个整数数组 <code>nums</code>，你需要将其排序后，找到相邻两个数之间的最大间隙（差）。如果不足两个元素则返回 0。</p>
<p>你必须在线性时间内，仅使用线性额外空间完成计算。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>桶排序实现常数 n 的 O(n)复杂度。</p>
<p>桶排序是指将数据划分为诺干子数组，称之为桶，在桶内使用一般排序算法（比如 O(n^2)的插入排序等）排序，等到每一个桶就完成各自的排序之后，将所有桶按照顺序组合起来，获得最终排序完成的数组。</p>
<p>这样做的优势，通过一个例子可以清晰的明白：我们有一个长度为 10 的数组需要排序；</p>
<ul>
<li>使用插入排序，O(n^2)的情况下最差的情况将进行 10*10=100 次操作；</li>
<li>使用桶排序，选择最大的桶将数组分为两个长度为 5 的子数组，分别应用排序，最差情况将进行 10（分桶）+5*5（插入排序）*2（2 个桶） =60 次操作。</li>
</ul>
<p>但是桶的尺寸为 2 对于这个场景并不是最优的选择，这个例子解释了就算用极限分桶，也比单独使用插入排序高效。</p>
<p>桶排序的重点在于决定桶的尺寸，这直接影响到排序效率，对于这道题来说，通过数学归纳可以得知，最大间距的最小可能应该是间距的平均值，而当所有数的间隔都是平均分布的时候才会遇到这个场景，比如 <code>[0, 5, 10, 15]</code>，其中总间距为最大值减去最小值，即 <code>15-0=15</code>，通过观察得知间距的数量为数组长度减去 <code>1</code>，即 <code>4-1=3</code>，那么平均间距为 <code>15/3=5</code>，对于这个数组来说，平均间距就是最大间距，但是一旦其中任何一个值变大或变小任意长度，比如 <code>[0, 4, 10, 15]</code>，第一个间距从 <code>5</code> 变为 <code>4</code>，就必定意味着第二个间距从 <code>5</code> 变为 <code>6</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, n, hi, lo = <span class="number">0</span>, <span class="built_in">len</span>(nums), <span class="built_in">max</span>(nums), <span class="built_in">min</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># Set 1 for case that max gap less than its length.</span></span><br><span class="line">        bsize = (hi - lo) // (n - <span class="number">1</span>) <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">        buckets = [[-<span class="number">1</span>, -<span class="number">1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>((hi - lo) // bsize + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            b = (x - lo) // bsize</span><br><span class="line">            buckets[b][<span class="number">0</span>] = <span class="built_in">min</span>(buckets[b][<span class="number">0</span>], x) <span class="keyword">if</span> buckets[b][<span class="number">0</span>] != -<span class="number">1</span> <span class="keyword">else</span> x</span><br><span class="line">            buckets[b][<span class="number">1</span>] = <span class="built_in">max</span>(buckets[b][<span class="number">1</span>], x)</span><br><span class="line">        prev = buckets[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(buckets)):</span><br><span class="line">            <span class="keyword">if</span> buckets[i][<span class="number">0</span>] == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, buckets[i][<span class="number">0</span>] - prev)</span><br><span class="line">            prev = buckets[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Sorting</tag>
        <tag>Bucket Sort</tag>
        <tag>Radix Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>1642. Furthest Building You Can Reach (Medium)</title>
    <url>/post/leetcode/1642-Furthest-Building-You-Can-Reach-Medium/</url>
    <content><![CDATA[<p>爬楼游戏。给你一个数组 <code>heights</code> 表示你面前的大楼的高度，你从 <code>0</code> 出发，你有一些砖块的梯子。当你从当前位置爬到下一个位置时需要满足下面的条件。</p>
<ul>
<li>如果当前楼层高度<strong>大于或等于</strong>下一个大楼的高度，你可以直接过去，不需要使用砖块或梯子；</li>
<li>如果当前楼岑高度<strong>小于</strong>下一个大楼的高度，你可以选择使用 1 个梯子，或者两栋楼高度差数量的砖块过去。</li>
</ul>
<p>重点在于梯子可以爬任意高度，砖块则需要消耗高度差的数量。求你可以到达的最远距离。贪心算法和优先队列可以解决这个问题。</p>
<span id="more"></span>

<h2 id="思路…算了直接-Solution"><a href="#思路…算了直接-Solution" class="headerlink" title="思路…算了直接 Solution"></a>思路…算了直接 Solution</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">furthestBuilding</span>(<span class="params">self, h: <span class="type">List</span>[<span class="built_in">int</span>], bricks: <span class="built_in">int</span>, ladders: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        lv = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(h)):</span><br><span class="line">            gap = h[x] - h[x-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> gap &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            lv.append(gap)</span><br><span class="line">            <span class="keyword">if</span> gap &lt;= bricks:</span><br><span class="line">                bricks -= gap</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> ladders != <span class="number">0</span>:</span><br><span class="line">                lv.sort()</span><br><span class="line">                ladders -= <span class="number">1</span></span><br><span class="line">                bricks += lv.pop() - gap</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> x - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(h) - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Ver 2.0 using max heap.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">furthestBuilding</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>], bricks: <span class="built_in">int</span>, ladders: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        heap = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(heights)):</span><br><span class="line">            <span class="keyword">if</span> heights[i] &gt; heights[i - <span class="number">1</span>]:</span><br><span class="line">                h = heights[i] - heights[i - <span class="number">1</span>]</span><br><span class="line">                heappush(heap, -h)</span><br><span class="line">                bricks -= h</span><br><span class="line">                <span class="keyword">if</span> bricks &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> ladders != <span class="number">0</span>:</span><br><span class="line">                    bricks -= heappop(heap)</span><br><span class="line">                    ladders -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(heights) - <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
        <tag>Heap (Priority Queue)</tag>
      </tags>
  </entry>
  <entry>
    <title>1689. Partitioning Into Minimum Number Of Deci-Binary Numbers (Medium)</title>
    <url>/post/leetcode/1689-Partitioning-Into-Minimum-Number-Of-Deci-Binary-Numbers-Medium/</url>
    <content><![CDATA[<p>给定一个字符串格式的十进制整数 <code>n</code>，要求你分析最少需要多少个“二进制式十进制数”（Deci-Binary）求和可以得到这个给定的数 <code>n</code>。</p>
<p>“二进制式十进制数”的定义：一个十进制的整数，并且每一位数都只能是 <code>0</code> 或 <code>1</code>，不能有前置 <code>0</code>。比如 <code>101</code> 和 <code>1100</code> 符合要求，但是 <code>112</code> 和 <code>3001</code> 不符合要求。</p>
<blockquote>
<p>这道题确定不是脑筋急转弯吗？！</p>
</blockquote>
<span id="more"></span>

<h2 id="Medium-Seriously"><a href="#Medium-Seriously" class="headerlink" title="???Medium??? Seriously?!"></a>???Medium??? Seriously?!</h2><p>解释一句，仔细观察你会发现，由于二进制式十进制数每一位最大值是 <code>1</code>，想要从 <code>0</code> 开始用最少数量的二进制式十进制数来求和得到 <code>n</code>，你只需要知道 <code>n</code> 每一位数字的最大值即可，所以答案会在 <code>1-9</code> 之间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPartitions</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : n.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c - <span class="string">&#x27;0&#x27;</span> &gt; ans) ans = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">9</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPartitions</span>(<span class="params">self, n: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> n)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>1695. Maximum Erasure Value (Medium)</title>
    <url>/post/leetcode/1695-Maximum-Erasure-Value-Medium/</url>
    <content><![CDATA[<p>有一个正整数数组 <code>nums</code>，你需要找到一个不存在重复元素的子数组，子数组的值之和是你获得的分数。求你可以获得的最大分数。这道题可以运用滑动窗口来解决。</p>
<span id="more"></span>

<h2 id="思路-1，双指针-Sliding-Window-nmap"><a href="#思路-1，双指针-Sliding-Window-nmap" class="headerlink" title="思路 1，双指针 Sliding Window + nmap"></a>思路 1，双指针 Sliding Window + nmap</h2><p>入参数值上限 10^4，所以我们可以准备一个能容纳最大数字的数组来储存每个数字出现的次数。</p>
<p>双指针方法，准备 <code>left</code>、<code>right</code> 两个指针，<code>right</code> 指针遍历整个数组，每次迭代计算合计值和最大值，当数字出现次数超过 1 时，迭代 <code>left</code> 指针直到数字出现次数回到 1，迭代过程中将移出窗口的数字从合计值中减去。重复这个过程直到 <code>right</code> 到达终点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumUniqueSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        score, left, total, mask = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, [<span class="number">0</span>] * <span class="number">10001</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> nums:</span><br><span class="line">            mask[right] += <span class="number">1</span></span><br><span class="line">            total += right</span><br><span class="line">            <span class="keyword">while</span> mask[right] &gt; <span class="number">1</span>:</span><br><span class="line">                mask[nums[left]] -= <span class="number">1</span></span><br><span class="line">                total -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            score = <span class="built_in">max</span>(score, total)</span><br><span class="line">        <span class="keyword">return</span> score</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumUniqueSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line">        <span class="keyword">int</span> score = <span class="number">0</span>, left = <span class="number">0</span>, total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right : nums) &#123;</span><br><span class="line">            total += right;</span><br><span class="line">            map[right]++;</span><br><span class="line">            <span class="keyword">while</span> (map[right] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                total -= nums[left];</span><br><span class="line">                map[nums[left++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            score = Math.max(score, total);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Sliding Window</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>1696. Jump Game VI (Medium)</title>
    <url>/post/leetcode/1696-Jump-Game-VI-Medium/</url>
    <content><![CDATA[<p>跳跃游戏问题。你有一个数组 <code>nums</code> 和一个步数 <code>k</code>，最初你站在 0 的位置。游戏每一回合你可以向前跳最多 <code>k</code> 步，你的得分就是向前跳的步数对于 <code>nums</code> 中的值。求你可以获得的最大得分。</p>
<span id="more"></span>

<h2 id="思路-1，DP-Heap"><a href="#思路-1，DP-Heap" class="headerlink" title="思路 1，DP + Heap"></a>思路 1，DP + Heap</h2><p>这道题很容易想到用 DP 来解决，我们记录 k 步以内的值，每一次用最大值来计算下一个值，可以用 O(n*k) 的复杂度完成计算，但是可惜 k 的最大值能到 10^5，O(n*k) 无法通过测试 case。</p>
<p>我们需要减少计算最大值的次数，可以考虑用大根堆数据结构来处理最大值的计算，但是这道题的复杂度在于我我们需要根据下标来判断这个值能不能选用，毕竟如果下标不在跳跃的范围内，这个最大值对我们来说就失效了。</p>
<p>为了处理这个问题，我们在创建大根堆的时候以 <code>(value, index)</code> 形式将值和下标建立联系。在每次迭代过程中，我们将失效的最大值从堆中移出掉，再去计算当前应该放入堆中的值。</p>
<p>使用 Python 时需要注意 heapq 没有原生提供大根堆的支持，我们可以在存值的使用使用负号颠倒一下值的大小，达到大根堆的效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxResult</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, q = nums[<span class="number">0</span>], [(-nums[<span class="number">0</span>], <span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">while</span> i - q[<span class="number">0</span>][<span class="number">1</span>] &gt; k:</span><br><span class="line">                heappop(q)</span><br><span class="line">            ans = nums[i] - q[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            heappush(q, (-ans, i))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Sliding Window</tag>
        <tag>DP</tag>
        <tag>Heap (Priority Queue)</tag>
        <tag>Queue</tag>
        <tag>Monotonic Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>1710. Maximum Units on a Truck (Easy)</title>
    <url>/post/leetcode/1710-Maximum-Units-on-a-Truck-Easy/</url>
    <content><![CDATA[<p>卡车装箱问题。你有一辆卡车和一个货物清单（2D 数组），货物清单每个项目列出了这种货物的数量和每个货物所占的容量。</p>
<p>你需要求出给定尺寸的卡车最多能装下多少个货物。这道题运用贪心算法。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将 <code>boxTypes</code> 按照 <code>units</code> 排序，从最大的 <code>units</code> 开始装入卡车，直到装满 <code>truckSize</code> 的数量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumUnits</span>(<span class="params">self, boxTypes: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], truckSize: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        boxTypes.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> nums, units <span class="keyword">in</span> boxTypes:</span><br><span class="line">            <span class="keyword">if</span> truckSize &lt;= nums:</span><br><span class="line">                <span class="keyword">return</span> ans + truckSize * units</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += nums * units</span><br><span class="line">                truckSize -= nums</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>19. Remove Nth Node From End of List (Medium)</title>
    <url>/post/leetcode/19-Remove-Nth-Node-From-End-of-List-Medium/</url>
    <content><![CDATA[<p>删除链表的指定节点，返回修改后的链表 <code>head</code>。</p>
<blockquote>
<p>Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the <strong>end of the list</strong> and return its <code>head</code>.</p>
<p><strong>Follow up</strong>: Could you do this in one pass?</p>
</blockquote>
<span id="more"></span>

<p>With solutions both in Java and Python.</p>
<p>移除一个 linked list 末尾第 n 个节点，返回这个 linked list 的 head。最好是 One-pass 算法， 即一个流程里面获得想要的结果。</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5], n = 2</span><br><span class="line">Output: [1,2,3,5]</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1], n = 1</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p>Example 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2], n = 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p>Constraints:</p>
<ul>
<li>The number of nodes in the list is <code>sz</code>.</li>
<li>1 &lt;= <code>sz</code> &lt;= 30</li>
<li>0 &lt;= <code>Node.val</code> &lt;= 100</li>
<li>1 &lt;= <code>n</code> &lt;= <code>sz</code></li>
</ul>
<h2 id="思路-amp-Solutions"><a href="#思路-amp-Solutions" class="headerlink" title="思路 &amp; Solutions"></a>思路 &amp; Solutions</h2><p>最简单的方法是先遍历一遍 Linked list 获得列表长度，然后重新遍历一次，在 <code>L - n - 1</code> 处停下，删掉下一个节点。</p>
<p>但是这样就不算 One-pass 算法了。</p>
<p>为了达成 One-pass 算法，我们可以维护 2 个指针。</p>
<ul>
<li>用 2 个指针，first 指向底部，一直遍历到最后；</li>
<li>second 指向需要删除的节点的上一个节点，与 first 维持 <code>n + 1</code> 的距离。</li>
</ul>
<p>为了避免处理例子 2 中的那种删除唯一节点的情况，我们初始化一个 dummy 节点，从这里开始遍历。</p>
<p>下面是 Python 代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = first = second = ListNode()</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        dis = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> first.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            first = first.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 注意由于second指向需要删除的节点的上一个节点，所以需要与first保持n+1的距离</span></span><br><span class="line">            <span class="keyword">if</span> dis != n + <span class="number">1</span>:</span><br><span class="line">                dis += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                second = second.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        second.<span class="built_in">next</span> = second.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>下面是相同逻辑的 Java 代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode first = dummy;</span><br><span class="line">        ListNode second = dummy;</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dis = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (first.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            <span class="comment">// 注意由于second指向需要删除的节点的上一个节点，所以需要与first保持n+1的距离</span></span><br><span class="line">            <span class="keyword">if</span> (dis != n + <span class="number">1</span>) &#123;</span><br><span class="line">                dis++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                second = second.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Two Pointers</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>204. Count Primes (Easy)</title>
    <url>/post/leetcode/204-Count-Primes-Easy/</url>
    <content><![CDATA[<p>计算所有小于非负整数 <code>n</code> 的质数的数量。</p>
<blockquote>
<p>质数（Prime）： 只能被 1 和其本身整除的数。</p>
</blockquote>
<p>可以暴力、枚举解题，也可以找到一定规律优化一下暴力算法。</p>
<span id="more"></span>

<h2 id="思路-Sieve-of-Eratosthenes"><a href="#思路-Sieve-of-Eratosthenes" class="headerlink" title="思路 Sieve of Eratosthenes"></a>思路 Sieve of Eratosthenes</h2><p>埃拉托色尼筛法。</p>
<p>准备一个长度为 <code>n</code> 的数组并且用 1 填充。</p>
<p>思路在于从 2 开始到 <code>n</code> 的平方根为止，将每个值到 <code>n</code> 为止的倍数作为下标，将数组中的值标记为 0，即非质数。</p>
<p>最终将数组求和，剩下的 1 都是质数。注意 0 和 1 不是质数，需要将其从结果中排除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">        isprime = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(math.sqrt(n)) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> isprime[i] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i ** <span class="number">2</span>, n, i):</span><br><span class="line">                    isprime[j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 0 and 1 are not prime.</span></span><br><span class="line">        ans = <span class="built_in">sum</span>(isprime) - <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
        <tag>Enumeration</tag>
        <tag>Number Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>22. Generate Parentheses (Medium)</title>
    <url>/post/leetcode/22-Generate-Parentheses-Medium/</url>
    <content><![CDATA[<p>给你一个数字 <code>n</code>，你需要用 <code>n</code> 对括号进行组合，找到所有可能的组合。</p>
<p>没对括号需要正常关闭才算一个有效的组合。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把括号转换成数字，我们可以观察到其中的规律。转数字的方法在于对括号嵌套的层级进行计数，比如 <code>((()))</code> 一共嵌套了 3 层，所以转化为数字为 <code>123</code>，而 <code>()(())</code> 可以转化为 <code>112</code>。</p>
<blockquote>
<p>Input: n = 3</p>
<p>Output: [“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p>
</blockquote>
<blockquote>
<p>Layout: [123, 122, 121, 112, 111]</p>
</blockquote>
<p>规律在答案中的所有组合都属于 <code>1..n</code> 到 <code>1..1</code> 的枚举。比如 <code>123, 122, 121</code> 的过程中最高位 3 被枚举到 1，而下一个数第二位 2 降为 1，第三位从第二位原本的值开始继续枚举到 1。</p>
<p>我们可以将其转化为算法，计算出所有可能的嵌套布局，然后用一个 <code>draw</code> 方法来将布局转化为实际的括号字符串。转化过程有三种模式：</p>
<ul>
<li>对排列的最后一个元素的处理：插入一对括号，然后关闭其他所有括号；</li>
<li>对当前元素 &gt;= 下一个元素的处理：插入一对括号，关闭到下一个元素为止层级的括号；</li>
<li>对当前元素 &lt; 下一个元素对处理：插入左半边括号。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">layout:[<span class="built_in">int</span>] = [<span class="number">1</span>]</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(layout) == n:</span><br><span class="line">                ans.append(draw(layout))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(layout[-<span class="number">1</span>]) + <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                generate(layout + [i])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">layout:[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">            res = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> i == n - <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># Add a left parentheses and close all others.</span></span><br><span class="line">                    res += <span class="string">&quot;(&quot;</span>  + <span class="string">&quot;)&quot;</span> * layout[i]</span><br><span class="line">                <span class="keyword">elif</span> layout[i] &gt;= layout[i + <span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># Add a left parentheses and close all others.</span></span><br><span class="line">                    res += <span class="string">&quot;(&quot;</span>  + <span class="string">&quot;)&quot;</span> * (layout[i] - layout[i + <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># Add a left parentheses only.</span></span><br><span class="line">                    res += <span class="string">&quot;(&quot;</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        generate()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>上面的思路只是找到了题目的答案，但是算不上优雅。对字符串的编辑可以在计算布局的适合完成，或者说，一旦我们知道了布局的规律，我们就可以完全没有额外操作的找到所有组合。</p>
<p>但是在编辑字符串的适合很容易陷入到对多种情况的考虑，但是只要换一个角度想想问题就可以解决：括号会出现在哪里？</p>
<p>实际上合理的括号只会出现在两个位置：当前括号的里面（嵌套变深），当前括号的右边（非嵌套）。</p>
<p>下一个问题是，哪些括号放在里面，哪些放在右边呢？答案是，从 <code>n</code> 到 <code>1</code> 遍历，当前的 <code>index</code> 在括号里面，<code>n - index</code> 在括号的右边，当然反之亦然，影响的只是答案中每个元素出现的顺序而已。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> self.generateParenthesis(i):</span><br><span class="line">                <span class="keyword">for</span> right <span class="keyword">in</span> self.generateParenthesis(n - <span class="number">1</span> - i):</span><br><span class="line">                    ans.append(<span class="string">f&quot;(<span class="subst">&#123;left&#125;</span>)<span class="subst">&#123;right&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>303. Range Sum Query - Immutable (Easy)</title>
    <url>/post/leetcode/303-Range-Sum-Query-Immutable-Easy/</url>
    <content><![CDATA[<p>你有一个整数数组 <code>nums</code>，你需要实现一个程序处理范围求和的查询</p>
<p>每次查询得到两个下标 <code>left</code> 和 <code>right</code> 作为参数，查询区间 [<code>left</code>, <code>right</code>] 的和，其中 <code>left &lt;= right</code>。</p>
<p>前缀和的教学题，我们讨论前缀和如何解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>前缀和，然后查询区间，最右减去最左，注意一个 index 的 offset。</p>
<p>查询 0 开始的范围，需要减去 -1 下标的和，这不合理，所以遇到 -1 可以选择重置为 0，但这不优雅。</p>
<p>通过向数组左端添加一个 0，可以避免处理 query 范围左端为 -1 的场景。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.q = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            self.q.append(self.q[-<span class="number">1</span>] + n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.q[right + <span class="number">1</span>] - self.q[left]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Prefix Sum</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>304. Range Sum Query 2D - Immutable (Medium)</title>
    <url>/post/leetcode/304-Range-Sum-Query-2D-Immutable-Medium/</url>
    <content><![CDATA[<p>你有一个 2D 矩阵 <code>matrix</code>，你需要实现一个程序处理多次子矩阵求和的查询。</p>
<p>每次查询你会得到 2 个坐标，分别代表子矩阵的左上坐标和右下坐标，返回这个子矩阵的和。</p>
<p>典型的前缀和问题，所以我们讨论如何应用前缀和解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>类似 1074，先求 Prefix Sum，然后计算子矩阵和。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            matrix[<span class="number">0</span>][j] += matrix[<span class="number">0</span>][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    matrix[i][j] += matrix[i][j - <span class="number">1</span>] - matrix[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                matrix[i][j] += matrix[i - <span class="number">1</span>][j]</span><br><span class="line"></span><br><span class="line">        self._m = matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = self._m[row2][col2]</span><br><span class="line">        <span class="keyword">if</span> row1 &gt; <span class="number">0</span>:</span><br><span class="line">            ans -= self._m[row1 - <span class="number">1</span>][col2]</span><br><span class="line">        <span class="keyword">if</span> col1 &gt; <span class="number">0</span>:</span><br><span class="line">            ans -= self._m[row2][col1 - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> row1 &gt; <span class="number">0</span> <span class="keyword">and</span> col1 &gt; <span class="number">0</span>:</span><br><span class="line">            ans += self._m[row1 - <span class="number">1</span>][col1 - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = NumMatrix(matrix)</span></span><br><span class="line"><span class="comment"># param_1 = obj.sumRegion(row1,col1,row2,col2)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Prefix Sum</tag>
        <tag>Matrix</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>307. Range Sum Query - Mutable (Medium)</title>
    <url>/post/leetcode/307-Range-Sum-Query-Mutable-Medium/</url>
    <content><![CDATA[<p>你有一个整数数组 <code>nums</code>，你需要实现一个程序处理下面两种类型的多次查询：</p>
<ul>
<li>更新：更新数组中某个字段的值；</li>
<li>求和：通过下标 <code>left</code> 和 <code>right</code> 查询区间 [<code>left</code>, <code>right</code>] 的和，其中 <code>left &lt;= right</code>。</li>
</ul>
<p>看到求和或许你开始思考能否用前缀和解题，但是题目要求能对原数组进行更新，显然前缀和不是最好的方案。这题可以运用线段树解决。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定数组，可以更新元素，还要快速查询范围内的和、最大最小值，这是典型的 Segment Tree （线段树）的应用场景。</p>
<p>线段树可以用数组和 TreeNode 的结构表达。这里需要构建一个和线段树，方便起见用数组来表达线段树。</p>
<h3 id="Build-Tree"><a href="#Build-Tree" class="headerlink" title="Build Tree"></a>Build Tree</h3><p>线段树是一个二叉树结构，在给定数组上构建一个线段树，最终节点数约等于原数组长度的 2 倍，所以我们准备一个原数组长度 2 倍的数组，将原数组的元素放在从 <code>n</code> 开始的后半段。</p>
<p>前半段从 <code>n - 1</code> 开始遍历到 <code>0</code>，每个位置的值等于 <code>2 * i</code> + <code>2 * i + 1</code>，即其左右节点的和。树的构建就完成了。</p>
<h3 id="Update-Values"><a href="#Update-Values" class="headerlink" title="Update Values"></a>Update Values</h3><p>更新线段树时，只需要更新从目标叶子节点开始到根节点的路径。</p>
<p>我们从叶子节点出发，用下标除以 2，更新每一个途径的节点，直到根节点，我们一共更新 log n 个元素。</p>
<h3 id="Range-Sum-Query"><a href="#Range-Sum-Query" class="headerlink" title="Range Sum Query"></a>Range Sum Query</h3><p>查询给定范围的和，分左右边界进行讨论：</p>
<p>左边界：</p>
<ul>
<li>如果左边元素属于节点的 right child，这意味着它的父节点包含一个值在查询的范围之外，所以我们仅加上左边元素的值本身，然后将边界向右移动一位；</li>
<li>如果左边元素属于节点的 left child，我们查询它的父元素即可。</li>
</ul>
<p>右边界：</p>
<ul>
<li>相反，如果右边元素属于节点的 left child，我们仅加上元素本身的值，将边界向左移动一位；</li>
<li>如果右边元素属于节点的 right child，我们查询它的父元素。</li>
</ul>
<p>我们更新左右边界，重复这个过程直到左右边界接错开（left &gt; right），这时我们得到了答案。</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        tree = [<span class="number">0</span>] * <span class="number">2</span> * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            tree[i + n] = nums[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        self.n = n</span><br><span class="line">        self.tree = tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        n, tree = self.n, self.tree</span><br><span class="line">        index += n</span><br><span class="line">        tree[index] = val</span><br><span class="line">        <span class="keyword">while</span> index != <span class="number">0</span>:</span><br><span class="line">            index //= <span class="number">2</span></span><br><span class="line">            tree[index] = tree[<span class="number">2</span> * index] + tree[<span class="number">2</span> * index + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n, tree = self.n, self.tree</span><br><span class="line">        left += n</span><br><span class="line">        right += n</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> left % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                ans += tree[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                ans += tree[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            left //= <span class="number">2</span></span><br><span class="line">            right //= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Design</tag>
        <tag>Binary Indexed Tree</tag>
        <tag>Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>318. Maximum Product of Word Lengths (Medium)</title>
    <url>/post/leetcode/318-Maximum-Product-of-Word-Lengths-Medium/</url>
    <content><![CDATA[<p>字符串问题。给定一个字符串数组，求数组中字符串 A 和字符串 B 的长度的最大乘积，其中 A 和 B 中不能有任何相同的字母存在。</p>
<p>应用位掩码解决这个问题。</p>
<span id="more"></span>

<h2 id="思路-1，暴力法"><a href="#思路-1，暴力法" class="headerlink" title="思路 1，暴力法"></a>思路 1，暴力法</h2><p>找到所有组合求最大值，用一个帮助函数 <code>pair</code> 来帮助我们判断是否需要进行相乘。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pair</span>(<span class="params">w1, w2</span>):</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> w1:</span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">in</span> w2:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        ans, n = <span class="number">0</span>, <span class="built_in">len</span>(words)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> pair(words[i], words[j]):</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">len</span>(words[i]) * <span class="built_in">len</span>(words[j]))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，位掩码"><a href="#思路-2，位掩码" class="headerlink" title="思路 2，位掩码"></a>思路 2，位掩码</h2><p>英文小写字母只有 26 位，设想我们有一个长度为 26 的二进制数字，按照顺序将每一位映射成一个字母，0 表示有这个字母，1 则表示没有，这就是位掩码。判断相同字符串经常用到位掩码操作，在计算机中位操作往往有更好的效率。要判断两个字符串是否有共同的字母，只需要将他们的位掩码进行 <code>&amp;</code> 操作，这样相同位存在 1 的情况就会让结果大于 0，相反如果没有任何一位存在两边都为 1 的情况，则结果一定是 0。所以我们仅在结果为 0 的时候去计算长度相乘。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        bitmasks, ans = &#123;&#125;, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            bitmask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> w:</span><br><span class="line">                bitmask |= <span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> bitmasks.items():</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> bitmask &amp; k:</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">len</span>(w) * v)</span><br><span class="line">            bitmasks[bitmask] = <span class="built_in">max</span>(<span class="built_in">len</span>(w), bitmasks.get(bitmask, <span class="number">0</span>))</span><br><span class="line">            <span class="comment"># print(bitmask, ans)</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>另一种位掩码的实现，按照下标映射位掩码，省去了 HashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bitmasks = <span class="keyword">new</span> <span class="keyword">int</span>[words.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) &#123;</span><br><span class="line">                bitmasks[i] |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((bitmasks[i] &amp; bitmasks[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = Math.max(ans, words[i].length() * words[j].length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>341. Flatten Nested List Iterator (Medium)</title>
    <url>/post/leetcode/341-Flatten-Nested-List-Iterator-Medium/</url>
    <content><![CDATA[<p>你需要实现一个迭代器来扁平化一个嵌套的整数数组。嵌套整数数组中可能存在整数元素和嵌套整数数组两种元素。</p>
<p>如果你选择的语言有生成器机制，那么这题会很简单。我们分别从生成器和 Stack 的应用来解决这道题。</p>
<span id="more"></span>

<p>With solutions both in Python and JavaScript.</p>
<p>先读题：</p>
<blockquote>
<p>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.</p>
<p>Implement the <code>NestedIterator</code> class:</p>
<ul>
<li><code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> Initializes the iterator with the nested list <code>nestedList</code>.</li>
<li><code>int next()</code> Returns the next integer in the nested list.</li>
<li><code>boolean hasNext()</code> Returns <code>true</code> if there are still some integers in the nested list and <code>false</code> otherwise.</li>
</ul>
</blockquote>
<p>题目比较明确，需要我们用迭代器接口来扁平化嵌套数组，需要实现 <code>next</code> 和 <code>hasNext</code> 接口。测试 Case 会调用 <code>hasNext</code> 来检查是否还有值没输出，然后调用 <code>next</code> 获取具体的值。</p>
<p>需求比较明确，例子看看就好。</p>
<p>Example 1:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Input: nestedList = [[1,1],2,[1,1]]</span><br><span class="line">Output: [1,1,2,1,1]</span><br><span class="line">Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Input: nestedList = [1,[4,[6]]]</span><br><span class="line">Output: [1,4,6]</span><br><span class="line">Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].</span><br></pre></td></tr></table></figure>

<h2 id="Submissions"><a href="#Submissions" class="headerlink" title="Submissions"></a>Submissions</h2><p>先贴一下我的结果，防止剧透，具体代码会贴在最后。</p>
<p><strong>Python</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
<th>Complexity</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>60 ms</td>
<td>92.67%</td>
<td>O(n)</td>
</tr>
<tr>
<td>Memory</td>
<td>17.5 MB</td>
<td>89.70%</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p><strong>JavaScript</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
<th>Complexity</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>88 ms</td>
<td>100.00%</td>
<td>O(n) for initialization, O(1) for retrieve values</td>
</tr>
<tr>
<td>Memory</td>
<td>49.6 MB</td>
<td>72.22%</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h2 id="思路-amp-Solutions"><a href="#思路-amp-Solutions" class="headerlink" title="思路 &amp; Solutions"></a>思路 &amp; Solutions</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>先来说说 Python 方案，说到最优的迭代方法，这就不得不说 Python 的生成器机制了。</p>
<p>下面是我的代码，可以看到逻辑上只是一个简单的递归，但是使用了生成器，让时间复杂度可以控制在 O(n)，同时由于没有使用额外的变量，空间复杂度为 O(1)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span>:</span></span><br><span class="line">    _gen = <span class="literal">None</span></span><br><span class="line">    _<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nestedList: [NestedInteger]</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">integer_retriever</span>(<span class="params">l</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">                <span class="keyword">if</span> i.isInteger():</span><br><span class="line">                    <span class="keyword">yield</span> i.getInteger()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">for</span> _i <span class="keyword">in</span> integer_retriever(i.getList()):</span><br><span class="line">                        <span class="keyword">yield</span> _i</span><br><span class="line"></span><br><span class="line">        self._gen = integer_retriever(nestedList)</span><br><span class="line">        self._retrieve()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_retrieve</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._<span class="built_in">next</span> = <span class="built_in">next</span>(self._gen)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            self._<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res = self._<span class="built_in">next</span></span><br><span class="line">        self._retrieve()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下。</p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
<th>Complexity</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>60 ms</td>
<td>92.67%</td>
<td>O(n)</td>
</tr>
<tr>
<td>Memory</td>
<td>17.5 MB</td>
<td>89.70%</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>再来看看一般思路。在初始化时将嵌套数组解构，然后每次从缓存中取值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;NestedInteger[]&#125;</span> <span class="variable">nestedList</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> NestedIterator = <span class="function"><span class="keyword">function</span> (<span class="params">nestedList</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._list = [];</span><br><span class="line">  <span class="keyword">const</span> denest = <span class="function">(<span class="params">nl</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (nest <span class="keyword">of</span> nl) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nest.isInteger()) &#123;</span><br><span class="line">        <span class="built_in">this</span>._list.push(nest.getInteger());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        denest(nest.getList());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  denest(nestedList);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@this <span class="variable">NestedIterator</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NestedIterator.prototype.hasNext = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._list.length &gt; <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@this <span class="variable">NestedIterator</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;integer&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NestedIterator.prototype.next = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._list.shift();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果如下。</p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
<th>Complexity</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>88 ms</td>
<td>100.00%</td>
<td>O(n) for initialization, O(1) for retrieve value</td>
</tr>
<tr>
<td>Memory</td>
<td>49.6 MB</td>
<td>72.22%</td>
<td>O(n)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
        <tag>Design</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title>37. Sudoku Solver (Hard)</title>
    <url>/post/leetcode/37-Sudoku-Solver-Hard/</url>
    <content><![CDATA[<p>数独问题。你需要实现一个游戏解决数独问题，数独游戏的规则如下：</p>
<ul>
<li>每一行中数字 <code>1 - 9</code> 只能出现一次；</li>
<li>每一列中数字 <code>1 - 9</code> 只能出现一次；</li>
<li>每个 <code>3 x 3</code> 的子矩阵中数字 <code>1 - 9</code> 只能出现一次。</li>
</ul>
<p>典型的回溯算法问题。</p>
<span id="more"></span>

<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>数独问题，适合回溯算法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Save board for further use.</span></span><br><span class="line">        self.board = board</span><br><span class="line">        <span class="comment"># print(self.solve())</span></span><br><span class="line">        self.solve()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findEmptyCell</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Find the next place need to be filled.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> self.board[i][j] == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> i, j</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkRow</span>(<span class="params">self, row, num</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Check if the target number is safe in row.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> num <span class="keyword">not</span> <span class="keyword">in</span> self.board[row]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkCol</span>(<span class="params">self, col, num</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Check if the target number is safe in column.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> self.board[row][col] == num:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkSquare</span>(<span class="params">self, row, col, num</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Check if the target number is safe in the nearest square.</span></span><br><span class="line"><span class="string">        We should find the first cell of the nearest square,</span></span><br><span class="line"><span class="string">        just subtract the result of modulo 3 from col and row to get it.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sr, sc = row - row % <span class="number">3</span>, col - col % <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sr, sr + <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sc, sc + <span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> self.board[i][j] == num:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The main body of our backtracking algorithm.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        row, col = self.findEmptyCell()</span><br><span class="line">        <span class="keyword">if</span> row == -<span class="number">1</span> <span class="keyword">and</span> col == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> [<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]:</span><br><span class="line">            <span class="keyword">if</span> (self.checkRow(row, num)</span><br><span class="line">                <span class="keyword">and</span> self.checkCol(col, num)</span><br><span class="line">                <span class="keyword">and</span> self.checkSquare(row, col, num)):</span><br><span class="line">                self.board[row][col] = num</span><br><span class="line">                <span class="keyword">if</span> self.solve():</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                self.board[row][col] = <span class="string">&quot;.&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>39. Combination Sum (Medium)</title>
    <url>/post/leetcode/39-Combination-Sum-Medium/</url>
    <content><![CDATA[<p>先读题，这种题真是脑细胞的初见杀。</p>
<blockquote>
<p>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.</p>
<p>The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p>
<p>It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</p>
</blockquote>
<span id="more"></span>

<h2 id="思路-amp-Solutions"><a href="#思路-amp-Solutions" class="headerlink" title="思路 &amp; Solutions"></a>思路 &amp; Solutions</h2><p>Backtrack</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">candidates</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum = <span class="function"><span class="keyword">function</span> (<span class="params">candidates, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">const</span> sz = candidates.length;</span><br><span class="line">  candidates.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">c, tar, comb, begin</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tar === <span class="number">0</span>) ans.push(comb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; sz; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tar &lt; c[i]) <span class="keyword">break</span>;</span><br><span class="line">      dfs(c, tar - c[i], [...comb, c[i]], i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dfs(candidates, target, [], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sz = candidates.length;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(candidates, target, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] c, <span class="keyword">int</span> tar, List&lt;Integer&gt; comb, <span class="keyword">int</span> begin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tar == <span class="number">0</span>) ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(comb));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tar &lt; c[i]) <span class="keyword">break</span>;</span><br><span class="line">            comb.add(c[i]);</span><br><span class="line">            dfs(c, tar - c[i], comb, i);</span><br><span class="line">            comb.remove(comb.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>45. Jump Game II (Medium)</title>
    <url>/post/leetcode/45-Jump-Game-II-Medium/</url>
    <content><![CDATA[<p>跳跃游戏。你有一个非负整数数组，最开始你在 0 的位置，数组每个数字意味你接下来能跳多远。</p>
<p>游戏的目标是到达数组的最后一个位置，你需要找到最少的跳跃次数到达终点。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n, ans, curr, nxt = <span class="built_in">len</span>(nums), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># No need of the last iteration so skip it here by `n - 1`.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            nxt = <span class="built_in">max</span>(nxt, i + nums[i])</span><br><span class="line">            <span class="keyword">if</span> i == curr:</span><br><span class="line">                curr = nxt</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, ans = <span class="number">0</span>, curr = <span class="number">0</span>, next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            next = Math.max(next, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == curr) &#123;</span><br><span class="line">                curr = next;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> jump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = nums.length,</span><br><span class="line">    curr = <span class="number">0</span>,</span><br><span class="line">    next = <span class="number">0</span>,</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    next = next &lt; i + nums[i] ? i + nums[i] : next;</span><br><span class="line">    <span class="keyword">if</span> (curr === i) &#123;</span><br><span class="line">      curr = next;</span><br><span class="line">      ans++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>453. Minimum Moves to Equal Array Elements (Easy)</title>
    <url>/post/leetcode/453-Minimum-Moves-to-Equal-Array-Elements-Easy/</url>
    <content><![CDATA[<p>你有一个长度为 <code>n</code> 的数组，允许你每次操作将 <code>n - 1</code> 个元素的值 +1，求最少需要多少操作次数让数组中的所有元素相等。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求每次给 <code>n - 1</code> 个元素加 1，重复这个步骤直到数组所有元素相等。我们不应该给 <code>max</code> 加 1，所以这一步实际上是给最大值以外的所有元素加 1，其等价于最大值减去 1。</p>
<p>一旦在脑子中把这个思路捋顺了，方案就简单了。实际上我们要找到的是每一个元素减到最小值需要减去的次数。</p>
<p>算法已经浮出水面，我们先找到最小值，然后计算每个元素和最小值的差的和，这个和就是答案。</p>
<blockquote>
<p>这是数学法，也称“感觉智商丢掉”法。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m, ans = <span class="built_in">min</span>(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            ans += n - m</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>基于这个思路，实际上我们把最小值减去了 <code>n</code> 次，那么找到最小值之后，我们对数组求和之后再减去数组长度乘以最小值，得到的结果就是答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(nums) - <span class="built_in">min</span>(nums) * <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>462. Minimum Moves to Equal Array Elements II (Medium)</title>
    <url>/post/leetcode/462-Minimum-Moves-to-Equal-Array-Elements-II-Medium/</url>
    <content><![CDATA[<p>你有一个数组，允许你每次操作将任意一个元素的值 +1 或 -1，求最少需要多少操作次数让数组中的所有元素相等。</p>
<span id="more"></span>

<h2 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h2><p>题目要求我们用最少的步数将数组元素修正到全部相等，换句话来说就是需要找到一个合适的目标，将其他数补上差值修正到与这个数相等，答案就是这些差值的和。</p>
<p>题目的难点在于如何意识到我们要寻找的目标是数组的中位数。</p>
<p>我们可以准备一个数组，首先将其排序，思考一下第一个数和最后一个数修正到目标数需要的步数。</p>
<p>我们会发现，第一个数和最后一个数中间的任何数都符合要求，因为最少步数实际上就是第一个数和最后一个数的差值。</p>
<p>我们进一步发现需要确认合适的目标，我们还需要继续确认第二个数和倒数第二个数修正到目标需要的步数。</p>
<p>我们重复这个过程，最终会有两种情况。</p>
<ul>
<li>如果数组的长度为奇数：最后找到的唯一一个数就是目标值；</li>
<li>如果数组的长度为偶数：最后找到的一对数之间的任何值都是目标值，也包括这对数本身。</li>
</ul>
<p>再仔细想想，我们在寻找的其实就是数组的中位数。现在算法浮出水面了。</p>
<ul>
<li>方便起见我们将数组进行排序；</li>
<li>根据长度找到数组中位数的值，不用考虑太多，直接取长度除以 2 的整数值；</li>
<li>计算所有元素与目标的差的绝对值，进行求和。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves2</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        m = nums[<span class="built_in">len</span>(nums) &gt;&gt; <span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            ans += <span class="built_in">abs</span>(i - m)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Sorting</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>48. Rotate Image (Medium)</title>
    <url>/post/leetcode/48-Rotate-Image-Medium/</url>
    <content><![CDATA[<p>矩阵问题。旋转图片 90 度。</p>
<p>图片本身是一组储存了颜色信息的矩阵数据，旋转一张图片即将矩阵中对应的颜色值移动到对应的位置上。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, m: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sz = <span class="built_in">len</span>(m)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sz // <span class="number">2</span> + sz % <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sz // <span class="number">2</span>):</span><br><span class="line">                m[i][j], m[j][~i], m[~i][~j], m[~j][i] = m[~j][i], m[i][j], m[j][~i], m[~i][~j]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Matrix</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>509. Fibonacci Number (Easy)</title>
    <url>/post/leetcode/509-Fibonacci-Number-Easy/</url>
    <content><![CDATA[<p>生成指定位置的斐波那契数。Hello World 级别的问题，难点是对时间和空间复杂度的控制。</p>
<blockquote>
<p>The Fibonacci numbers, commonly denoted <code>F(n)</code> form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,</p>
<ul>
<li>F(0) = 0, F(1) = 1</li>
<li>F(n) = F(n - 1) + F(n - 2), for n &gt; 1.</li>
<li>Given n, calculate F(n).</li>
</ul>
</blockquote>
<span id="more"></span>

<blockquote>
<p>官解比较变态。</p>
</blockquote>
<p>不多说，上正文。</p>
<h2 id="思路-amp-Solutions"><a href="#思路-amp-Solutions" class="headerlink" title="思路 &amp; Solutions"></a>思路 &amp; Solutions</h2><h3 id="方法一，递归（不推荐）"><a href="#方法一，递归（不推荐）" class="headerlink" title="方法一，递归（不推荐）"></a>方法一，递归（不推荐）</h3><p>实现一个 <code>F(n) = F(n - 1) + F(n - 2)</code>，缺点就是时间复杂度是 O(2^n)。</p>
<h3 id="方法二，递归-DP"><a href="#方法二，递归-DP" class="headerlink" title="方法二，递归+DP"></a>方法二，递归+DP</h3><p>实现一个 <code>F(n) = F(n - 1) + F(n - 2)</code>，但是每次计算结果缓存起来，不再重复相同的计算。</p>
<p>跳过。</p>
<h3 id="方法三，Bottom-Up"><a href="#方法三，Bottom-Up" class="headerlink" title="方法三，Bottom-Up"></a>方法三，Bottom-Up</h3><p>抛开递归，记录前一个值，按照斐波那契数列的规律计算到 n 为止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">          <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = <span class="number">0</span></span><br><span class="line">            ans = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">                ans, pre = ans + pre, ans</span><br><span class="line">            <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<blockquote>
<p>官解给出了矩阵幂和黄金比例的方法，跳过…</p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Math</tag>
        <tag>Recursion</tag>
        <tag>Memoization</tag>
      </tags>
  </entry>
  <entry>
    <title>51. N-Queens (Hard)</title>
    <url>/post/leetcode/51-N-Queens-Hard/</url>
    <content><![CDATA[<p>国际象棋问题。给你一个 <code>n x n</code> 大小的棋盘，你需要在上面摆放 Queen 棋子，并且让棋子之间不能相互攻击。</p>
<blockquote>
<p>Tips</p>
<p>Queen 可以在行、列、对角线和反对角线这四条线上随意行动，我们在放 Queen 时要保证这四个方向上没有 Queen 存在。</p>
</blockquote>
<p>我们需要遍历尽可能多的摆放方法才能确认最终的答案，我们用回溯算法对枚举进行剪纸来解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一个典型回溯法的应用场景，即我们需要尝试把 Queen 放在这一行的每个位置之后，才能知道所有可能的摆法。</p>
<p>比较容易忽视的点是，虽然我们可以轻松观察得知一行只有一个 Queen，所以行是不需要判断的，只需要判断列、对角线和反对角线上是否存在 Queen，但是这三条线是需要分开判断的。</p>
<p>我们需要准备 3 个 set 来保存已经使用过的列、对角线和反对角线。逻辑比较简单，我们通过代码和注释来理解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">        <span class="comment"># Prepare the answer list and an empty board in the required format.</span></span><br><span class="line">        ans, board = [], [[<span class="string">&#x27;.&#x27;</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">format</span>(<span class="params">res</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;Produce the output to meet to required format.&quot;&quot;&quot;</span></span><br><span class="line">            out = []</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> res:</span><br><span class="line">                out.append(<span class="string">&#x27;&#x27;</span>.join(row))</span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">row, cols, diag, anti, res</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;Solve recursively.&quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># The base case that we know we&#x27;ve got a right answer.</span></span><br><span class="line">            <span class="keyword">if</span> row == n:</span><br><span class="line">                ans.append(<span class="built_in">format</span>(res))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Try each position at this row.</span></span><br><span class="line">            <span class="keyword">for</span> q <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># Calculate the top point of diagonal and anti-diagonal.</span></span><br><span class="line">                d, a = q - row, q + row</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Check if the current place can place a Queen.</span></span><br><span class="line">                <span class="keyword">if</span> q <span class="keyword">not</span> <span class="keyword">in</span> cols <span class="keyword">and</span> d <span class="keyword">not</span> <span class="keyword">in</span> diag <span class="keyword">and</span> a <span class="keyword">not</span> <span class="keyword">in</span> anti:</span><br><span class="line">                    cols.add(q)</span><br><span class="line">                    diag.add(d)</span><br><span class="line">                    anti.add(a)</span><br><span class="line">                    res[row][q] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line"></span><br><span class="line">                    solve(row + <span class="number">1</span>, cols, diag, anti, res)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># Backtracking.</span></span><br><span class="line">                    cols.remove(q)</span><br><span class="line">                    diag.remove(d)</span><br><span class="line">                    anti.remove(a)</span><br><span class="line">                    res[row][q] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line"></span><br><span class="line">        solve(<span class="number">0</span>, <span class="built_in">set</span>(), <span class="built_in">set</span>(), <span class="built_in">set</span>(), board)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>52. N-Queens II (Hard)</title>
    <url>/post/leetcode/52-N-Queens-II-Hard/</url>
    <content><![CDATA[<p>国际象棋问题。求在 <code>n x n</code> 的棋盘上摆放 Queen 棋子并让其不能相互攻击的布局数量。</p>
<p>和 51 是孪生问题，不再赘述。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>感觉在刷分 hhh。和 51 完全一样，不同之处在于这题只要计数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">place</span>(<span class="params">pos, cols, diag, anti</span>):</span></span><br><span class="line">            <span class="keyword">if</span> pos == n:</span><br><span class="line">                self.ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                d, a = i - pos, i + pos</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> cols <span class="keyword">and</span> d <span class="keyword">not</span> <span class="keyword">in</span> diag <span class="keyword">and</span> a <span class="keyword">not</span> <span class="keyword">in</span> anti:</span><br><span class="line">                    cols.add(i)</span><br><span class="line">                    diag.add(d)</span><br><span class="line">                    anti.add(a)</span><br><span class="line">                    place(pos + <span class="number">1</span>, cols, diag, anti)</span><br><span class="line">                    cols.remove(i)</span><br><span class="line">                    diag.remove(d)</span><br><span class="line">                    anti.remove(a)</span><br><span class="line"></span><br><span class="line">        place(<span class="number">0</span>, <span class="built_in">set</span>(), <span class="built_in">set</span>(), <span class="built_in">set</span>())</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>583. Delete Operation for Two Strings (Medium)</title>
    <url>/post/leetcode/583-Delete-Operation-for-Two-Strings-Medium/</url>
    <content><![CDATA[<p>字符串问题。你有两个字符串，允许你每次在任意一个字符串上删除一个字符，求需要多少步才能让两个字符串相等。</p>
<p>使用 DP 解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i, j] = i + j</span><br><span class="line">                <span class="keyword">elif</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i, j] = dp[i - <span class="number">1</span>, j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i, j] = <span class="number">1</span> + <span class="built_in">min</span>(dp[i - <span class="number">1</span>, j], dp[i, j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m, n]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>589. N-ary Tree Preorder Traversal (Easy)</title>
    <url>/post/leetcode/589-N-ary-Tree-Preorder-Traversal-Easy/</url>
    <content><![CDATA[<p>N 叉树前序遍历问题。和二叉树前序遍历的区别在于…多了几个 child，仅此而已。</p>
<blockquote>
<p>Given the root of an n-ary tree, return the preorder traversal of its nodes’ values.</p>
<p>Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)</p>
</blockquote>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        ans, stack = [], [root,]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            top = stack.pop()</span><br><span class="line">            ans.append(top.val)</span><br><span class="line">            stack.extend(top.children[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>609. Find Duplicate File in System (Medium)</title>
    <url>/post/leetcode/609-Find-Duplicate-File-in-System-Medium/</url>
    <content><![CDATA[<p>寻找系统中的重复文件。你会得到下面结构的字符串数组，这表示在 <code>root/d1/d2/.../dm</code> 目录下存在 <code>n</code> 个文件，分别命名为 <code>f1, f2, ..., fn</code>，文件名后括号内为文件的内容。你需要找到所有内容重复的文件，并返回文件的路径。</p>
<blockquote>
<p>“root/d1/d2/…/dm f1.txt(f1_content) f2.txt(f2_content) … fn.txt(fn_content)”</p>
</blockquote>
<span id="more"></span>

<h2 id="思路-1-使用哈希表"><a href="#思路-1-使用哈希表" class="headerlink" title="思路 1 使用哈希表"></a>思路 1 使用哈希表</h2><p>以文件内容为 key，拼出文件名存到字典中，最后遍历字典所有值，存在长度大于 1 的列表则表示存在内容重复。这道题还是比较亲切，实际工作中确实会遇到这类问题。</p>
<p>下面是代码例子。</p>
<blockquote>
<p>其实做的粗糙一点，去掉 <code>c = c[:-1]</code> 这句也能实现，而且少一个字符串处理性能会更好。毕竟我们不在意文件内容实际是什么，只在意有没有重复。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, paths: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">        table = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> paths:</span><br><span class="line">            f = f.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">            p = f[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> f[<span class="number">1</span>:]:</span><br><span class="line">                fn, c = i.split(<span class="string">&quot;(&quot;</span>)</span><br><span class="line">                c = c[:-<span class="number">1</span>]</span><br><span class="line">                table[c].append(<span class="string">f&quot;<span class="subst">&#123;p&#125;</span>/<span class="subst">&#123;fn&#125;</span>&quot;</span>)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> table.values():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(v) &gt; <span class="number">1</span>:</span><br><span class="line">                ans.append(v)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>Java 例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findDuplicate(String[] paths) &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; table = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String p : paths) &#123;</span><br><span class="line">            String[] f = p.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            String pr = f[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; f.length; i++) &#123;</span><br><span class="line">                String[] file = f[i].split(<span class="string">&quot;\\(&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (!table.containsKey(file[<span class="number">1</span>])) &#123;</span><br><span class="line">                    table.put(file[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                table.get(file[<span class="number">1</span>]).add(pr + <span class="string">&quot;/&quot;</span> + file[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; val : table.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                ans.add(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JS 例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">paths</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findDuplicate = <span class="function"><span class="keyword">function</span> (<span class="params">paths</span>) </span>&#123;</span><br><span class="line">  table = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paths) &#123;</span><br><span class="line">    p = p.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> pr = p[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; p.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> file = p[i].split(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (!table[file[<span class="number">1</span>]]) table[file[<span class="number">1</span>]] = [];</span><br><span class="line">      table[file[<span class="number">1</span>]].push(pr + <span class="string">&#x27;/&#x27;</span> + file[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> table) &#123;</span><br><span class="line">    <span class="keyword">if</span> (table[k].length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      ans.push(table[k]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>62. Unique Paths (Medium)</title>
    <url>/post/leetcode/62-Unique-Paths-Medium/</url>
    <content><![CDATA[<p>组合问题。机器人在矩阵的左上角需要去矩阵的右下角，且机器人只能向下和向右行动。</p>
<p>你需要实现一个程序计算机器人有多少条路径到达右下角。</p>
<span id="more"></span>

<h2 id="思路-DP"><a href="#思路-DP" class="headerlink" title="思路 DP"></a>思路 DP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [[<span class="number">1</span>]*n] * m</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[x][y] = dp[x-<span class="number">1</span>][y] + dp[x][y-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Math</tag>
        <tag>Combinatorics</tag>
      </tags>
  </entry>
  <entry>
    <title>63. Unique Paths II (Medium)</title>
    <url>/post/leetcode/63-Unique-Paths-II-Medium/</url>
    <content><![CDATA[<p>路径问题。一个机器人在 <code>m x n</code> 矩阵的左上角 (0, 0) 位置，矩阵中存在诺干障碍物，机器人只能向下或者向右移动，你需要实现一个程序计算机器人有多少条路径可以到达右下角的 (m, n) 位置。</p>
<p>这是典型的 DP 问题。</p>
<span id="more"></span>

<h2 id="思路-DP"><a href="#思路-DP" class="headerlink" title="思路 DP"></a>思路 DP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, og: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(og)):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(og[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">and</span> y == <span class="number">0</span>:</span><br><span class="line">                    up, left = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    up = og[x-<span class="number">1</span>][y] <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                    left = og[x][y-<span class="number">1</span>] <span class="keyword">if</span> y &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> og[x][y] == <span class="number">0</span>:</span><br><span class="line">                    og[x][y] = up + left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    og[x][y] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> og[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DP</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>630. Course Schedule III (Hard)</title>
    <url>/post/leetcode/630-Course-Schedule-III-Hard/</url>
    <content><![CDATA[<p>课程安排问题。一共有 <code>n</code> 门不同的在线课程，你会得到一个 <code>courses</code> 数组包含每门课程的持续时间和最后期限。</p>
<p>你将从第 1 天开始课程学习，你 1 天只能专注一门课程，不能多门课程同时进行。</p>
<p>计算出你最多能完成多少门课程。</p>
<span id="more"></span>

<h2 id="思路-1，优先队列"><a href="#思路-1，优先队列" class="headerlink" title="思路 1，优先队列"></a>思路 1，优先队列</h2><p>虽然做出来了，但是成绩比较差，这一块需要研究一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scheduleCourse</span>(<span class="params">self, courses: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        c = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">sorted</span>(courses, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])]</span><br><span class="line">        heap = []</span><br><span class="line">        time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(c):</span><br><span class="line">            <span class="keyword">if</span> time + x[<span class="number">0</span>] &lt;= x[<span class="number">1</span>]:</span><br><span class="line">                time += x[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(heap) &gt; <span class="number">0</span> <span class="keyword">and</span> heap[-<span class="number">1</span>] &gt; x[<span class="number">0</span>] <span class="keyword">and</span> time - heap[-<span class="number">1</span>] + x[<span class="number">0</span>] &lt;= x[<span class="number">1</span>]:</span><br><span class="line">                time +=  - heap.pop() + x[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            heap.append(x[<span class="number">0</span>])</span><br><span class="line">            heap.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(heap)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2-大根堆"><a href="#思路-2-大根堆" class="headerlink" title="思路 2, 大根堆"></a>思路 2, 大根堆</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scheduleCourse</span>(<span class="params">self, courses: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        c = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">sorted</span>(courses, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])]</span><br><span class="line">        time, heap = <span class="number">0</span>, []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(c):</span><br><span class="line">            <span class="keyword">if</span> time + x[<span class="number">0</span>] &lt;= x[<span class="number">1</span>]:</span><br><span class="line">                time += x[<span class="number">0</span>]</span><br><span class="line">                heappush(heap, -x[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">elif</span> heap:</span><br><span class="line">                <span class="keyword">if</span> -heap[<span class="number">0</span>] &gt; x[<span class="number">0</span>]:</span><br><span class="line">                    time += heappop(heap) + x[<span class="number">0</span>]</span><br><span class="line">                    heappush(heap, -x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(heap)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
        <tag>Heap (Priority Queue)</tag>
      </tags>
  </entry>
  <entry>
    <title>65. Valid Number (Hard)</title>
    <url>/post/leetcode/65-Valid-Number-Hard/</url>
    <content><![CDATA[<p>字符串问题。一个字符串数字，你需要判断这个数字是否有效。需要满足一堆条件。</p>
<p>考验归纳的问题。我们从正则取巧和数学归纳的角度来解决这道题。</p>
<span id="more"></span>

<h2 id="正则思路"><a href="#正则思路" class="headerlink" title="正则思路"></a>正则思路</h2><p>取巧使用正则，一行方案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        ptn = <span class="string">r&#x27;^[+-]?(\d+\.|\d*\.\d+|\d+)([eE][+-]?\d+)?$&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> re.match(ptn, s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><p>使用数学归纳法的思路。先整理无效数字的模式。</p>
<ul>
<li><code>+/-</code> 出现在数字之后</li>
<li><code>.</code> 重复或出现在 exp 之后</li>
<li><code>e/E</code> 重复或前面没数字</li>
</ul>
<p>总结得知，我们需要对应是否为数字、小数、符号、指数设置 4 个 flag，然后依次迭代字符串的每一个字符，根据当前 flag 的值进行判断。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isNumber = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num, dec, sign, exp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> s.split(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// Check number.</span></span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&quot;0&quot;</span> &amp;&amp; c &lt;= <span class="string">&quot;9&quot;</span>) num = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// Check sign.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="string">&quot;+&quot;</span> || c === <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// If sign duplicated or appears after number or decimal.</span></span><br><span class="line">      <span class="keyword">if</span> (sign || num || dec) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      sign = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// Check decimal.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="string">&quot;.&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// If duplicated or appears after exponent.</span></span><br><span class="line">      <span class="keyword">if</span> (dec || exp) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      dec = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// Check exponent.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="string">&quot;e&quot;</span> || c === <span class="string">&quot;E&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// If duplicated or no number before it.</span></span><br><span class="line">      <span class="keyword">if</span> (exp || !num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      (exp = <span class="literal">true</span>), (num = <span class="literal">false</span>), (sign = <span class="literal">false</span>), (dec = <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// Failed.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !!num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>665. Non-decreasing Array (Medium)</title>
    <url>/post/leetcode/665-Non-decreasing-Array-Medium/</url>
    <content><![CDATA[<p>数组问题。你有一个整数数组，你有一次机会修改其中的一个值，你需要检查这个数组是否能构成一个非递减数组。</p>
<p>非递减，换个思路就是递增数组。检查数组元素顺序是否为递增，并允许一次例外。</p>
<span id="more"></span>

<h2 id="思路-1，从后往前判断，允许一次失败"><a href="#思路-1，从后往前判断，允许一次失败" class="headerlink" title="思路 1，从后往前判断，允许一次失败"></a>思路 1，从后往前判断，允许一次失败</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        modified = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums))):</span><br><span class="line">            <span class="comment"># print(nums[i] , nums[i - 1])</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> modified:</span><br><span class="line">                    <span class="keyword">if</span> i != <span class="built_in">len</span>(nums) - <span class="number">1</span> <span class="keyword">and</span> nums[i + <span class="number">1</span>] &lt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                        nums[i - <span class="number">1</span>] = nums[i]</span><br><span class="line">                    modified = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="思路-2，颠倒符号从前往后，允许一次失败"><a href="#思路-2，颠倒符号从前往后，允许一次失败" class="headerlink" title="思路 2，颠倒符号从前往后，允许一次失败"></a>思路 2，颠倒符号从前往后，允许一次失败</h2><p>把题目转化为递增数组的思路，避免了颠倒数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        modified = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> modified:</span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">1</span> <span class="keyword">and</span> nums[i] &lt; nums[i - <span class="number">2</span>]:</span><br><span class="line">                        nums[i] = nums[i - <span class="number">1</span>]</span><br><span class="line">                    modified = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="思路-3，数学归纳"><a href="#思路-3，数学归纳" class="headerlink" title="思路 3，数学归纳"></a>思路 3，数学归纳</h2><p>评论区大神给的思路，只允许修改一次值的情况下，只有 YABY 这种情况是直接丢出 <code>false</code>，其余情况可以通过修改一次值通过。这个算法可以在不进行任何值的修改的前提下，进行正确的判断。</p>
<p><img src="/images/leetcode/665.idea.png" alt="665.idea.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        modified = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># Return False if modified before, or if these conditions are satisfied.</span></span><br><span class="line">                <span class="keyword">if</span> modified <span class="keyword">or</span> (</span><br><span class="line">                    <span class="comment"># Ensure `i - 2` and  `i + 1` exist,</span></span><br><span class="line">                    i &gt; <span class="number">1</span></span><br><span class="line">                    <span class="keyword">and</span> i &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">                    <span class="comment"># if `i - 2` &gt; `i`, it&#x27;s a YAB of YABY,</span></span><br><span class="line">                    <span class="keyword">and</span> nums[i - <span class="number">2</span>] &gt; nums[i]</span><br><span class="line">                    <span class="comment"># if `i - 1` &gt; `i + 1`, it&#x27;s a ABY of YABY.</span></span><br><span class="line">                    <span class="keyword">and</span> nums[i - <span class="number">1</span>] &gt; nums[i + <span class="number">1</span>]</span><br><span class="line">                ):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># If it&#x27;s not the cases above, set modified to True,</span></span><br><span class="line">                <span class="comment"># no more chance for the next violation.</span></span><br><span class="line">                modified = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>667. Beautiful Arrangement II （Medium）</title>
    <url>/post/leetcode/667-Beautiful-Arrangement-II-Medium/</url>
    <content><![CDATA[<p>给定两个数 <code>n</code> 和 <code>k</code>，你需要构建一个数组包含从 <code>1</code> 到 <code>n</code> 的正整数，并且相邻两个数的差组成的数组必须要有 <code>k</code> 个不重复的元素。</p>
<span id="more"></span>

<h2 id="Understanding-the-Problem"><a href="#Understanding-the-Problem" class="headerlink" title="Understanding the Problem"></a>Understanding the Problem</h2><p>With solutions both in Python and Java.</p>
<p>先读题：</p>
<blockquote>
<p>Given two integers <code>n</code> and <code>k</code>, you need to construct a list which contains <code>n</code> different positive integers ranging from 1 to <code>n</code> and obeys the following requirement:</p>
<p>Suppose this list is <code>[a1, a2, a3, ... , an]</code>, then the list <code>[|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|]</code> has exactly <code>k</code> distinct integers.</p>
<p>If there are multiple answers, print any of them.</p>
</blockquote>
<p>简而言之，我们要根据两个整数参数 <code>n</code> 和 <code>k</code>，来输出一个从 1 开始到 <code>n</code> 的整数数组，并且这个数组中，所有相邻的两个整数之间的差，其绝对值要凑齐 <code>k</code> 个不同的整数。</p>
<p>来看看例子。</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3, k = 1</span><br><span class="line">Output: [1, 2, 3]</span><br><span class="line">Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.</span><br></pre></td></tr></table></figure>

<p>输出结果为整数 1 ～ 3，相邻整数的差为 [1, 1]，去重后长度为 1，满足 <code>k = 1</code> 的需求。</p>
<p>Example 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3, k = 2</span><br><span class="line">Output: [1, 3, 2]</span><br><span class="line">Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.</span><br></pre></td></tr></table></figure>

<p>输出结果为整数 1 ～ 3，相邻整数的差为 [2, 1]，满足 <code>k = 2</code> 的需求。</p>
<h2 id="Submission"><a href="#Submission" class="headerlink" title="Submission"></a>Submission</h2><p>先贴一下我自己独立完成的结果，防止剧透，具体代码会贴在最后。</p>
<p>我的代码中，空间复杂度还需要研究一下，目前还没找到提升的思路。</p>
<p><strong>Python</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>40 ms</td>
<td>96.55%</td>
</tr>
<tr>
<td>Memory</td>
<td>15.1 MB</td>
<td>50.34%</td>
</tr>
</tbody></table>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题偏重考验观察。我们要做的是观察并找到数组排列的规律，用算法实现出来。</p>
<p>已知条件：</p>
<ul>
<li>输出数组包含 1 ～ n 的整数</li>
<li>需要做的是调整数组中数字出现的顺序，致使相邻的两个数之间的差不同</li>
<li>相邻两个数的差只考虑绝对值</li>
<li>相邻两个数的差的绝对值构成的数组长度为 k</li>
<li>由于不关注具体的差的值，所以有不同解法，只需要找出一种</li>
</ul>
<p>先硬算几个例子来找找规律。</p>
<p>(因为懒，这里我直接贴讨论帖中的例子，UAADs 指的是唯一绝对相邻数差，贴主原文全称是 Unique Absolute Adjacent Difference，为了方便理解，后面我们就称之为“相邻数差”。)</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">For eg.</span><br><span class="line">1. let n = 10, k = 4</span><br><span class="line">permutation =&gt; [1, 5, 2, 4, 3, 6, 7, 8, 9, 10]</span><br><span class="line">UAADs       =&gt; [X, 4, 3, 2, 1, 3, 1, 1, 1, 1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. n = 10, k = 5</span><br><span class="line">permutation =&gt; [1, 6, 2, 5, 3, 4, 7, 8, 9, 10]</span><br><span class="line">UAADs       =&gt; [X, 5, 4, 3, 2, 1, 3, 1, 1, 1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. n = 9, k = 8</span><br><span class="line">permutation =&gt; [1, 9, 2, 8, 3, 7, 4, 6, 5]</span><br><span class="line">UAADs       =&gt; [X, 8, 7, 6, 5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>

<p>题目不关注相邻数差的具体数值，所以正确的排列方式不止一种，这里我们只讨论可以相对直观理解的一种。</p>
<p>观察上面例子可以了解到：</p>
<ul>
<li>输出的数组从 1 开始</li>
<li>第二个数是 k + 1</li>
<li>要求 k 个不同相邻数差会影响 k 个元素</li>
<li>不受 k 影响的数按自然顺序排序</li>
</ul>
<blockquote>
<p>可能 <code>要求 k 个不同相邻数差会影响 k 个元素</code> 不是很直观，我们通过分解上面的例子来理解。</p>
<p>下面结论中，1 一直处于固定位置，高亮出来的部分是排序受到 k 影响的数，而剩余的数（如果有的话）将按照递增排序。</p>
<p>n = 10, k = 4 =&gt; [1, <code>5, 2, 4, 3,</code> 6, 7, 8, 9, 10]</p>
<p>n = 10, k = 5 =&gt; [1, <code>6, 2, 5, 3, 4,</code> 7, 8, 9, 10]</p>
<p>n = 9, k = 8 =&gt; [1, <code>9, 2, 8, 3, 7, 4, 6, 5</code>]</p>
</blockquote>
<p>设定好了前提，接下来我们需要关注的问题变成了观察并理解“受到 k 影响的元素应该如何排序”。</p>
<p>多看几眼上面的例子，我们可以直观的意识到规律：为了满足 k 个不同的相邻数差，我们将排序靠后的数依次插入到 <code>1, 2, 3, ..., n</code> 之间，来制造不同的绝对差。</p>
<p>了解规律之后，可以开始实现算法了，这是一些对于时间复杂度和空间复杂度的考虑。</p>
<ul>
<li>避免使用尾递归</li>
<li>控制循环次数</li>
<li>不使用非必要的变量</li>
</ul>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArray</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># 初始化一个数组，由于前两个值是已知的，所以直接写入字面量</span></span><br><span class="line">        ans = [<span class="number">1</span>, k + <span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 以 k 为基准进行循环</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k):</span><br><span class="line">            <span class="comment"># 取倒数第二个值为计算基数，根据当前 index 决定做递增或递减</span></span><br><span class="line">            ans.append(ans[-<span class="number">2</span>] + (<span class="number">1</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span>))</span><br><span class="line">        <span class="comment"># 按自然顺序填充剩下的元素</span></span><br><span class="line">        ans += <span class="built_in">range</span>(k + <span class="number">2</span>, n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>结果如下。</p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>40 ms</td>
<td>96.55%</td>
</tr>
<tr>
<td>Memory</td>
<td>15.1 MB</td>
<td>50.34%</td>
</tr>
</tbody></table>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>由于先做出了 Python 版本，相同思路转换成 Java 代码结果很糟糕。</p>
<p>这里根据讨论帖的提示完成了一个较优的方案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArray(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// l 为递增初始值，r 为递减初始值，用 i 来保存 index</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = k + <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 执行一个步长为 2 的循环来填充数组直到满足 k 个相邻数差</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; k) &#123;</span><br><span class="line">            ans[i++] = l++;</span><br><span class="line">            ans[i++] = r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于数组以1起始，故当 k 为偶数时做 2 步长的循环将漏掉一个数</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) ans[i++] = r;</span><br><span class="line">        <span class="comment">// 依序填充自然递增的数直到填至 n 为止</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) ans[i++] = i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下。</p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>0 ms</td>
<td>100.00%</td>
</tr>
<tr>
<td>Memory</td>
<td>39.1 MB</td>
<td>73.71%</td>
</tr>
</tbody></table>
<blockquote>
<p>受 Java 版本思路启发，我修改了一下 Python 的算法，在空间复杂度上得到一些提升。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">constructArray</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">       ans = [<span class="number">1</span>, k + <span class="number">1</span>]</span><br><span class="line">       <span class="comment"># 执行一个步长为 2 的循环来制造不同的相邻数差</span></span><br><span class="line">       <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, k, <span class="number">2</span>):</span><br><span class="line">           ans.append(ans[x-<span class="number">2</span>] + <span class="number">1</span>)</span><br><span class="line">           ans.append(ans[x-<span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">       <span class="comment"># 补充 k 为偶数时漏掉的数</span></span><br><span class="line">       <span class="keyword">if</span> ans[-<span class="number">1</span>] -<span class="number">2</span> == ans[-<span class="number">2</span>]: ans.append(ans[-<span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">       ans += <span class="built_in">range</span>(<span class="built_in">len</span>(ans) + <span class="number">1</span>, n + <span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>结果如下。</p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>40 ms</td>
<td>96.55%</td>
</tr>
<tr>
<td>Memory</td>
<td>15.1 MB</td>
<td>82.76%</td>
</tr>
</tbody></table>
</blockquote>
<h2 id="官方-Solution"><a href="#官方-Solution" class="headerlink" title="官方 Solution"></a>官方 Solution</h2><p>来学习一下官方答案的思路。这个问题官方给出了 2 个方案。</p>
<h3 id="Approach-1-Brute-Force-Time-Limit-Exceeded"><a href="#Approach-1-Brute-Force-Time-Limit-Exceeded" class="headerlink" title="Approach #1: Brute Force [Time Limit Exceeded]"></a>Approach #1: Brute Force [Time Limit Exceeded]</h3><p>顾名思义，这个方法是暴力枚举所有排列，直到找到合适的排列。具体做法是准备一个检查唯一相邻数差数量的函数，然后对 1 ～ n 的数组排列进行枚举，直到找到该函数返回的唯一相邻数差的数量匹配 k 的值…</p>
<p>这个方法就不细说了，下面的代码看看就好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArray</span>(<span class="params">self, n, k</span>):</span></span><br><span class="line">        seen = [<span class="literal">False</span>] * n</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">num_uniq_diffs</span>(<span class="params">arr</span>):</span></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                seen[i] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>):</span><br><span class="line">                delta = <span class="built_in">abs</span>(arr[i] - arr[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> seen[delta]:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    seen[delta] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cand <span class="keyword">in</span> itertools.permutations(<span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> num_uniq_diffs(cand) == k:</span><br><span class="line">                <span class="keyword">return</span> cand</span><br></pre></td></tr></table></figure>

<h3 id="Approach-2-Construction-Accepted"><a href="#Approach-2-Construction-Accepted" class="headerlink" title="Approach #2: Construction [Accepted]"></a>Approach #2: Construction [Accepted]</h3><p>先看看官方原文，不过有些 LaTex 表达式不一定能正常显示，可以去 <a href="https://leetcode.com/problems/beautiful-arrangement-ii/solution/">原地址</a> 查看。看完原文我们来分析和理解一下官方的思路。</p>
<blockquote>
<p><strong>Intuition</strong></p>
<p>When \text{k = n-1}k = n-1, a valid construction is \text{[1, n, 2, n-1, 3, n-2, ….]}[1, n, 2, n-1, 3, &gt; n-2, ….]. One way to see this is, we need to have a difference of \text{n-1}n-1, which means we need &gt; \text{1}1 and \text{n}n adjacent; then, we need a difference of \text{n-2}n-2, etc.</p>
<p>Also, when \text{k = 1}k = 1, a valid construction is \text{[1, 2, 3, …, n]}[1, 2, 3, …, n]. So we &gt; have a construction when \text{n-k}n-k is tiny, and when it is large. This leads to the idea that we can &gt; stitch together these two constructions: we can put \text{[1, 2, …, n-k-1]}[1, 2, …, n-k-1] first so &gt; that \text{n}n is effectively \text{k+1}k+1, and then finish the construction with the first \text{“k = &gt; n-1”}”k = n-1” method.</p>
<p>For example, when \text{n = 6}n = 6 and \text{k = 3}k = 3, we will construct the array as \text{[1, 2, 3, &gt; 6, 4, 5]}[1, 2, 3, 6, 4, 5]. This consists of two parts: a construction of \text{[1, 2]}[1, 2] and a &gt; construction of \text{[1, 4, 2, 3]}[1, 4, 2, 3] where every element had \text{2}2 added to it (i.e. \text{&gt; [3, 6, 4, 5]}[3, 6, 4, 5]).</p>
<p><strong>Algorithm</strong></p>
<p>As before, write \text{[1, 2, …, n-k-1]}[1, 2, …, n-k-1] first. The remaining \text{k+1}k+1 elements &gt; to be written are \text{[n-k, n-k+1, …, n]}[n-k, n-k+1, …, n], and we’ll write them in alternating &gt; head and tail order.</p>
<p>When we are writing the i^{th}i<br>th<br>element from the remaining \text{k+1}k+1, every even ii is going to be chosen from the head, and will &gt; have value \text{n-k + i//2}n-k + i//2. Every odd ii is going to be chosen from the tail, and will have &gt; value \text{n - i//2}n - i//2.</p>
</blockquote>
<p>按照这个方案的思路，首先我们观察俩个极端：k 为最大值 n-1 时的结果；以及 k 为最小值 1 时的结果。</p>
<p>当 k = n - 1 时，这个时候数组根据数组序列（index）的奇偶性，出现奇数取头部（[1, 2, 3, …]），偶数取尾部（[n, n-1, n-2, …]）的规律。其最终结果如下。</p>
<p><code>[1, n, 2, n-1, 3, n-2, ...]</code></p>
<p>而当 k = 1 时，数组按照自然顺序递增排列。</p>
<p><code>[1, 2, 3, ..., n]</code></p>
<p>了解到这两个规律之后，我们可以将其结合：</p>
<ul>
<li>将 n-k-1 的部分的数按照 k = 1 时的规律处理；</li>
<li>而剩下的 k + 1 个元素单独视作一个数组，采取 k = n - 1 时的处理。</li>
</ul>
<p>这样就可以将处理划分为两类，用最简单的方法来构建这个数组。</p>
<ul>
<li>首先构建 <code>[1, 2, ..., n-k-1]</code> 数组</li>
<li>从 n-k 开始的数根据 index 的奇偶性来取值<ul>
<li>当 index 为偶数时从头部取值，这时值为 n-k + i//2</li>
<li>当 index 为奇数时从尾部取值，这时值为 n - i//2</li>
</ul>
</li>
</ul>
<p>参考代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArray</span>(<span class="params">self, n, k</span>):</span></span><br><span class="line">        ans = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, n - k))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                ans.append(n-k + i//<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(n - i//<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>从代码上来看，先取 k = 1 的排序，再取 k = n - 1 的排序确实让代码逻辑更加简洁和易懂；</li>
<li>从结果上来看，这段代码在空间复杂度上有改善（beats 82.76%），但是时间复杂度上有上升（beats 86.21%）。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>695. Max Area of Island (Medium)</title>
    <url>/post/leetcode/695-Max-Area-of-Island-Medium/</url>
    <content><![CDATA[<p>给定一个尺寸为 <code>m x n</code> 的二进制值的矩阵。定义元素的值为 <code>1</code> 表示土地，元素值为 <code>0</code> 表示海水。</p>
<p>陆地由四边邻接的土地组合而成，陆地的面积是接邻的土地的数量。</p>
<p>求矩阵中的陆地的最大面积，如果不存在陆地则返回 0。</p>
<span id="more"></span>

<h2 id="思路-1，递归"><a href="#思路-1，递归" class="headerlink" title="思路 1，递归"></a>思路 1，递归</h2><p>使用 DFS 搜索所有陆地（1），将搜索过的元素标注为 1 以外的数，避免重复计算，每次搜索到一个目标，保持一个最大结果作为答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m, n, ans = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">x, y</span>):</span></span><br><span class="line">            <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x == m <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y == n <span class="keyword">or</span> grid[x][y] != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            grid[x][y]  = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + search(x, y - <span class="number">1</span>) + search(x, y + <span class="number">1</span>) + search(x + <span class="number">1</span>, y) + search(x - <span class="number">1</span>, y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, search(i, j))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，栈"><a href="#思路-2，栈" class="headerlink" title="思路 2，栈"></a>思路 2，栈</h2><p>用一个 set <code>seen</code> 储存遇到过的格子，避免重复计算。每当遇到陆地，新建一个栈，遍历这个栈，取出栈顶的格子，将其上下左右四个方向存在陆地的格子放到栈顶，重复这个过程直到栈清空，维持一个计数最大值作为答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m, n, ans, seen = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>]), <span class="number">0</span>, <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] != <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                count, stack = <span class="number">0</span>, [(i, j)]</span><br><span class="line">                <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># print(stack)</span></span><br><span class="line">                    x, y = stack.pop()</span><br><span class="line">                    seen.add((x, y))</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">for</span> _x, _y <span class="keyword">in</span> ((x-<span class="number">1</span>, y), (x+<span class="number">1</span>, y), (x, y-<span class="number">1</span>), (x, y+<span class="number">1</span>)):</span><br><span class="line">                        <span class="keyword">if</span> _x &gt;= <span class="number">0</span> <span class="keyword">and</span> _x &lt; m <span class="keyword">and</span> _y &gt;= <span class="number">0</span> <span class="keyword">and</span> _y &lt; n <span class="keyword">and</span> (_x, _y) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                            <span class="keyword">if</span> grid[_x][_y] == <span class="number">1</span>:</span><br><span class="line">                                stack.append((_x, _y))</span><br><span class="line">                                seen.add((_x, _y))</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, count)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Matrix</tag>
        <tag>Union Fold</tag>
      </tags>
  </entry>
  <entry>
    <title>709. To Lower Case (Easy)</title>
    <url>/post/leetcode/709-To-Lower-Case-Easy/</url>
    <content><![CDATA[<p>字符串问题。将给定的字符串中的大写字母转换为小写字母并返回。</p>
<p>很简单的一道题目，考察点在于实现的思路。通过 ASCII 码可以简单的解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>只要记得大写字母 <code>A-Z</code> 的 ASCII 码区间是 <code>65-90</code>，大写字母和小写字母的差值是 32，这道题就很好解决。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toLowerCase</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            _c = <span class="built_in">ord</span>(c)</span><br><span class="line">            <span class="keyword">if</span> _c &gt;= <span class="number">65</span> <span class="keyword">and</span> _c &lt;= <span class="number">90</span>:</span><br><span class="line">                ans += <span class="built_in">chr</span>(_c + <span class="number">32</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += c</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ans = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[i] &gt;= <span class="number">65</span> &amp;&amp; ans[i] &lt;= <span class="number">90</span>) &#123;</span><br><span class="line">                ans[i] += <span class="number">32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>745. Prefix and Suffix Search (Hard)</title>
    <url>/post/leetcode/745-Prefix-and-Suffix-Search-Hard/</url>
    <content><![CDATA[<p>字典树题目。实现一个字典根据指定的前缀和后缀来定位单词，如果存在多个单词则返回最大的下标位置，如果不存在单词则返回 -1。</p>
<p>测试 case 中单词最大数量为 15000，查询次数最大为 15000，查询性能不够的话会遇到超时问题。</p>
<p>字符串索引问题是字典树（Trie）的应用场景，我们用字典树来解决这道题。</p>
<span id="more"></span>

<h2 id="思路，然而并没有用-Trie"><a href="#思路，然而并没有用-Trie" class="headerlink" title="思路，然而并没有用 Trie"></a>思路，然而并没有用 Trie</h2><p>用 Hash Table + Memoization 方法。</p>
<p>根据后缀长度，将每个单词截取后缀长度的 substring，加上 <code>#</code> 拼上原字符作为一个索引列表。</p>
<p>比如后缀长度为 3 时，将 <code>abcdefg</code> 处理为 <code>efg#abcdefg</code> 储存到长度为 3 的索引。</p>
<p>这样我们可以将给定的后缀拼上 <code>#</code> 再拼上前缀，使用字符串的 <code>startsWith</code> 方法进行匹配。</p>
<p>出于效率考虑我们将每次计算的结果储存到 <code>memo</code> 中，方便遇到相同的查询直接返回结果。</p>
<blockquote>
<p>这一步是避免算法超时的关键，实际上换一个不存在重复数据的测试集就会超时。</p>
<p>这道题考察的是 Trie 的应用。应用字典树的情况下测试集不会对结果有太大影响。</p>
<p>字典树构建流程并不复杂，但是细节处理需要小心注意，TODO</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String[]&gt; index = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> String[] reversed;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordFilter</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.len = words.length;</span><br><span class="line">        Collections.reverse(Arrays.asList(words));</span><br><span class="line">        <span class="keyword">this</span>.reversed = words;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(String prefix, String suffix)</span> </span>&#123;</span><br><span class="line">        String query = suffix + <span class="string">&quot;#&quot;</span> + prefix;</span><br><span class="line">        Integer ans = memo.get(query);</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memo.put(query, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> l = suffix.length();</span><br><span class="line"></span><br><span class="line">        String[] arr = index.get(l);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            arr = <span class="keyword">new</span> String[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                String w = reversed[i];</span><br><span class="line">                arr[i] = w.substring(w.length() - l) + <span class="string">&quot;#&quot;</span> + w;</span><br><span class="line">                <span class="comment">// System.out.println(arr[i]);</span></span><br><span class="line">            &#125;</span><br><span class="line">            index.put(l, arr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i].startsWith(query)) &#123;</span><br><span class="line">                ans = len - <span class="number">1</span> - i;</span><br><span class="line">                memo.put(query, ans);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordFilter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordFilter obj = new WordFilter(words);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.f(prefix,suffix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>746. Min Cost Climbing Stairs (Easy)</title>
    <url>/post/leetcode/746-Min-Cost-Climbing-Stairs-Easy/</url>
    <content><![CDATA[<p>爬楼梯游戏。你在爬一段楼梯，你会得到一个 <code>cost</code> 数组记录爬到每一级台阶的消耗。</p>
<p>一旦你付出当前台阶的消耗，你可以选择往上爬一级或两级台阶。另外，你可以选择从第一级台阶或第二级台阶开始游戏。</p>
<p>求爬到顶部的最小消耗。这是一道 DP 应用的简单题目。</p>
<span id="more"></span>

<h2 id="思路-1，DP"><a href="#思路-1，DP" class="headerlink" title="思路 1，DP"></a>思路 1，DP</h2><p>仔细观察能发现每一步的 <code>cost</code> 都取前两步 <code>cost</code> 的最小值，那么我们可以准备一个数组来存计算过的最小 <code>cost</code>。</p>
<p>话虽如此，这道题叙述有些模糊，经过尝试可以明确以下信息：</p>
<ul>
<li>下标 0 和 1 的 <code>cost</code> 都为 0，因为第一步最大可以走到下标 1 的位置，而第一步是没有 <code>cost</code> 的；</li>
<li>最后一步要超过最后一个元素，下标要达到数组长度。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(cost)</span><br><span class="line">        mincost = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 0，1 的 cost 都为 0，我们直接从 2 开始遍历，到 n （包含）结束。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 每一步 i 的 cost 都为前一步的值加上到达前一步的最小值。</span></span><br><span class="line">            <span class="comment"># 其中前一步可以选择 i - 1 和 i - 2。</span></span><br><span class="line">            mincost[i] = <span class="built_in">min</span>(</span><br><span class="line">                mincost[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>],</span><br><span class="line">                mincost[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> mincost[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，优化-DP"><a href="#思路-2，优化-DP" class="headerlink" title="思路 2，优化 DP"></a>思路 2，优化 DP</h2><p>仔细一看发现我们每次只看 2 个值，那么可以优化 O(n) 空间复杂度到 O(1)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        st1 = st2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(cost) + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 按照从左到右的顺序依次是 st2、st1、st0，每一个迭代我们丢弃 st2 的值，</span></span><br><span class="line">            <span class="comment"># 将 st1、st0 作为下一次迭代的 st2、st1。</span></span><br><span class="line">            st0 = <span class="built_in">min</span>(st1 + cost[i - <span class="number">1</span>], st2 + cost[i - <span class="number">2</span>])</span><br><span class="line">            st1, st2 = st0, st1</span><br><span class="line">        <span class="keyword">return</span> st1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>752. Open the Lock (Medium)</title>
    <url>/post/leetcode/752-Open-the-Lock-Medium/</url>
    <content><![CDATA[<p>开锁游戏。你有一个圆盘锁，锁有 4 个转轮，每个转轮上有 0 ～ 9 共十个数字。</p>
<p>你可以自由转动每个转轮，每次转动一个转轮后它的值会 +1 或 -1，当你从 0 开始转动 -1 后为 9，反之亦然。</p>
<p>你会得到一个死锁列表 <code>deadends</code>，表示当你转动圆盘锁到这个值的时候游戏结束。你还会得到目标值 <code>target</code>，你需要在避免遇到死锁的情况下解开圆盘锁，返回操作圆盘锁的最少步骤数，或者返回 -1 表示在已知条件下无法解锁。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>换个角度我们需要求出一个 10000 个节点的图中从 <code>0000</code> 出发到目标节点的最短路径，并且要避开给定的死路。总结一下已知的情报。</p>
<ul>
<li>每个转轮每次操作可以 +1 or -1；</li>
<li>当前状态的下一步操作有 4 * 2 = 8 中选择；</li>
<li>要求最少步数，需要穷尽每一步的所有选择 -&gt; 确定 BFS 应用场景；</li>
<li>为避免重复搜索，准备一个 <code>seen</code> 数组进行剪枝；<ul>
<li>已知圆盘锁的值都为数字且不重复，<code>seen</code> 数组可以初始化为长度为 10000 的布尔值 or 0/1 数组；</li>
<li><code>deadends</code> 可以视作已经处理过的组合，可以将其对应的 <code>seen</code> 数组的元素设为 true；</li>
</ul>
</li>
<li>为了方面计算，先将不好处理的特殊场景排除在外，这题有 2 个特殊场景：<ul>
<li>当目标等于初始值时，直接返回 0；</li>
<li>当初始值被标记为死路时，直接返回 -1；</li>
</ul>
</li>
<li>开始实现算法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">openLock</span>(<span class="params">self, deadends: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="string">&#x27;0000&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        depth, queue, seen, target = <span class="number">0</span>, [<span class="number">0</span>], [<span class="number">0</span>] * <span class="number">10000</span>, <span class="built_in">int</span>(target)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> deadends:</span><br><span class="line">            seen[<span class="built_in">int</span>(d)] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> seen[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            n, depth = <span class="built_in">len</span>(queue), depth + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                first = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                    base = first // <span class="number">10</span> ** k % <span class="number">10</span></span><br><span class="line">                    <span class="keyword">for</span> d <span class="keyword">in</span> (-<span class="number">1</span>, <span class="number">1</span>):</span><br><span class="line">                        <span class="comment"># first - base * 10 ** k -&gt; get the base number with target digit reset to 0.</span></span><br><span class="line">                        <span class="comment"># ~ + (base + d) % 10 * 10 ** k -&gt; add back the caculated target digit.</span></span><br><span class="line">                        nxt = first - base * <span class="number">10</span> ** k + (base + d) % <span class="number">10</span> * <span class="number">10</span> ** k</span><br><span class="line">                        <span class="keyword">if</span> nxt == target:</span><br><span class="line">                            <span class="keyword">return</span> depth</span><br><span class="line">                        <span class="keyword">if</span> seen[<span class="built_in">int</span>(nxt)]:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        seen[<span class="built_in">int</span>(nxt)] = <span class="number">1</span></span><br><span class="line">                        queue.append(nxt)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>BFS</tag>
        <tag>String</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>77. Combinations (Medium)</title>
    <url>/post/leetcode/77-Combinations-Medium/</url>
    <content><![CDATA[<p>组合问题。给定两个整数 <code>n</code> 和 <code>k</code>，返回从 <code>1 ~ n</code> 中选取 <code>k</code> 个数能构成的所有组合。</p>
<p>典型的回溯算法应用题，需要注意去重的思路。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>需要编辑的数组长度 <code>k</code> 是一个变量，看来这道题是一道典型的回溯算法题。</p>
<p>我们从 <code>1</code> 开始尝试往目标数组中放入包含 <code>1</code> 到包含 <code>n</code> 之间的值。</p>
<p>下一轮中我们尝试放入包含 <code>2</code> 到包含 <code>n</code> 之间的值。重复这个过程。</p>
<p>组合不在乎元素的排序，所以也许你会觉得算法会重复取值，这里的处理重点在于下一个值永远是大于上一个值的，所以我们没有必要考虑组合重复。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">pos, res</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) == k:</span><br><span class="line">                ans.append(res)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos, n + <span class="number">1</span>):</span><br><span class="line">                search(i + <span class="number">1</span>, res + [i])</span><br><span class="line">        search(<span class="number">1</span>, [])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>778. Swim in Rising Water (Hard)</title>
    <url>/post/leetcode/778-Swim-in-Rising-Water-Hard/</url>
    <content><![CDATA[<p>这是一道求最合适路径的题目，根据提示可以应用图论中的 Dijkstra 算法。</p>
<blockquote>
<p>Dijkstra‘s Algorithm 适用于求<strong>权重不为负数的加权图</strong>起点到终点的最优路径。</p>
</blockquote>
<p>这道题的 input 是一个 <code>n * n</code> 的矩阵，可以将其视作所有元素都与其上下左右相互连接的一张无向图，每个顶点的数值表示到达这个顶点的边的权重，我们需要求的是从起点 <code>(0, 0)</code> 到终点 <code>(n, n)</code> 的最优路径。这道题要求我们计算的是这条路径上权重最大值，所以我们用一个变量来保持每一次选择后的权重最大值。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>下面是算法：</p>
<ul>
<li>从 <code>(0, 0)</code> 开始，将四个方向能访问的顶点加权后放入小根堆：<ul>
<li>根据题目的限制，<code>n &lt;= 50</code>，所以我们留出 2 进制 6 位（<code>2^6=64</code>）便足够放下下标的长度来；</li>
<li>加权后的值 = <code>(grid[x][y] &lt;&lt; 12) + (x &lt;&lt; 6) + y</code>;</li>
</ul>
</li>
<li>选择小根堆中的最小值继续往下走：<ul>
<li>现在我们选了一个新的值，用其和全局最大值再取一次最大值，更新全局变量；</li>
<li>从加权后的值中恢复这个值的 <code>x, y</code> 下标；</li>
</ul>
</li>
<li>重复这个过程直到终点 <code>(n, n)</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">moves = ((-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">mask = (<span class="number">1</span> &lt;&lt; <span class="number">6</span>) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swimInWater</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n, ans, i, j, q = <span class="built_in">len</span>(grid) - <span class="number">1</span>, grid[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>, []</span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">or</span> j &lt; n:</span><br><span class="line">            <span class="keyword">for</span> a, b <span class="keyword">in</span> moves:</span><br><span class="line">                _i, _j = i + a, j + b</span><br><span class="line">                <span class="keyword">if</span> _i &lt; <span class="number">0</span> <span class="keyword">or</span> _i &gt; n <span class="keyword">or</span> _j &lt; <span class="number">0</span> <span class="keyword">or</span> _j &gt; n <span class="keyword">or</span> grid[_i][_j] == math.inf:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                heapq.heappush(q, (grid[_i][_j] &lt;&lt; <span class="number">12</span>) + (_i &lt;&lt; <span class="number">6</span>) + _j)</span><br><span class="line">                grid[_i][_j] = math.inf</span><br><span class="line">            nxt = heapq.heappop(q)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, nxt &gt;&gt; <span class="number">12</span>)</span><br><span class="line">            i, j = (nxt &gt;&gt; <span class="number">6</span>) &amp; mask, nxt &amp; mask</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>Java 版用 PriorityQueue 实现小根堆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] moves = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; <span class="number">6</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n = grid.length - <span class="number">1</span>;</span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i != n || j != n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] m : moves) &#123;</span><br><span class="line">                <span class="keyword">int</span> mi = i + m[<span class="number">0</span>], mj = j + m[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (mi &lt; <span class="number">0</span> || mi &gt; n || mj &lt; <span class="number">0</span> || mj &gt; n</span><br><span class="line">                    || grid[mi][mj] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pq.add((grid[mi][mj] &lt;&lt; <span class="number">12</span>) + (mi &lt;&lt; <span class="number">6</span>) + mj);</span><br><span class="line">                grid[mi][mj] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> next = pq.poll();</span><br><span class="line">            ans = Math.max(ans, next &gt;&gt; <span class="number">12</span>);</span><br><span class="line">            i = (next &gt;&gt; <span class="number">6</span>) &amp; mask;</span><br><span class="line">            j = next &amp; mask;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Matrix</tag>
        <tag>Heap (Priority Queue)</tag>
        <tag>Union Fold</tag>
      </tags>
  </entry>
  <entry>
    <title>792. Number of Matching Subsequences (Medium)</title>
    <url>/post/leetcode/792-Number-of-Matching-Subsequences-Medium/</url>
    <content><![CDATA[<p>字符串问题。找出匹配子序列（Subsequences）的数量。</p>
<p>子序列（Subsequences）的定义：一个字符串中删除某些字符（也可以不删除字符）之后，字符出现的相对顺序没有被改变，则这个新的字符串称之为原字符串的子序列。</p>
<blockquote>
<p>For example, “ace” is a subsequence of “abcde”.</p>
</blockquote>
<p>我们用暴力法和桶来解决这道题。</p>
<span id="more"></span>

<h2 id="无脑思路…"><a href="#无脑思路…" class="headerlink" title="无脑思路…"></a>无脑思路…</h2><p>这道题定义的子序列不需要是连续的字符串，只需要字符按照原本的先后顺序排列即可，所以遗憾 <code>for in</code> 不能派上用场（废话）。</p>
<p>但这也难不倒无脑的我，定义在于先后顺序，那么我们每一次仅搜索从上一次找到的下标往后是不是存在下一个字符，如果找到下一个字符，这个下标保存继续循环，最后判断找到的字符数量是不是和愿字符串长度一致。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMatchingSubseq</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            curr, cnt = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> w:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    curr = curr + s[curr:].index(c) + <span class="number">1</span></span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="built_in">len</span>(w):</span><br><span class="line">                ans +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="正常思路，桶"><a href="#正常思路，桶" class="headerlink" title="正常思路，桶"></a>正常思路，桶</h2><p>评论区的一个思路，作者命名为 “Next Letter Pointer” 方法。</p>
<p>我们将每个检查对象按照首字母放到对应的桶中，通过下面的方法实现仅遍历一次目标字符串就检查完所有目标的算法。</p>
<p>作者还做了一张图来可视化这个过程。算法思路如下。</p>
<ul>
<li>准备好桶后，开始遍历目标字符串：<ul>
<li>用当前位置的字符取出对应的桶保留，就桶原本的位置重置为空桶；</li>
<li>遍历取出的桶：<ul>
<li>如果字符长度为 1：说明找到了一个答案，计数器+1；</li>
<li>否则：将字符串去头（第一个字符）后，按照首字母继续放入对应的桶中，等待后面有机会取出来；</li>
</ul>
</li>
<li>重复这个过程直到目标字符串遍历结束。</li>
</ul>
</li>
</ul>
<p><img src="/images/leetcode/792.bucket.png" alt="bucket"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMatchingSubseq</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, bucket = <span class="number">0</span>, defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            bucket[w[<span class="number">0</span>]].append(w)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            target, bucket[c] = bucket[c], []</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> target:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(w) == <span class="number">1</span>:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                bucket[w[<span class="number">1</span>]].append(w[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>Java 版本，好长长长…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String w;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> p;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String w, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">            <span class="keyword">this</span>.p = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numMatchingSubseq</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Node&gt;[] bucket = <span class="keyword">new</span> ArrayList[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            bucket[i] = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            bucket[word.charAt(<span class="number">0</span>) - <span class="number">97</span>].add(<span class="keyword">new</span> Node(word, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            List&lt;Node&gt; target = bucket[c - <span class="number">97</span>];</span><br><span class="line">            bucket[c - <span class="number">97</span>] = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Node n : target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n.p + <span class="number">1</span> == n.w.length()) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    n.p ++;</span><br><span class="line">                    bucket[n.w.charAt(n.p) - <span class="number">97</span>].add(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Hash Table</tag>
        <tag>Sorting</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>816. Ambiguous Coordinates (Medium)</title>
    <url>/post/leetcode/816-Ambiguous-Coordinates-Medium/</url>
    <content><![CDATA[<p>模棱两可的平面坐标。你需要从一个删除了逗号、空格和小数点的平面坐标中还原它的所有可能的坐标值。</p>
<blockquote>
<p>For example, “(1, 3)” becomes s = “(13)” and “(2, 0.5)” becomes s = “(205)”.</p>
</blockquote>
<p>结果坐标值不会有多余的前置 0，并且小数点后的数字不会以 0 结尾。还原后的坐标的两个值应该用逗号和一个空格隔开。</p>
<p>我们讨论用正则和回溯算法来解决这道题。</p>
<span id="more"></span>

<h2 id="思路-1，正则"><a href="#思路-1，正则" class="headerlink" title="思路 1，正则"></a>思路 1，正则</h2><p>偷懒用正则检查字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ambiguousCoordinates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isvalid</span>(<span class="params">s</span>):</span></span><br><span class="line">            ptn = <span class="string">r&quot;^(([1-9]+\d*|0)\.\d*[1-9]|([1-9]+\d*|0))$&quot;</span></span><br><span class="line">            <span class="keyword">return</span> re.match(ptn, s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">makenumberstr</span>(<span class="params">s</span>):</span></span><br><span class="line">            ret = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                _s = s</span><br><span class="line">                <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                    _s = s[:i + <span class="number">1</span>] + <span class="string">&#x27;.&#x27;</span> + s[i + <span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> isvalid(_s):</span><br><span class="line">                    ret.append(_s)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        s = s[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line"></span><br><span class="line">            n = makenumberstr(s[:i])</span><br><span class="line">            m = makenumberstr(s[i:])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _n <span class="keyword">in</span> n:</span><br><span class="line">                <span class="keyword">for</span> _m <span class="keyword">in</span> m:</span><br><span class="line">                    ans.append(<span class="string">f&quot;(<span class="subst">&#123;_n&#125;</span>, <span class="subst">&#123;_m&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，回溯算法"><a href="#思路-2，回溯算法" class="headerlink" title="思路 2，回溯算法"></a>思路 2，回溯算法</h2><p>老老实实拼正确的字符串，跳过检查。其实正确字符串规则只有 2 个，无论对整数还是浮点数来说，整数部分只能是 0 或 0 以上，所以判断这部分只要判断是否有前缀 0，以及是否为 0。</p>
<ul>
<li>浮点数：<ul>
<li>左边只能是 0 或大于 0 的数；</li>
<li>右边末位不能是 0。</li>
</ul>
</li>
<li>整数：<ul>
<li>只能是 0 或大于 0 的数。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ambiguousCoordinates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">makenumberstr</span>(<span class="params">s</span>):</span></span><br><span class="line">            ret = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s) + <span class="number">1</span>):</span><br><span class="line">                left, right = s[:i], s[i:]</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">not</span> left.startswith(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> left == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">and</span> <span class="keyword">not</span> right.endswith(<span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">                    ret.append(left + (<span class="string">&#x27;.&#x27;</span> <span class="keyword">if</span> right != <span class="string">&#x27;&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>) + right)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        s, ans = s[<span class="number">1</span>:-<span class="number">1</span>], []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line"></span><br><span class="line">            n = makenumberstr(s[:i])</span><br><span class="line">            m = makenumberstr(s[i:])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _n <span class="keyword">in</span> n:</span><br><span class="line">                <span class="keyword">for</span> _m <span class="keyword">in</span> m:</span><br><span class="line">                    ans.append(<span class="string">f&quot;(<span class="subst">&#123;_n&#125;</span>, <span class="subst">&#123;_m&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>86. Partition List (Medium)</title>
    <url>/post/leetcode/86-Partition-List-Medium/</url>
    <content><![CDATA[<p>链表问题。链表分区，给你一个链表和整数 <code>x</code>，你需要在保证相对顺序的情况下，将小于 <code>x</code> 的值排在链表前面，大于等于 <code>x</code> 的值排在后面。</p>
<blockquote>
<p>Given the <code>head</code> of a linked list and a value <code>x</code>, partition it such that all nodes less than <code>x</code> come before nodes greater than or equal to <code>x</code>.</p>
<p>You should <strong>preserve</strong> the original relative order of the nodes in each of the two partitions.</p>
</blockquote>
<span id="more"></span>

<p>With solutions both in Python and Java.</p>
<p>已知参数为一个 linked list 和 x，需要将数组根据 x 的值分区，小于它的放在前面，大于等于它的放在后面，并且分区后要保证原有顺序不变。</p>
<p>从下面例子可以看出来，我们可以把数组拆成一个前一个后，保持元素相对顺序，然后拼接起来。</p>
<p>Example 1:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Input: head = [1,4,3,2,5,2], x = 3</span><br><span class="line">Output: [1,2,2,4,3,5]</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Input: head = [2,1], x = 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>

<h2 id="Submissions"><a href="#Submissions" class="headerlink" title="Submissions"></a>Submissions</h2><p>我的代码时间复杂度还能看，空间复杂度已经脱离排名，没法看了。</p>
<p>虽然解题思路和官方一样，但是处理上有些愚蠢，这题就不贴我的结果了。</p>
<h2 id="思路-amp-Solutions"><a href="#思路-amp-Solutions" class="headerlink" title="思路 &amp; Solutions"></a>思路 &amp; Solutions</h2><p>思路很简单，这道题主要考察的是对空间复杂度对处理。逻辑的流程如下。</p>
<ul>
<li>准备一个 before 列表存储值小于 x 的元素</li>
<li>准备一个 after 列表存储值不小于 x 的元素</li>
<li>将两个列表连接起来作为结果</li>
</ul>
<p>逻辑很简单，但是 linked list 的接口如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">         self.val = val</span><br><span class="line">         self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>程序拿到的参数是这个 linked list 的第一个元素，这是一个逻辑上的列表，我们只能向下遍历，无法从下节点反推出上一个节点的值。</p>
<p>要准备 before 和 after 列表我们首先要知道从哪里开始，以及如何开始。</p>
<ul>
<li>我们可以不初始化 before 和 after，等到遇到合适的值的时候再去给其赋值；</li>
<li>也可以初始化为当前的节点，再根据与 x 比较的结果来调整赋值；这两个思路我都尝试了。</li>
<li>官解的处理是，将 before 和 after 初始化为两个伪节点，规避了初始化问题（是我没想到的思路）。</li>
</ul>
<p>看一下 Python 代码理解一下这个处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, head: ListNode, x: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        bef = bf_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        aft = af_head = ListNode(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">                bef.<span class="built_in">next</span> = head</span><br><span class="line">                bef = head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                aft.<span class="built_in">next</span> = head</span><br><span class="line">                aft = head</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        aft.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        bef.<span class="built_in">next</span> = af_head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bf_head.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Java 代码逻辑一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode before = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode after = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode bfHead = before;</span><br><span class="line">        ListNode afHead = after;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &lt; x) &#123;</span><br><span class="line">                before.next = head;</span><br><span class="line">                before = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                after.next = head;</span><br><span class="line">                after = head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        after.next = <span class="keyword">null</span>;</span><br><span class="line">        before.next = afHead.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bfHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>进行伪初始化的处理很好的规避了初始化判断，对遍历的处理也只是改变了列表的排序，两者使得程序在时间和空间复杂度上有很好的表现。</p>
<ul>
<li>时间复杂度：O(n)，做了一次遍历；</li>
<li>空间复杂度：O(1)，只做了列表重组，没使用额外空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Two Pointers</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>890. Find and Replace Pattern (Medium)</title>
    <url>/post/leetcode/890-Find-and-Replace-Pattern-Medium/</url>
    <content><![CDATA[<p>给定一组字符串和一个模式（pattern），返回字符串中所有匹配这个模式的对象。</p>
<p>这里的模式（pattern）描述字母如何重复，即如果模式匹配，那么将模式中的字母替换成映射的字母，就可以还原成目标字符串。</p>
<p>使用字符串映射，或者码表来解决这道题。</p>
<span id="more"></span>

<h2 id="思路-1，先计算-pattern-的排列码表"><a href="#思路-1，先计算-pattern-的排列码表" class="headerlink" title="思路 1，先计算 pattern 的排列码表"></a>思路 1，先计算 <code>pattern</code> 的排列码表</h2><p>使用这个码表来过滤输入数据。简单来说，我们这样做。</p>
<ul>
<li>计算 <code>pattern</code> 的排列码表<ul>
<li>用一个计数器将 <code>pattern</code> 中的字符按出现顺序编码；</li>
<li>相同字符的编码保持不变，比如 <code>abba</code> 转化为排列码表为 <code>[0, 1, 1, 0]</code>。</li>
</ul>
</li>
<li>对输入数据中每一个字符串进行检查<ul>
<li>用一个计数器将目标中的字符按出现顺序编码；</li>
<li>相同字符的编码保持不变；</li>
<li>计算完每一个字符的编码后，与排列码表相同下标的元素进行比对，结果不一致时直接返回 <code>false</code>；</li>
<li>顺利匹配完成时，返回 <code>true</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAndReplacePattern</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], pattern: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        ptn, tbl, c = [], &#123;&#125;, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> pattern:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> tbl:</span><br><span class="line">                tbl[i] = c</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">            ptn.append(tbl[i])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">match</span>(<span class="params">w</span>):</span></span><br><span class="line">            tbl.clear()</span><br><span class="line">            c = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w)):</span><br><span class="line">                <span class="keyword">if</span> w[i] <span class="keyword">not</span> <span class="keyword">in</span> tbl:</span><br><span class="line">                    tbl[w[i]] = c</span><br><span class="line">                    c += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> tbl[w[i]] != ptn[i]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(ptn)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">filter</span>(match, words)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，双射（bijection）"><a href="#思路-2，双射（bijection）" class="headerlink" title="思路 2，双射（bijection）"></a>思路 2，双射（bijection）</h2><p>用两个哈希表分别映射 <code>pattern</code> 字符和目标字符，检查映射结果是否一致。</p>
<ul>
<li>用 <code>m1</code> 储存目标字符到 <code>pattern</code> 字符的映射，比如字符 <code>x</code> -&gt; <code>a</code>;</li>
<li>用 <code>m2</code> 储存 <code>pattern</code> 字符到目标字符的映射，比如字符 <code>a</code> -&gt; <code>x</code>；</li>
<li>作为判断条件，当下面条件任意一个满足，则表示目标字符与 <code>pattern</code> 不匹配：<ul>
<li><code>m1</code> 中字符 <code>x</code> 对应的字符与当前 <code>pattern</code> 相对下标的字符不匹配；或，</li>
<li><code>m2</code> 中字符 <code>a</code> 对应的字符与当前目标字符串相对下标的字符不匹配。</li>
</ul>
</li>
<li>如果到最后一个字符依然匹配，则目标字符匹配 <code>pattern</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, Character&gt; m1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, Character&gt; m2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findAndReplacePattern</span><span class="params">(String[] words, String pattern)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String w : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (match(w, pattern)) ans.add(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String w, String ptn)</span> </span>&#123;</span><br><span class="line">        m1.clear(); m2.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = w.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> p = ptn.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!m1.containsKey(c)) m1.put(c, p);</span><br><span class="line">            <span class="keyword">if</span> (!m2.containsKey(p)) m2.put(p, c);</span><br><span class="line">            <span class="keyword">if</span> (m1.get(c) != p || m2.get(p) != c) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，单哈希表"><a href="#思路-3，单哈希表" class="headerlink" title="思路 3，单哈希表"></a>思路 3，单哈希表</h2><p>在双射的思路里我们用到了 2 个哈希表，这里还有优化的空间，我们考虑一下只使用一个哈希表时需要处理的问题。</p>
<ul>
<li>首先按照思路 2 准备好哈希表，这次我们仅作目标字符到 <code>pattern</code> 字符的映射；</li>
<li>第一个错误条件是目标字符在哈希表中对应的 <code>pattern</code> 字符和当前不匹配：<ul>
<li>如果目标字符重复之前出现过的字符，而 <code>pattern</code> 字符是未出现过的，则哈希表中对应字符和当前 <code>pattern</code> 字符必定不匹配。</li>
</ul>
</li>
<li>第二个错误条件是目标字符都不重复时，会将多个不同字符映射到 <code>pattern</code> 的同一个字符：<ul>
<li>这时哈希表会顺利完成，我们需要对哈希表的值集合进行进一步的检查，如果出现重复字符则返回 <code>false</code>。</li>
</ul>
</li>
<li>最终顺利完成检查的返回 <code>true</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, Character&gt; m1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findAndReplacePattern</span><span class="params">(String[] words, String pattern)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String w : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (match(w, pattern)) ans.add(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String w, String ptn)</span> </span>&#123;</span><br><span class="line">        m1.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = w.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> p = ptn.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!m1.containsKey(c)) m1.put(c, p);</span><br><span class="line">            <span class="keyword">if</span> (m1.get(c) != p) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] test = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> v : m1.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (test[v - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                test[v - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">words</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">pattern</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findAndReplacePattern = <span class="function"><span class="keyword">function</span> (<span class="params">words, pattern</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> words.filter(<span class="function">(<span class="params">w</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; w.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> c = w.charAt(i),</span><br><span class="line">        p = pattern.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (!map[c]) map[c] = p;</span><br><span class="line">      <span class="keyword">if</span> (p !== map[c]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> test = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="built_in">Object</span>.values(map)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (test.indexOf(v) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        test.push(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>906. Super Palindromes (Hard)</title>
    <url>/post/leetcode/906-Super-Palindromes-Hard/</url>
    <content><![CDATA[<p>嗯…暂且打表吧…</p>
<span id="more"></span>

<h2 id="思路，打表"><a href="#思路，打表" class="headerlink" title="思路，打表"></a>思路，打表</h2><p>Don’t know the reason but not interested in this problem, so let’s calculate a table to break it.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superpalindromesInRange</span>(<span class="params">self, left: <span class="built_in">str</span>, right: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        L, R = <span class="built_in">int</span>(left), <span class="built_in">int</span>(right)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.table:</span><br><span class="line">            <span class="keyword">if</span> i &lt; L:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> i &lt;= R:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    table = [</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">4</span>,</span><br><span class="line">        <span class="number">9</span>,</span><br><span class="line">        <span class="number">121</span>,</span><br><span class="line">        <span class="number">484</span>,</span><br><span class="line">        <span class="number">10201</span>,</span><br><span class="line">        <span class="number">12321</span>,</span><br><span class="line">        <span class="number">14641</span>,</span><br><span class="line">        <span class="number">40804</span>,</span><br><span class="line">        <span class="number">44944</span>,</span><br><span class="line">        <span class="number">1002001</span>,</span><br><span class="line">        <span class="number">1234321</span>,</span><br><span class="line">        <span class="number">4008004</span>,</span><br><span class="line">        <span class="number">100020001</span>,</span><br><span class="line">        <span class="number">102030201</span>,</span><br><span class="line">        <span class="number">104060401</span>,</span><br><span class="line">        <span class="number">121242121</span>,</span><br><span class="line">        <span class="number">123454321</span>,</span><br><span class="line">        <span class="number">125686521</span>,</span><br><span class="line">        <span class="number">400080004</span>,</span><br><span class="line">        <span class="number">404090404</span>,</span><br><span class="line">        <span class="number">10000200001</span>,</span><br><span class="line">        <span class="number">10221412201</span>,</span><br><span class="line">        <span class="number">12102420121</span>,</span><br><span class="line">        <span class="number">12345654321</span>,</span><br><span class="line">        <span class="number">40000800004</span>,</span><br><span class="line">        <span class="number">1000002000001</span>,</span><br><span class="line">        <span class="number">1002003002001</span>,</span><br><span class="line">        <span class="number">1004006004001</span>,</span><br><span class="line">        <span class="number">1020304030201</span>,</span><br><span class="line">        <span class="number">1022325232201</span>,</span><br><span class="line">        <span class="number">1024348434201</span>,</span><br><span class="line">        <span class="number">1210024200121</span>,</span><br><span class="line">        <span class="number">1212225222121</span>,</span><br><span class="line">        <span class="number">1214428244121</span>,</span><br><span class="line">        <span class="number">1232346432321</span>,</span><br><span class="line">        <span class="number">1234567654321</span>,</span><br><span class="line">        <span class="number">4000008000004</span>,</span><br><span class="line">        <span class="number">4004009004004</span>,</span><br><span class="line">        <span class="number">100000020000001</span>,</span><br><span class="line">        <span class="number">100220141022001</span>,</span><br><span class="line">        <span class="number">102012040210201</span>,</span><br><span class="line">        <span class="number">102234363432201</span>,</span><br><span class="line">        <span class="number">121000242000121</span>,</span><br><span class="line">        <span class="number">121242363242121</span>,</span><br><span class="line">        <span class="number">123212464212321</span>,</span><br><span class="line">        <span class="number">123456787654321</span>,</span><br><span class="line">        <span class="number">400000080000004</span>,</span><br><span class="line">        <span class="number">10000000200000001</span>,</span><br><span class="line">        <span class="number">10002000300020001</span>,</span><br><span class="line">        <span class="number">10004000600040001</span>,</span><br><span class="line">        <span class="number">10020210401202001</span>,</span><br><span class="line">        <span class="number">10022212521222001</span>,</span><br><span class="line">        <span class="number">10024214841242001</span>,</span><br><span class="line">        <span class="number">10201020402010201</span>,</span><br><span class="line">        <span class="number">10203040504030201</span>,</span><br><span class="line">        <span class="number">10205060806050201</span>,</span><br><span class="line">        <span class="number">10221432623412201</span>,</span><br><span class="line">        <span class="number">10223454745432201</span>,</span><br><span class="line">        <span class="number">12100002420000121</span>,</span><br><span class="line">        <span class="number">12102202520220121</span>,</span><br><span class="line">        <span class="number">12104402820440121</span>,</span><br><span class="line">        <span class="number">12122232623222121</span>,</span><br><span class="line">        <span class="number">12124434743442121</span>,</span><br><span class="line">        <span class="number">12321024642012321</span>,</span><br><span class="line">        <span class="number">12323244744232321</span>,</span><br><span class="line">        <span class="number">12343456865434321</span>,</span><br><span class="line">        <span class="number">12345678987654321</span>,</span><br><span class="line">        <span class="number">40000000800000004</span>,</span><br><span class="line">        <span class="number">40004000900040004</span></span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Enumeration</tag>
      </tags>
  </entry>
  <entry>
    <title>92. Reverse Linked List II (Medium)</title>
    <url>/post/leetcode/92-Reverse-Linked-List-II-Medium/</url>
    <content><![CDATA[<p>链表问题。实现一个程序根据 2 个下标位置对链表对于位置的元素进行翻转。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">Output: [1,4,3,2,5]</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>啥也不多说，看看算法。</p>
<ul>
<li>把 <code>LinkedList</code> 转换成 <code>List；</code></li>
<li>交换 <code>left</code> 和 <code>right</code> 的值；</li>
<li>更新 <code>left</code> 和 <code>right</code> 指针；</li>
<li>重复过程直到 <code>left</code> 不再小于 <code>right</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: ListNode, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        nodes = [head]</span><br><span class="line">        <span class="keyword">while</span> head.<span class="built_in">next</span>:</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            nodes.append(head)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            nodes[left - <span class="number">1</span>].val, nodes[right - <span class="number">1</span>].val = nodes[right - <span class="number">1</span>].val, nodes[left - <span class="number">1</span>].val</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nodes[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>94. Binary Tree Inorder Traversal (Easy)</title>
    <url>/post/leetcode/94-Binary-Tree-Inorder-Traversal-Easy/</url>
    <content><![CDATA[<p>遍历树的方法通常有三种，分别是前序遍历 pre-order traversal、中序遍历 in-order traversal 和后序遍历 post-order traversal。这道题是中序遍历。</p>
<p>难度上来说，前序最简单，中序和后序遍历会复杂一点。</p>
<span id="more"></span>

<h2 id="思路-1，递归"><a href="#思路-1，递归" class="headerlink" title="思路 1，递归"></a>思路 1，递归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            traverse(node.left)</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            traverse(node.right)</span><br><span class="line"></span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，遍历"><a href="#思路-2，遍历" class="headerlink" title="思路 2，遍历"></a>思路 2，遍历</h2><p>基于前序遍历的方案做的修改，可以解决问题，但是在空间复杂度上有优化余地，为了储存 stack 使用了额外的 2n 的空间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans, stack = [], [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">type</span>(node) == <span class="built_in">int</span>:</span><br><span class="line">                ans.append(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">                stack.append(node.val)</span><br><span class="line">                stack.append(node.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，遍历，优化版本"><a href="#思路-3，遍历，优化版本" class="headerlink" title="思路 3，遍历，优化版本"></a>思路 3，遍历，优化版本</h2><p>中序遍历要先遍历左节点，所以先抵达最左路径的最后一个节点，从这个节点开始回溯，重复检查左节点，本体和右节点的顺序。</p>
<p>这其实是思路 1 递归的扁平化处理，使用 stack 来替代递归过程。时间复杂度和空间复杂度均为 O(n)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans, stack, curr = [], [], root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">or</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># find the leftmost node</span></span><br><span class="line">            <span class="keyword">while</span> curr:</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr = curr.left</span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            <span class="comment"># record its value</span></span><br><span class="line">            ans.append(curr.val)</span><br><span class="line">            <span class="comment"># start the next turn with its right node</span></span><br><span class="line">            curr = curr.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-4，莫里斯遍历-Morris-Traversal"><a href="#思路-4，莫里斯遍历-Morris-Traversal" class="headerlink" title="思路 4，莫里斯遍历 Morris Traversal"></a>思路 4，莫里斯遍历 Morris Traversal</h2><p>也叫线索二叉树（Threaded Binary Tree），修改树的结构，让其“穿起来”成为一条线，整个遍历过程重复修改结构 -&gt; 遍历数据的过程。</p>
<p>具体做法如下：</p>
<ul>
<li>当前节点不存在左节点时<ul>
<li>记录当前节点值</li>
<li>将右节点标记为当前节点</li>
</ul>
</li>
<li>当前节点存在左节点时<ul>
<li>将当前节点挂在左节点的最后一个右节点上</li>
<li>将左节点标记为当前节点</li>
</ul>
</li>
<li>重复这个过程直到不存在当前节点</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans, curr = [], root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">if</span> curr.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                ans.append(curr.val)</span><br><span class="line">                curr = curr.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = curr.left</span><br><span class="line">                <span class="keyword">while</span> pre.right:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                pre.right = curr</span><br><span class="line">                curr.left, curr = <span class="literal">None</span>, curr.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>抄一个 Threaded Binary Tree 的解释方便理解。</p>
<blockquote>
<p>For example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   /</span><br><span class="line">4   5 6</span><br></pre></td></tr></table></figure>

<p>First, 1 is the root, so initialize 1 as current, 1 has left child which is 2, the current’s left subtree is</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>

<p>So in this subtree, the rightmost node is 5, then make the current(1) as the right child of 5. Set current = cuurent.left (current = 2). The tree now looks like:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br><span class="line">     \</span><br><span class="line">      1</span><br><span class="line">       \</span><br><span class="line">        3</span><br><span class="line">       /</span><br><span class="line">      6</span><br></pre></td></tr></table></figure>

<p>For current 2, which has left child 4, we can continue with thesame process as we did above</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    5</span><br><span class="line">     \</span><br><span class="line">      1</span><br><span class="line">       \</span><br><span class="line">        3</span><br><span class="line">       /</span><br><span class="line">      6</span><br></pre></td></tr></table></figure>

<p>then add 4 because it has no left child, then add 2, 5, 1, 3 one by one, for node 3 which has left child 6, do the same as above. Finally, the inorder traversal is [4,2,5,1,6,3].</p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>943. Find the Shortest Superstring (Hard)</title>
    <url>/post/leetcode/943-Find-the-Shortest-Superstring-Hard/</url>
    <content><![CDATA[<h2 id="NOT-SOLVED-YET"><a href="#NOT-SOLVED-YET" class="headerlink" title="NOT SOLVED YET!!"></a>NOT SOLVED YET!!</h2><p>计算完每个字符串的 overlap 之后，这个问题变成了有向加权图的最短路径问题，这是一个典型的 TSP 问题，NP-Hard 难度。</p>
<p>由于暂时还是我的只是盲区，先做记录，等学到图论和 TSP 解法的时候再来看看这道题。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
        <tag>DP</tag>
        <tag>Bit Manipulation</tag>
        <tag>Bitmask</tag>
        <tag>Not Solved</tag>
      </tags>
  </entry>
  <entry>
    <title>968. Binary Tree Cameras (Hard)</title>
    <url>/post/leetcode/968-Binary-Tree-Cameras-Hard/</url>
    <content><![CDATA[<p>在二叉树上安装摄像头，每个摄像头可以监控 +1 的距离，也就是它的父节点、子节点和自身。求最少需要安装多少摄像头才能监控整棵树。</p>
<p>这道题我们讨论贪心算法和 DP 的应用。</p>
<span id="more"></span>

<h2 id="思路-1，贪心从下而上"><a href="#思路-1，贪心从下而上" class="headerlink" title="思路 1，贪心从下而上"></a>思路 1，贪心从下而上</h2><p>这里能使用贪心算法是因为我们可以从叶子节点开始，给叶子节点的父节点安装摄像头，并一步步往上推出需要安装摄像头的最小数量。</p>
<p>解题思路的第一步是要推算一个节点能有多少种状态，这道题每个节点存在 3 种状态：</p>
<ul>
<li><code>0</code>: 无摄像头覆盖</li>
<li><code>1</code>: 有摄像头覆盖</li>
<li><code>2</code>: 节点安装了摄像头</li>
</ul>
<p>第二步是要处理父节点遇到子节点处于上面各种状态时应该如何应对，根据状态有三种应对，我们需要按照顺序处理，即在下面的判断已经排除了上面的判断条件：</p>
<ul>
<li>左右子节点有一个无摄像头覆盖（<code>0</code>）：此时父节点必须安装摄像头，即返回 <code>2</code></li>
<li>左右子节点有一个安装了摄像头（<code>2</code>）：由于已经判断子节点没有无覆盖的情况，此时父节点可以算有摄像头覆盖，返回 <code>1</code></li>
<li>除了上述情况以外（左右子节点均为 <code>1</code>）：由于没有子节点安装摄像头，此时父节点只能是无摄像头覆盖，返回 <code>0</code></li>
</ul>
<p>第二步程序的思路已经明确了，但是有些特殊情况需要处理，所以第三步我们要找出特殊 case。这里有 2 个特殊情况需要考虑：</p>
<ul>
<li>叶子节点的处理<ul>
<li>由于我们希望叶子节点的父节点安装摄像头，所以我们希望叶子节点返回无摄像头覆盖（<code>0</code>）</li>
<li>已知叶子节点的左右子节点均为空<ul>
<li>根据第二步总结的思路，当左右节点均为有摄像头覆盖（<code>1</code>）时，父节点才能返回无摄像头覆盖（<code>0</code>）</li>
<li>结论：对于空节点需要返回有摄像头覆盖（<code>1</code>）</li>
</ul>
</li>
</ul>
</li>
<li>对于 <code>root</code> 节点的处理<ul>
<li><code>root</code> 节点也存在左右子节点存在无摄像头覆盖（<code>0</code>）的情况，有可能需要安装摄像头，这里有 2 种处理方法：<ol>
<li>父节点需要安装摄像头时必须返回 <code>2</code>，所以判断递归最后一次返回值为 2 时主动增加一次计数</li>
<li>或者，用一个 <code>dummy</code> 节点包装 <code>root</code> 节点，将对其的处理包括在递归过程中，我们不关注 <code>dummy</code> 节点的返回值，这样可以省去手动判断</li>
</ol>
</li>
<li>这里我们选择第二种做法</li>
</ul>
</li>
</ul>
<p>思路整理到这里，可以开始实现算法了，下面是 Python 代码例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCameraCover</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 0: not covered</span></span><br><span class="line">        <span class="comment"># 1: covered</span></span><br><span class="line">        <span class="comment"># 2: has camera</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># Mark none as covered</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            left = dfs(node.left)</span><br><span class="line">            right = dfs(node.right)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">min</span>(left, right) == <span class="number">0</span>:</span><br><span class="line">                self.ans += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">max</span>(left, right) == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        <span class="comment"># Wrap root with a dummy node to avoid special case of 0 at root.</span></span><br><span class="line">        dfs(TreeNode(left=root))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，DP"><a href="#思路-2，DP" class="headerlink" title="思路 2，DP"></a>思路 2，DP</h2><p>忘掉思路 1，来看看 DP 的解决方案。</p>
<p>思路 1 总结的状态对 DP 方案不适用，忘掉它，我们重新总结一个节点<strong>允许的状态</strong>，这里不再包括无摄像头覆盖的场景。</p>
<p>第一步，总结节点可能的状态有三种：</p>
<ul>
<li><code>BY_CH</code>：by children，节点被子节点的摄像头覆盖</li>
<li><code>BY_PR</code>：by parent，节点被父节点的摄像头覆盖</li>
<li><code>HAS_C</code>：has camera，节点被自己的摄像头覆盖</li>
</ul>
<p>第二步，应用 DP。程序整体的做法是针对一个节点所有状态分别计算需要的摄像头数量，递交给上一层递归进行下一步判断，直到达到 <code>root</code> 节点时，由于不再存在父节点，取 <code>BY_CH</code> 和 <code>HAS_C</code> 的最小值作为答案。</p>
<p>对于每一次递归的逻辑，我们需要分别计算这三种状态下的摄像头安装数量，如果通过 flag 控制递归过程计算三次不同的值将造成大量重复计算（因为每个节点将执行 3 次递归逻辑），所以在每次递归逻辑中计算并返回这三个状态的值才是最优解。</p>
<p>在递归逻辑中我们执行下面的计算（已知当前节点（<code>node</code>）和左右子节点（<code>left</code>，<code>right</code>）及其三个状态值）：</p>
<ul>
<li><code>BY_CH</code>：当前节点不安装摄像头，需要考虑子节点 <code>BY_CH</code> 和 <code>HAS_C</code> 的情况，我们取下面情况的最小值：<ul>
<li><code>left.HAS_C</code> + <code>right.HAS_C</code> ：左右子节点都存在摄像头，不需要当前节点安装摄像头</li>
<li><code>left.HAS_C</code> + <code>right.BY_CH</code> ：左节点存在摄像头，右节点被其子节点覆盖，不需要当前节点安装摄像头</li>
<li><code>left.BY_CH</code> + <code>right.HAS_C</code> ：左节点被其子节点覆盖，右节点存在摄像头，不需要当前节点安装摄像头</li>
</ul>
</li>
<li><code>BY_PR</code>：当前节点不安装摄像头，也不依赖子节点安装摄像头，这个状态仅比上面多一种情况：<ul>
<li><code>node.BY_CH</code> ：当前节点依赖子节点安装摄像头的状态值，使用这个值避免重复计算</li>
<li><code>left.BY_CH</code> + <code>right.BY_CH</code> ：左右子节点被各自的子节点的摄像头覆盖，不需要当前节点安装摄像头</li>
</ul>
</li>
<li><code>HAS_C</code>：当前节点<strong>安装摄像头</strong>，需要考虑子节点 <code>BY_PR</code> 和 <code>HAS_C</code> 的情况，取下面状态的最小值，<strong>在此基础上+1</strong>：<ul>
<li><code>left.BY_PR</code> + <code>right.BY_PR</code> ：左右子节点都依赖当前节点安装摄像头</li>
<li><code>left.BY_PR</code> + <code>right.HAS_C</code> ：左节点依赖当前节点安装摄像头，右节点存在摄像头</li>
<li><code>left.HAS_C</code> + <code>right.BY_PR</code> ：左节点存在摄像头，右节点依赖当前节点安装摄像头</li>
</ul>
</li>
</ul>
<blockquote>
<p>在计算 <code>HAS_C</code> 时不应该考虑子节点被其子节点覆盖（<code>BY_CH</code>）的情况，从逻辑上来说，如果子节点被其子节点覆盖，也就不再依赖父节点安装摄像头；其次，考虑下面的 case，如果节点 A 考虑子节点 B 依赖其子节点覆盖的情况，那么为了覆盖节点 B 的两个子节点，B 的 <code>BY_CH</code> 状态值将等于 2，那么如果节点 A 安装摄像头，A 的 <code>HAS_C</code> 最终为 2 + 1 = 3，已经偏离最优解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   O</span><br><span class="line">   │</span><br><span class="line">┌──┴──┐</span><br><span class="line">│     │</span><br><span class="line">O     O(A)</span><br><span class="line">      │</span><br><span class="line">   ┌──┴──┐</span><br><span class="line">   │     │</span><br><span class="line">   O     O(B)</span><br><span class="line">         │</span><br><span class="line">      ┌──┴──┐</span><br><span class="line">      │     │</span><br><span class="line">      O     O</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个思路需要考虑的特殊情况同样是叶子节点和递归返回值。</p>
<ul>
<li>叶子节点<ul>
<li>叶子节点不存在被子节点覆盖（<code>BY_CH</code>）的情况<ul>
<li>所以将其子节点的 <code>HAS_C</code> 设为无限大，这个值将在下一次计算中被舍弃</li>
<li>其子节点的另外两个状态初始化为 0 即可</li>
</ul>
</li>
</ul>
</li>
<li><code>root</code> 节点的递归返回值<ul>
<li>之前已经解释过了，对于 <code>root</code> 来说已经不存在父节点了，所以我们在其返回值中取 <code>BY_CH</code> 和 <code>HAS_C</code> 的最小值作为答案</li>
</ul>
</li>
</ul>
<p>思路整理结束，信息量足够开始实现算法了。下面是 Python 代码例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BY_PR = <span class="number">0</span> <span class="comment"># covered by parent</span></span><br><span class="line">BY_CH = <span class="number">1</span> <span class="comment"># covered by children</span></span><br><span class="line">HAS_C = <span class="number">2</span> <span class="comment"># has camera</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCameraCover</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">df</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            l = df(node.left)</span><br><span class="line">            r = df(node.right)</span><br><span class="line">            bych = <span class="built_in">min</span>(l[HAS_C] + r[HAS_C], l[HAS_C] + r[BY_CH], l[BY_CH] + r[HAS_C])</span><br><span class="line">            bypr = <span class="built_in">min</span>(l[BY_CH] + r[BY_CH], bych)</span><br><span class="line">            hasc = <span class="built_in">min</span>(l[BY_PR] + r[BY_PR], l[BY_PR] + r[HAS_C], l[HAS_C] + r[BY_PR]) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> bypr, bych, hasc</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(df(root)[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>贪心和 DP 思路差异比较明显。</p>
<ul>
<li>贪心思路默认处于最优情况，只讨论最坏 case</li>
<li>DP 思路计算所有情况，仅舍弃不合理的 case</li>
</ul>
<p>但是两者都需要清晰的有目的性的思考才能理清思路，相对来说，DP 方案比贪心方案要容易一些，因为贪心方案需要更加细致的观察。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>97. Interleaving String (Medium)</title>
    <url>/post/leetcode/97-Interleaving-String-Medium/</url>
    <content><![CDATA[<p>字符串问题。定义字符串交错指的是俩个字符串的字符交错出现构成一个新的字符串。比如对字符串 <code>s</code> 和 <code>t</code> 来说：</p>
<ul>
<li><code>s = s1 + s2 + ... + sn</code></li>
<li><code>t = t1 + t2 + ... + tm</code></li>
<li><code>|n - m| &lt;= 1</code></li>
<li>The <strong>interleaving</strong> is <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> or <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li>
</ul>
<p>现在你需要实现一个程序接受三个字符串 <code>s1</code>、 <code>s2</code>、 <code>s3</code>，判断 <code>s3</code> 是否是 <code>s1</code> 和 <code>s2</code> 字符串交错组成。</p>
<span id="more"></span>

<h2 id="思路-1，2D-数组动态规划"><a href="#思路-1，2D-数组动态规划" class="headerlink" title="思路 1，2D 数组动态规划"></a>思路 1，2D 数组动态规划</h2><p>这题乍一看用快慢指针可以解出来，但是这是个陷阱，设想如果下一个字符可以同时从 <code>s1</code> 和 <code>s2</code> 中取得，如果使用快慢指针这里如何处理？可以考虑回溯算法，但是这变成了暴力破解，无法在时限内通过测试 case。</p>
<p>DP 相关的题目对思路和直觉有要求，为了方便后面的计算，我们先把一个特殊 case 排除在外：</p>
<ul>
<li>如果 <code>s1.length</code> + <code>s2.length</code> != <code>s3.length</code>，那就没有必要计算了，直接返回 <code>false</code>。</li>
</ul>
<p>接下来分析 DP 的思路。</p>
<ul>
<li>准备一个 <code>(m + 1)</code> * <code>(n + 1)</code> 的 2D 数组；<ul>
<li><code>m</code>：<code>s1.length</code>；<code>n</code>：<code>s2.length</code>；</li>
<li>+ 1 的原因是要留出第一个字符不选 <code>s1</code> 或 <code>s2</code> 的空间；</li>
</ul>
</li>
<li>初始化 <code>dp[0][0]</code> 为 <code>true</code> or 1，这个坐标意味长度为 0 的场景；</li>
<li>接下来要做的事情就是遍历 <code>dp</code> 的所有元素，计算对应下标的元素的值；</li>
<li>如果最后一个元素 <code>dp[-1][-1]</code> 的值为 <code>true</code> or 1，则 <code>s1</code> 和 <code>s2</code> 可以交替构成 <code>s3</code>。</li>
</ul>
<p>我们可以用示例画出对应的表格来帮助理解。</p>
<p>s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbcbcac”</p>
<table>
<thead>
<tr>
<th align="center">n \ m</th>
<th align="center">0</th>
<th align="center">1(a)</th>
<th align="center">2(a)</th>
<th align="center">3(b)</th>
<th align="center">4(c)</th>
<th align="center">5(c)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1(d)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">2(b)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">3(b)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">4(c)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">5(a)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>可以观察到，从 （0， 0） 开始，我们行走的方向只有向右和向下。</p>
<ul>
<li>向右：选择使用 <code>s1</code> 的字符，如果下一个字符匹配 <code>s3[row + col - 1]</code> 则设其值为 1；</li>
<li>向下：选择使用 <code>s2</code> 的字符，如果下一个字符匹配 <code>s3[row + col - 1]</code> 则设其值为 1。</li>
</ul>
<p>换言之，要计算当前位置的值时，需要先检查上面一个和左边一个值是否被选用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span>, s3: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s1) + <span class="built_in">len</span>(s2) != <span class="built_in">len</span>(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        m, n = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(m + <span class="number">1</span>), <span class="built_in">range</span>(n + <span class="number">1</span>)):</span><br><span class="line">            k, top, left = i + j - <span class="number">1</span>, <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                top = s3[k] == s1[i - <span class="number">1</span>] <span class="keyword">and</span> dp[i - <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j != <span class="number">0</span>:</span><br><span class="line">                left = s3[k] == s2[j - <span class="number">1</span>] <span class="keyword">and</span> dp[i][j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> i + j &gt; <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = top <span class="keyword">or</span> left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，1D-数组动态规划"><a href="#思路-2，1D-数组动态规划" class="headerlink" title="思路 2，1D 数组动态规划"></a>思路 2，1D 数组动态规划</h2><p>通过观察可以知道上面方法每次最多只看到上一行，那么实际上我们没必要准备一个全量的 2D 数组，一个 1D 数组足够处理这些数据了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span>, s3: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s1) + <span class="built_in">len</span>(s2) != <span class="built_in">len</span>(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        m, n = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line"></span><br><span class="line">        dp = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(m + <span class="number">1</span>), <span class="built_in">range</span>(n + <span class="number">1</span>)):</span><br><span class="line">            k, top, left = i + j - <span class="number">1</span>, <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                top = s3[k] == s1[i - <span class="number">1</span>] <span class="keyword">and</span> dp[j]</span><br><span class="line">            <span class="keyword">if</span> j != <span class="number">0</span>:</span><br><span class="line">                left = s3[k] == s2[j - <span class="number">1</span>] <span class="keyword">and</span> dp[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> i + j &gt; <span class="number">0</span>:</span><br><span class="line">                dp[j] = top <span class="keyword">or</span> left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>970. Powerful Integers (Medium)</title>
    <url>/post/leetcode/970-Powerful-Integers-Medium/</url>
    <content><![CDATA[<p>给定 3 个整数 <code>x</code>， <code>y</code>， <code>bound</code>，求所有小于等于 <code>bound</code> 的强整数（Powerful Integers）。</p>
<p>强整数（Powerful Integers）指一个数可以用 <code>x^i + y^j</code> 的形式表现，其中 <code>i</code> 和 <code>j</code> 均大于等于 0。</p>
<p>答案无所谓排序，但是不能有重复的值。需要用到一些数学方法来解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先找到指数的边界，然后枚举所有可能的结果。</p>
<p>使用一个 <code>set</code> 来进行去重。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">powerfulIntegers</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span>, bound: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        a = <span class="number">0</span> <span class="keyword">if</span> x == <span class="number">1</span> <span class="keyword">else</span> <span class="built_in">int</span>(log(bound, x))</span><br><span class="line">        b = <span class="number">0</span> <span class="keyword">if</span> y == <span class="number">1</span> <span class="keyword">else</span> <span class="built_in">int</span>(log(bound, y))</span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a + <span class="number">1</span>):</span><br><span class="line">            left = x ** i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(b + <span class="number">1</span>):</span><br><span class="line">                r = left + y ** j</span><br><span class="line">                <span class="keyword">if</span> r &lt;= bound:</span><br><span class="line">                    ans.add(r)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(ans)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>从需求来看 MongoDB 的最简单用法</title>
    <url>/post/notes/Simple-Usage-of-MongoDB/</url>
    <content><![CDATA[<p>从需求来看 MongoDB，了解能满足我们需求的最简用法。</p>
<p>这篇文章介绍如何在 Python 中操作 MongoDB，面向初学者。我们使用 MongoDB 来储存一个网站的数据，去满足搭建一个博客网站可能会遇到的需求，以此为例来熟悉和了解 MongoDB。</p>
<p>以下是这篇文章讨论的内容：</p>
<ul>
<li>设计符合需求的数据结构</li>
<li>document 的增删改查</li>
</ul>
<span id="more"></span>

<p>这些内容是基础知识。</p>
<h2 id="设计符合需求的数据结构"><a href="#设计符合需求的数据结构" class="headerlink" title="设计符合需求的数据结构"></a>设计符合需求的数据结构</h2><p>// TODO or delete</p>
<p>// Or maybe extract this part as a single post.</p>
<h2 id="document-的增删改查"><a href="#document-的增删改查" class="headerlink" title="document 的增删改查"></a>document 的增删改查</h2><h3 id="连接-MongoDB"><a href="#连接-MongoDB" class="headerlink" title="连接 MongoDB"></a>连接 MongoDB</h3><p>这是一个连接 MongoDB 的示例代码，主要用来定义几个变量方便后面使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"><span class="keyword">from</span> bson <span class="keyword">import</span> ObjectId</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mc = MongoClient() <span class="comment"># connect to default client</span></span><br><span class="line">db = mc[<span class="string">&#x27;test&#x27;</span>] <span class="comment"># use &#x27;test&#x27; database</span></span><br><span class="line">col = db[<span class="string">&#x27;test-collection&#x27;</span>] <span class="comment"># use &#x27;test-collection&#x27; collection</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="find-查询"><a href="#find-查询" class="headerlink" title="find 查询"></a>find 查询</h3><p>查询是使用数据库的基础需求。在 MongoDB 中查询分为两种，查询单个值的 <code>find_one</code> 和查询多个值的 <code>find</code>。使用方法示例如下。</p>
<h4 id="find-one-amp-find"><a href="#find-one-amp-find" class="headerlink" title="find_one &amp; find"></a>find_one &amp; find</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Query for only one document</span></span><br><span class="line">col.find_one(&#123;</span><br><span class="line">    <span class="string">&#x27;some_fields&#x27;</span>: <span class="string">&#x27;values&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;array_fields&#x27;</span>: [<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;object_fields&#x27;</span>: &#123;<span class="string">&#x27;keys&#x27;</span>: <span class="string">&#x27;values&#x27;</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment"># Query for one or more than one documents</span></span><br><span class="line">col.find(&#123;</span><br><span class="line">    <span class="string">&#x27;some_fields&#x27;</span>: <span class="string">&#x27;values&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;array_fields&#x27;</span>: [<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;object_fields&#x27;</span>: &#123;<span class="string">&#x27;keys&#x27;</span>: <span class="string">&#x27;values&#x27;</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以知道，查询方法接收一个参数作为查询条件，且这个参数需要是 <code>dict</code> 对象类型。这个例子如果放在 SQL 语句中对应 <code>select * from ... where ...</code> 句式。</p>
<p>上面的例子查询条件是几个精确值，很多时候我们的查询条件无法准确到一个具体的值，需要限定一个范围查询。MongoDB 使用比较操作符来圈定范围，来看下面这个例子 🌰。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.find(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;views&#x27;</span>: &#123;<span class="string">&#x27;$gte&#x27;</span>: <span class="number">1000</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这个例子中，我们可以拿到所有 <code>views</code> 值大于等于 1000 的文章。比较操作符 <code>$gte</code> 表达大于等于的关系，这是 <code>greater than or equal to</code> 的缩写，含义等同于 <code>&gt;=</code>。</p>
<p>常用的比较操作符有下面这些：</p>
<ul>
<li><code>$eq</code> equal to</li>
<li><code>$gt</code> greater than</li>
<li><code>$gte</code> greater than or equal to</li>
<li><code>$lt</code> less than</li>
<li><code>$lte</code> less than or equal to</li>
<li><code>$ne</code> not equal to</li>
<li><code>$in</code> match in an array</li>
<li><code>$nin</code> not match in an array</li>
</ul>
<p>这些操作符中，<code>$in</code> 和 <code>$nin</code> 需要匹配数组，例如 <code>$in</code> 的表达方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;field_name&#x27;</span>: &#123;<span class="string">&#x27;$in&#x27;</span>: [<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>...<span class="string">&#x27;values&#x27;</span>]&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>而其他的比较操作符需要匹配单个值，例如 <code>$eq</code> 的表达方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;field_name&#x27;</span>: &#123;<span class="string">&#x27;$eq&#x27;</span>: <span class="string">&#x27;value&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这些操作符可用于所有比较关系，不仅限于 <code>find</code> 查询，还包括更新、删除和 <code>aggregate</code> 聚合等场合。</p>
<h4 id="project-计划字段"><a href="#project-计划字段" class="headerlink" title="project 计划字段"></a>project 计划字段</h4><p><code>find</code> 默认拉取整个 document 作为输出，类似 SQL 的 <code>select * from table</code>，这意味着即使你只想要这个文档中的一个字段，你也将先得到整个文档，然后从中取得你想要的字段。通常出于带宽的限制以及性能的考虑，这都不是一个好主意，好在有办法只取某几个字段，在 MongoDB 中这个概念被称作 <code>project</code>。</p>
<p><code>find</code> 方法的第二个参数将被视为 <code>projection</code>，同样也需要是 <code>dict</code> 对象类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.find(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;author&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;content&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这个例子中，我们在第二个参数中列出需要的字段名，并将其值设为 <code>1</code>， 我们就完成了对需要字段的声明。<code>projection</code> 中字段对应的值是一个 flag，当其为 <code>1</code> 的时候，代表<strong>包含关系</strong>，让 MongoDB 可以理解我们的需求，仅取出需要的字段。</p>
<p>或者，我们也可以声明不要获取哪些字段。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.find(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;comments&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;reviews&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面说到 <code>projection</code> 中字段对应的值是 flag，那么 <code>0</code> 就表示<strong>不包含关系</strong>。MongoDB 会知道我们的意思，并且把我们声明不需要的字段以外的数据都取出来，这在一些场景下很有用。</p>
<p>在使用 <code>projection</code> 时需要注意，<code>_id</code> 字段在 MongoDB 中有特殊的地位，即使没有被声明为需要获取的字段，其依然会被默认抽取出来。但如果你确实不需要它，可以在 <code>projection</code> 中手动设置为 <code>0</code>，它就不会出现了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.find(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;_id&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;author&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;content&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>但是注意，除了 <code>_id</code> 以外，包含关系（<code>1</code>）和不包含关系（<code>0</code>）是不能共存的，否则你会得到下面这个错误。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pymongo.errors.OperationFailure: Projection cannot have a mix of inclusion and exclusion.</span><br></pre></td></tr></table></figure>

<p>所以需要记住，对于 <code>_id</code> 来说，想要不显示它需要手动设置为 <code>0</code>。但对其他字段来说，只能有两个选择，声明所有需要获取的字段，或者声明所有不需要获取的字段。如果你尝试同时要求 MongoDB 理解你需要哪些字段和不需要哪些字段，那么只能得到无情的报错。</p>
<h4 id="project-进阶"><a href="#project-进阶" class="headerlink" title="project 进阶"></a>project 进阶</h4><p>声明获取和不获取的字段只是 <code>project</code> 的一个功能，除此之外它还有很多很实用的能力。例如当需要查询一个数组对象时，有时我们需要更高精度的操作，比如做评论的分页时，通常一次性取出所有评论是没有必要的，有时甚至是昂贵的，这时我们可以使用 <code>project</code> 来帮我们做一些更进一步的操作。来看看这个例子 🌰。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.find(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"># Fetch the 0-3 of comments</span></span><br><span class="line">        <span class="string">&#x27;comments&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;$slice&#x27;</span>: <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># Fetch the 2-6 of comments</span></span><br><span class="line">        <span class="string">&#x27;comments&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;$slice&#x27;</span>: [<span class="number">2</span>, <span class="number">6</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># Fetch the last comment</span></span><br><span class="line">        <span class="string">&#x27;comments&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;$slice&#x27;</span>: -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的例子中展示了数组切片操作符的用法，其效果等同于 Python 中数组的切片操作。第一个 comments 取了数组的前 3 条数据，第二个 comments 取得了第 2 条到第 6 条的数据，最后一个 comments 取得了倒数第 1 条数据。</p>
<p>或者，有时我们仅需要取出符合要求的第一个评论，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.find(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"># Fetch the first deleted comment</span></span><br><span class="line">        <span class="string">&#x27;comments&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;$elemMatch&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;deleted&#x27;</span>: <span class="literal">True</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">col.find(</span><br><span class="line">    <span class="comment"># Fetch the first element matched the condition</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;comments&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;deleted&#x27;</span>: <span class="literal">True</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;comments.$&#x27;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的两个查询的效果一样，都是获取评论数组中满足删除 Flag 为 <code>true</code> 这个条件的第一条评论。不过这个例子的匹配世界上用处有限，因为通常我们需要取出的是满足条件的多条评论，而非最初的某一条。但是 <code>project</code> 虽然有办法实现，却不是在 <code>find</code> 方法中实现，在之后的关于 <code>aggregate</code> 的文章中我们再继续讨论如何满足这个需求吧。</p>
<p>目前为止涉及的文档：</p>
<ul>
<li><a href="https://docs.mongodb.com/manual/tutorial/query-documents/">Query Documents</a></li>
<li><a href="https://docs.mongodb.com/manual/reference/operator/query-comparison/">Comparison Query Operators</a></li>
<li><a href="https://docs.mongodb.com/manual/tutorial/project-fields-from-query-results/">Project Fields to Return from Query</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.find">collection – Collection level operations - find()</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.find_one">collection – Collection level operations - find_one()</a></li>
</ul>
<h3 id="update-更新"><a href="#update-更新" class="headerlink" title="update 更新"></a>update 更新</h3><p>修改已有的数据是普遍的需求。在我们要设计的博客系统中，用户主动以及被动的操作都会触发数据的变更，比如当用户打开一篇文章时，这篇文章的浏览数会得到更新；当用户赞了这篇文章时，这篇文章的点赞数也会得到更新；或者当用户在线修改了一篇文章的内容，这次修改也需要正确地更新到数据源上。</p>
<h4 id="update-one"><a href="#update-one" class="headerlink" title="update_one"></a>update_one</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Get user inputted content</span></span><br><span class="line">new_content = get_user_input()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Update specified article</span></span><br><span class="line">col.update_one(</span><br><span class="line">    <span class="comment"># Match article by id</span></span><br><span class="line">    &#123;<span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>)&#125;,</span><br><span class="line">    <span class="comment"># Update content</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;content&#x27;</span>: new_content&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面这个简单的例子中，我们假设通过 <code>get_user_input()</code> 函数拿到了用户的输入数据。接下来我们对指定的文章做了一次更新。</p>
<p>在例子中我们给 <code>update_one</code> 方法传递了两个参数，第一个是查询参数，对应 SQL 中的 <code>where</code> 小句。第二个参数是更新参数，<code>$set</code> 是更新操作的操作符，它的值也是一个 <code>dict</code> 对象，描述将什么字段更新成什么值，对应 SQL 中的 <code>update table set ...</code> 句式。</p>
<p>这是一个简单的更新操作，我们实际上做的是：</p>
<p>更新 <code>_id</code> 为给定值的文章，更新的字段是 <code>content（内容）</code>，更新的内容是我们之前拿到的用户输入值 <code>new_content</code>。</p>
<blockquote>
<p><code>_id</code> 是 MongoDB 中自动生成的一个字段，作为主键来标识数据的唯一性，它是一个对象而非字符串，在 Python 中指定的时候需要用 <code>ObjectId(）</code> 方法来生成一个 ID 对象。</p>
</blockquote>
<h4 id="inc-数值增量"><a href="#inc-数值增量" class="headerlink" title="$inc 数值增量"></a>$inc 数值增量</h4><p>回到更新文字阅读数和点赞数的例子 🌰，在这个场景中，我们希望阅读数和点赞数字段更新的结果是在原有的基础上增加 1，而不是设置一个具体的值给他。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.update_one(</span><br><span class="line">    <span class="comment"># Match article by id</span></span><br><span class="line">    &#123;<span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>)&#125;,</span><br><span class="line">    <span class="comment"># Update views</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;$inc&#x27;</span>: &#123;<span class="string">&#x27;views&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>MongoDB 提供了一个 <code>$inc</code> 操作符来实现给指定的字段做增量操作。所有我们实际的操作是：更新 <code>_id</code> 为给定值的文章，更新的字段是 <code>views（点击量）</code>，更新的内容是在原有的基础上加 1。当然增量的值是根据需要设定的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.update_one(</span><br><span class="line">    <span class="comment"># Match user by username</span></span><br><span class="line">    &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">    <span class="comment"># Update points</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;$inc&#x27;</span>: &#123;<span class="string">&#x27;points&#x27;</span>: <span class="number">100</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们给名为 Richard 的用户增加了 100 积分来激励他继续使用我们的网站。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.update_one(</span><br><span class="line">    <span class="comment"># Match user by username</span></span><br><span class="line">    &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">    <span class="comment"># Update points</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;$inc&#x27;</span>: &#123;<span class="string">&#x27;points&#x27;</span>: -<span class="number">999</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>负值当然也是允许的，接着因为剧情需要我们发现了 Richard 的违规行为，谨慎考虑后我们决定扣除 999 积分以示惩戒。</p>
<p>这些操作都可以使用 <code>$inc</code> 完成。不过当然我们的博客也不需要积分系统。</p>
<p>上面的例子都使用了 <code>update_one</code> 方法，顾名思义其只对一个目标进行更新，当更新多个目标时我们用到另一个方法。</p>
<h4 id="update-many"><a href="#update-many" class="headerlink" title="update_many"></a>update_many</h4><p>我们对所有点击量超过 1000 的文章进行一次更新，将它们标注为热点文章。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.update_many(</span><br><span class="line">    &#123;<span class="string">&#x27;views&#x27;</span>: &#123;<span class="string">&#x27;$gte&#x27;</span>: <span class="number">1000</span>&#125;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;hot_topic&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>使用 <code>update_many</code> 进行批量更新操作时，同样的第一个参数将作为查询参数来负责筛选出我们需要的数据，第二个参数则将指定的字段更新为新的值。</p>
<p><code>update_many</code> 会返回一个 <code>UpdateResult</code> 对象，里面包含诸如匹配行数和修改行数等信息。</p>
<p>但是当我们在设计 RESTful API 的时候，一个比较好的实践是，更新操作完成后将更新后的对象作为响应对象交付给客户端，这样可以减少请求数量，并且准确的保持服务端和客户端的数据一致性。</p>
<p>要满足这个需求，就目前所了解到的信息，我们可以先执行一次更新操作，然后在执行一次查询操作，将更新后的数据再次取出来。但这太繁琐了，没关系，有一个更好的办法可以使用。</p>
<h4 id="find-one-and-update"><a href="#find-one-and-update" class="headerlink" title="find_one_and_update"></a>find_one_and_update</h4><p>从名称上我们就可以轻松的理解这个方法的含义，就是查找一个对象并且更新它。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> ReturnDocument</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get user inputted content</span></span><br><span class="line">new_content = get_user_input()</span><br><span class="line"></span><br><span class="line">col.find_one_and_update(</span><br><span class="line">    <span class="comment"># Match article by id</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># Update content and timestamp</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;$set&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;content&#x27;</span>: new_content,</span><br><span class="line">            <span class="string">&#x27;updated_time&#x27;</span>: time()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># Project fields</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;content&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;reviews&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;comment&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;updated_time&#x27;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># Return modified document</span></span><br><span class="line">    return_document=ReturnDocument.AFTER</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>例子 🌰 稍微有点长，首先我们导入了两个工具。和之前一样，假设我们从 <code>get_user_input()</code> 方法拿到了用户的输入内容，这是我们将要更新的数据。接着使用 <code>find_one_and_update</code> 来更新数据。</p>
<p>第一个参数是作为查询参数，匹配一个唯一的 <code>_id</code>；第二个参数是更新内容，我们将 <code>content</code> 更新为新的用户输入，并且使用 <code>time()</code> 工具更新时间戳；注意，这里出现了<strong>第三个参数</strong>，由于要进行一次查找文档，我们可以利用 <code>project</code> 计划字段来指定需要的字段。关于更新和查找的参数就是这些。</p>
<p>第四个参数是一个选项，是可以省略的，但是要小心，默认情况下，<code>find_one_and_update</code> 方法就如其名，会先查找出文档，再进行更新操作，这样的话返回的就是<strong>更新前的文档</strong>。</p>
<p>显然，为了保持数据一致性我们需求的应该是更新后的文档，<code>return_document</code> 选项就是用来指定这个行为的。从 <code>pymongo</code> 包中导入的 <code>ReturnDocument</code> 工具可以提供几个选项，在这里我们将 <code>ReturnDocument.AFTER</code> 设置给 <code>return_document</code> 即可告诉 MongoDB 给我们更新后的文档。</p>
<p>关于更新，了解这些想必搭建一个 blog 网站是够用了。</p>
<p>这一部分涉及的文档：</p>
<ul>
<li><a href="https://docs.mongodb.com/manual/reference/operator/update-field/">Field Update Operators</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.update_one">collection – Collection level operations - update_one()</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.update_many">collection – Collection level operations - update_many()</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.find_one_and_update">collection – Collection level operations - find_one_and_update()</a></li>
</ul>
<h3 id="delete-删除"><a href="#delete-删除" class="headerlink" title="delete 删除"></a>delete 删除</h3><p>一般的删除操作我们仅在逻辑层面上对数据进行删除，具体的操作是设定一个删除 Flag，对需要删除的数据进行更新，将该 Flag 值更新为 <code>True</code>，这样只需要用到上述的更新方法就可以完成了。</p>
<p>逻辑删除的好处之一是在于留有一些余地，当某些数据被误删除时能够及时得到恢复，毕竟数据是最重要的，而储存空间是便宜的。</p>
<p>不过当某些数据被最终认定为无用数据时，就是时候进行物理删除了。</p>
<p><strong>删除操作非常简单，但同时需要非常慎重。</strong></p>
<h4 id="delete-one"><a href="#delete-one" class="headerlink" title="delete_one"></a>delete_one</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.delete_one(</span><br><span class="line">    <span class="comment"># Delete specified article</span></span><br><span class="line">    &#123;<span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>)&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的例子将删除 <code>_id</code> 匹配的文章。</p>
<h4 id="delete-many"><a href="#delete-many" class="headerlink" title="delete_many"></a>delete_many</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.delete_many(</span><br><span class="line">    <span class="comment"># Delete articles which deleted flag is True</span></span><br><span class="line">    &#123;<span class="string">&#x27;deleted&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的例子将删除所有被逻辑删除的文章。在这里逻辑删除 Flag 名称是 <code>deleted</code>。</p>
<p>可以看到，无论是删除一个目标还是删除多个目标，对于删除方法来说只需要一个匹配参数来识别数据。</p>
<h4 id="find-one-and-delete"><a href="#find-one-and-delete" class="headerlink" title="find_one_and_delete"></a>find_one_and_delete</h4><p>有时我们可能会需要将删除的文档放在 response 中返回给客户端，来看看例子 🌰。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.find_one_and_delete(</span><br><span class="line">    <span class="comment"># Match article by id</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># Project field_names</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;content&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;reviews&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;comment&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;updated_time&#x27;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面这个例子很简单，匹配 <code>_id</code> 对应的文章，删除它，第二个参数作为 <code>project</code> 声明获取的字段，最终我们会得到一个文档，但是在数据库上这个文档已经被删除了。</p>
<p>删除操作看上去很简单，但是一份数据被删除的后果可能会很严重，对于删除操作我们应该小心慎行，毕竟数据无价。</p>
<p>这部分内容涉及的文档：</p>
<ul>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.delete_one">collection – Collection level operations - delete_one()</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.delete_many">collection – Collection level operations - delete_many()</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.find_one_and_delete">collection – Collection level operations - find_one_and_delete()</a></li>
</ul>
<h3 id="insert-插入"><a href="#insert-插入" class="headerlink" title="insert 插入"></a>insert 插入</h3><p>插入操作是保存数据的核心。了解完查询、更新和删除操作的使用方法，插入操作则显得很简单。</p>
<h4 id="insert-one"><a href="#insert-one" class="headerlink" title="insert_one"></a>insert_one</h4><p>当用户发表了 1 条评论，我们需要将这条评论保存到正确的文档下面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.insert_one(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;article_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;comment&#x27;</span>: <span class="string">&#x27;Awesome!&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1531211551.682105</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的例子将保存一条来自用户 Richard 的评论，虽然评论内容没什么意义，但是它还是被正常的保存在数据库了。或许我们应该把这条评论的 ID 发回客户端，让我们稍微修改下这个例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = col.insert_one(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;article_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;comment&#x27;</span>: <span class="string">&#x27;Awesome!&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1531211551.682105</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">comment_id = result.inserted_id</span><br></pre></td></tr></table></figure>

<p>用一个变量接受插入操作的结果对象，里面包含了我们需要的 ID，使用 <code>inserted_id</code> key 可以将其取出来。你或许觉得有些麻烦，为何我们不能手动设置 ID，或者设置我们想要的 ID？</p>
<p>再修改一下代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.insert_one(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;_id&#x27;</span>: <span class="string">&#x27;cid007&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;article_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;comment&#x27;</span>: <span class="string">&#x27;Awesome!&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1531211551.682105</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当我们手动指定了 ID 字段，MongoDB 将不会自动为我们生成新的 ID，有些时候会比较有用，根据你的习惯来决定是否需要手动来设定 ID 吧！</p>
<h4 id="insert-many"><a href="#insert-many" class="headerlink" title="insert_many"></a>insert_many</h4><p>有时我们可能需要考虑到减少请求数量，仅在收集了一些评论之后才真正到进行更新，当然这里我们关注的重点是如何同时更新多条评论。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.insert_many(</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;article_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;comment&#x27;</span>: <span class="string">&#x27;Awesome!&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1531211551.682105</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;article_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;comment&#x27;</span>: <span class="string">&#x27;Awesome again!&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1531212418.92356</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们又插入了两条没有意义的评论。</p>
<p>可以看到 <code>insert_many</code> 接收一个文档 list，同样的，如果需要得到 ID，可以用一个变量接收插入操作的结果，使用 <code>inserted_ids</code> 来获得 ID，但是注意，获得的将会是一个 ID 的 list。</p>
<p>插入操作同样很简单。但是目前为止，我们似乎默认了一个事实，将评论储存在一个单独的 collection 中。</p>
<p>MongoDB 是一个文档数据库，不应该用传统的关系型数据库的思路来看待它，对于文章和评论这种典型的一对多的关系，内嵌数组会是一种更好的数据结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">articles = &#123;</span><br><span class="line">    <span class="comment"># Article ID</span></span><br><span class="line">    <span class="string">&#x27;_id&#x27;</span>: <span class="string">&#x27;5b33af56d2cbe686e00b75c9&#x27;</span>,</span><br><span class="line">    <span class="comment"># Other field_names</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># Comments</span></span><br><span class="line">    <span class="string">&#x27;comments&#x27;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment"># Comment ID</span></span><br><span class="line">            <span class="string">&#x27;cid&#x27;</span>: <span class="string">&#x27;5b3dc242f0470538510b28d7&#x27;</span>,</span><br><span class="line">            <span class="comment"># Username</span></span><br><span class="line">            <span class="string">&#x27;from&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">            <span class="comment"># Comment body</span></span><br><span class="line">            <span class="string">&#x27;body&#x27;</span>: <span class="string">&#x27;Content of comment.&#x27;</span>,</span><br><span class="line">            <span class="comment"># Created or updated timestamp</span></span><br><span class="line">            <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1529248843.301676</span>,</span><br><span class="line">            <span class="comment"># Deleted flag</span></span><br><span class="line">            <span class="string">&#x27;deleted&#x27;</span>: <span class="literal">False</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># Created or updated timestamp</span></span><br><span class="line">    <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1529248869.717813</span>,</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>评论作为一个 list 内嵌在所属的文章文档里，这时添加一个评论不再是插入操作了，它变成了一个更新操作。</p>
<h4 id="update-array-use-push"><a href="#update-array-use-push" class="headerlink" title="update array use $push"></a>update array use $push</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.update_one(</span><br><span class="line">    &#123;<span class="string">&#x27;_id&#x27;</span>: Object(<span class="string">&#x27;5b33af56d2cbe686e00b75c9&#x27;</span>)&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;$push&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;comments&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;cid&#x27;</span>: ObjectId(),</span><br><span class="line">                <span class="string">&#x27;comment&#x27;</span>: <span class="string">&#x27;Awesome!&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1531211551.682105</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>使用 <code>$push</code> 操作符可以将一条评论添加到评论 list 中。而由于评论不再是单独的文档，不再自动生成 ID 属性，如果需要的话我们可以通过调用不带参数的 <code>ObjectId()</code> 来手动生成一个 ID 属性。</p>
<p>这部分涉及的文档：</p>
<ul>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.insert_one">collection – Collection level operations - insert_one()</a></li>
<li><a href="hhttp://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.insert_many">collection – Collection level operations - insert_many()</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/results.html#pymongo.results.InsertOneResult">results – Result class definitions - InsertOneResult</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/results.html#pymongo.results.InsertManyResult">results – Result class definitions - InsertManyResult</a></li>
<li><a href="https://docs.mongodb.com/manual/reference/operator/update-array/">Array Update Operators</a></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我们已经了解了 MongoDB 的增删改查的操作。无论增删改查，都有两种模式，操作单一文档的方法后缀都是 <code>one</code>:</p>
<ul>
<li>insert_one</li>
<li>delete_one</li>
<li>update_one</li>
<li>find_one</li>
</ul>
<p>而操作多个文件基本都是加后缀 <code>many</code>，只有 <code>find</code> 是特殊的，什么都不加：</p>
<ul>
<li>insert_many</li>
<li>delete_many</li>
<li>update_many</li>
<li>find</li>
</ul>
<p>对于更新或者删除之后的数据，有时我们需要拿到更新后或者删除前的文档返回给客户端，有两个方法很实用：</p>
<ul>
<li>find_one_and_update</li>
<li>find_one_and_delete</li>
</ul>
<p>但是注意，<code>find_one_and_update</code> 默认返回更新前的文档，设定 <code>return_document=ReturnDocument.AFTER</code> 可以变更默认行为，让它返回修改后的文档。</p>
<p>对于查询来说，我们还了解了 <code>project</code> 的概念，以此来声明我们需要哪些字段。</p>
<p>对于 <code>project</code> 要注意两点：</p>
<ul>
<li><code>_id</code> 是默认会取出的，除非在 <code>project</code> 中显示地声明不包含关系（设为 <code>0</code>）</li>
<li><code>_id</code> 以外的字段，在 <code>project</code> 中不可以同时声明包含关系（设为 <code>1</code>）和不包含关系（设为 <code>0</code>），否则将会报错</li>
</ul>
<p>除此之外，我们还看了看 MongoDB 中的比较操作符，快速扫一眼：</p>
<ul>
<li><code>$eq</code> equal to</li>
<li><code>$gt</code> greater than</li>
<li><code>$gte</code> greater than or equal to</li>
<li><code>$lt</code> less than</li>
<li><code>$lte</code> less than or equal to</li>
<li><code>$ne</code> not equal to</li>
<li><code>$in</code> match in an array</li>
<li><code>$nin</code> not match in an array</li>
</ul>
<p>然后，还有更新操作符：</p>
<ul>
<li><code>$set</code> 设置更新字段内容</li>
<li><code>$inc</code> 设置更新字段增量</li>
<li><code>$push</code> 添加一个对象到内嵌数组</li>
</ul>
<p>感觉如何？是不是很简单？</p>
<p>但是等等！如果你熟悉 SQL 的话可能会想，除了这些基础的功能，在 SQL 中实用的 <code>GROUP BY</code>、<code>MAX</code>、<code>SUM</code> 甚至 <code>PARTITION BY</code> 等分析函数在 MongoDB 中没有对应的实现吗？</p>
<p>答案当然是有的！并且我们需要的大部分分析函数在 MongoDB 中都有相应的实现。MongoDB 使用 <code>aggregate</code> 来满足各种数据分析的需求，如果有机会在之后的文章中我们再来讨论一下聚合的用法吧。</p>
<p>切实需要的东西才能在我们的记忆中保留一席之地，过多实际用不到的，或者近期用不到的信息，只会让记忆系统趋于混沌。目前我们已经了解了足够的知识来使 MongoDB 为我们所用了。等到需求或者求知欲继续延伸，就是进一步学习的最好时机。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Using CSS Transitions and Transforms</title>
    <url>/post/study/css/Using-CSS-Transitions-and-Transforms/</url>
    <content><![CDATA[<p>CSS 过渡属性提供了一种方式给 CSS 属性变化添加过渡动画，过程中属性值的变化是由浏览器所决定，所以其过程也被叫做<code>隐式过渡（implicit transitions）</code>。也因其由浏览器原生实现，所以通常有更好的性能，但是在灵活性上有其局限。</p>
<p>使用场景上，单纯的鼠标悬浮、选中和失去焦点等情况的过渡动画中 CSS 过渡属性是首选；但是当涉及到时间轴动画、稍复杂的补间动画时，应该选择 GSAP 之类的成熟的 JavaScript 动画库才合适。</p>
<blockquote>
<p>这里有一个<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties">可以使用过渡效果的属性列表</a>，对于可添加过渡效果的属性有 2 点需要注意：</p>
<ol>
<li>可以使用过渡效果的属性列表会发生变化，因为 transitions 的规格还没有定版；</li>
<li>对于变化前，或变化后的属性为 <code>auto</code> 的情况，规格建议不做过渡效果，但是每个浏览器对其采取不同处理，所以为了保证效果一致性，我们应该避免对 <code>auto</code> 添加过渡效果。</li>
</ol>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.25s</span> ease;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>) <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="过渡-transitions"><a href="#过渡-transitions" class="headerlink" title="过渡 transitions"></a>过渡 transitions</h2><blockquote>
<p>对于动画效果需要注意！</p>
<p>网页上的缩放动画效果是常见的特定偏头痛症状的触发因素，所以如果你希望在网页上加入这样的动画效果，你应该提供一个开关让用户可以选择关闭动画。</p>
<p>CSS 媒体查询有一个 <code>prefers-reduced-motion</code> 属性表示用户系统偏好设置了减少动画效果，你可以考虑使用这个媒体查询来关闭动画效果。</p>
</blockquote>
<h3 id="定义过渡属性"><a href="#定义过渡属性" class="headerlink" title="定义过渡属性"></a>定义过渡属性</h3><p>CSS 过渡属性可以轻易实现很出效果的动画。</p>
<blockquote>
<p>避免产生不适，点击 <code>start</code> 开始演示动画。</p>
</blockquote>
<div class="example-container" style="height: 150px">
  <div class="example-def transition radius-hover" style="height: 50px; width: 50px; background-color: rgb(25,135,84)"></div>
  <span class="toggle position-absolute top-0 end-0 m-3 hover-pointer">start</span>
</div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.25s</span> ease;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transition"><a href="#transition" class="headerlink" title="transition"></a><code>transition</code></h4><p>简写属性，定义过渡效果最常用的属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: &lt;property&gt; &lt;duration&gt; &lt;timing-function&gt; &lt;delay&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transition-property"><a href="#transition-property" class="headerlink" title="transition-property"></a><code>transition-property</code></h4><p>指定应用过渡效果的属性。</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>没有属性会添加过渡动画</td>
</tr>
<tr>
<td><code>all</code></td>
<td>默认值，所有支持的属性会添加过渡动画</td>
</tr>
<tr>
<td><code>&lt;property&gt;</code></td>
<td>如果属性支持过渡动画，指定的属性会添加过渡动画</td>
</tr>
</tbody></table>
<h4 id="transition-duration"><a href="#transition-duration" class="headerlink" title="transition-duration"></a><code>transition-duration</code></h4><p>指定过度效果的持续时间。</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>有效单位为 <code>ms</code>，<code>s</code></td>
<td>时间值，默认为 <code>0s</code></td>
</tr>
</tbody></table>
<h4 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a><code>transition-timing-function</code></h4><p>指定过度效果的缓动函数，一个描述数值变动速率的数学函数，视觉表现为我们熟知的贝塞尔曲线。</p>
<p><img src="/images/study/css/TimingFunction.png" alt="timing-function"></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>ease</code></td>
<td>默认值，相当于 <code>cubic-bezier(0.25, 0.1, 0.25, 1.0)</code></td>
</tr>
<tr>
<td><code>linear</code></td>
<td>相当于 <code>cubic-bezier(0.0, 0.0, 1.0, 1.0)</code></td>
</tr>
<tr>
<td><code>ease-in</code></td>
<td>相当于 <code>cubic-bezier(0.42, 0, 1.0, 1.0)</code></td>
</tr>
<tr>
<td><code>ease-out</code></td>
<td>相当于 <code>cubic-bezier(0, 0, 0.58, 1.0)</code></td>
</tr>
<tr>
<td><code>ease-in-out</code></td>
<td>相当于 <code>cubic-bezier(0.42, 0, 0.58, 1.0)</code></td>
</tr>
<tr>
<td><code>cubic-bezier(p1, p2, p3, p4)</code></td>
<td>自定义的贝塞尔曲线，<code>p1</code> 和 <code>p3</code> 的值需要在 <code>[0, 1]</code> 区间内</td>
</tr>
<tr>
<td><code>steps( n, &lt;jumpterm&gt;)</code></td>
<td>按步长应用过渡效果，不常用，略</td>
</tr>
</tbody></table>
<blockquote>
<p>步长值定义的参考资料：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function#values">https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function#values</a></li>
</ul>
</blockquote>
<h4 id="transition-delay"><a href="#transition-delay" class="headerlink" title="transition-delay"></a><code>transition-delay</code></h4><p>指定过度效果的延迟时间。</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>有效单位为 <code>ms</code>，<code>s</code></td>
<td>时间值，默认为 <code>0s</code></td>
</tr>
</tbody></table>
<h3 id="定义多个过渡属性"><a href="#定义多个过渡属性" class="headerlink" title="定义多个过渡属性"></a>定义多个过渡属性</h3><h4 id="使用-transition-时"><a href="#使用-transition-时" class="headerlink" title="使用 transition 时"></a>使用 <code>transition</code> 时</h4><p>CSS 过渡可以针对不同属性分别设置持续时间、缓动函数和延迟时间。使用 <code>transition</code> 时，多个过渡设置用逗号分隔。</p>
<blockquote>
<p>避免产生不适，点击 <code>start</code> 开始演示动画。</p>
</blockquote>
<div class="example-container justify-content-evenly" style="height: 150px">
  <div id="example-def" class="example-def transition radius-hover text-white text-nowrap fs-6 d-flex align-items-center justify-content-center" style="height: 50px; width: 50px; background-color: rgb(25,135,84)"><small>指定 all</small></div>
  <div id="example-def" class="example-def transition transition-multiple radius-hover text-white text-nowrap fs-6 d-flex align-items-center justify-content-center" style="height: 50px; width: 50px; background-color: rgb(25,135,84)"><small>分别指定</small></div>
  <span class="toggle position-absolute top-0 end-0 m-3 hover-pointer">start</span>
</div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.25s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.transition-multiple</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: background-color <span class="number">1s</span> ease, width <span class="number">0.25s</span> ease, height <span class="number">0.25s</span> ease, border-radius</span><br><span class="line">      <span class="number">1s</span> ease, transform <span class="number">0.25s</span> ease-in-out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-transition-分别定义时"><a href="#使用-transition-分别定义时" class="headerlink" title="使用 transition-* 分别定义时"></a>使用 <code>transition-*</code> 分别定义时</h4><p>在每个 <code>transition-*</code> 属性中使用逗号分隔值，由位置相互匹配属性，比如上面的简写转换成单独的属性将变成下面的定义。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition-multiple</span> &#123;</span><br><span class="line">  <span class="attribute">transition-property</span>: background-color, width, height, border-radius, transform;</span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">1s</span>, <span class="number">0.25s</span>, <span class="number">0.25s</span>, <span class="number">1s</span>, <span class="number">0.25s</span>;</span><br><span class="line">  <span class="attribute">transition-timing-function</span>: ease, ease, ease, ease, ease-in-out;</span><br><span class="line">  <span class="attribute">transition-delay</span>: <span class="number">0s</span>, <span class="number">0s</span>, <span class="number">0s</span>, <span class="number">0s</span>, <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别定义各过渡属性时，如果遇到值的长度不匹配的情况，将按照下面规则处理：</p>
<ul>
<li>如果 <code>transition-property</code> 长度比其他属性<strong>短</strong>时，无视其他属性多出来的值；</li>
<li>如果 <code>transition-property</code> 长度比其他属性<strong>长</strong>时，其他属性进行循环重复匹配。</li>
</ul>
<p>比如如果有下面的定义。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition-test1</span> &#123;</span><br><span class="line">  <span class="comment">/* the length of property is shorter than the duration */</span></span><br><span class="line">  <span class="attribute">transition-property</span>: background-color, width;</span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">1s</span>, <span class="number">0.25s</span>, <span class="number">0.25s</span>, <span class="number">1s</span>, <span class="number">0.25s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.transition-test2</span> &#123;</span><br><span class="line">  <span class="comment">/* the length of duration is shorter than the property */</span></span><br><span class="line">  <span class="attribute">transition-property</span>: background-color, width, height, border-radius, transform;</span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">1s</span>, <span class="number">0.25s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终将转换成以下的设置起效。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition-test1</span> &#123;</span><br><span class="line">  <span class="attribute">transition-property</span>: background-color, width;</span><br><span class="line">  <span class="comment">/* the parts that longer than property are truncated */</span></span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">1s</span>, <span class="number">0.25s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.transition-test2</span> &#123;</span><br><span class="line">  <span class="attribute">transition-property</span>: background-color, width, height, border-radius, transform;</span><br><span class="line">  <span class="comment">/* values are repeated to match the length */</span></span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">1s</span>, <span class="number">0.25s</span>, <span class="number">1s</span>, <span class="number">0.25s</span>, <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-JavaScript-时需要注意"><a href="#使用-JavaScript-时需要注意" class="headerlink" title="使用 JavaScript 时需要注意"></a>使用 JavaScript 时需要注意</h3><p>在下面操作之后<strong>立即</strong>修改过渡属性时，可能<strong>不会触发</strong>过渡动画：</p>
<ul>
<li>使用 <code>.appendChild()</code> 将元素添加到 DOM；</li>
<li>修改 <code>display: none;</code> 属性让元素显示时。</li>
</ul>
<p>原因在于修改过渡属性时元素的样式属性可能还未计算出来，这导致元素显示出来时已经是过渡结束的状态，其初始状态未被触发，所以也就不会发生过渡效果。规避这个限制的最简单方法是使用 <code>setTimeout()</code> 函数让过渡属性的修改延迟几毫秒，元素的初始状态将在这期间进行计算。</p>
<h3 id="检测-CSS-过渡效果的开始和结束"><a href="#检测-CSS-过渡效果的开始和结束" class="headerlink" title="检测 CSS 过渡效果的开始和结束"></a>检测 CSS 过渡效果的开始和结束</h3><p><code>TransitionEvent</code> 用来判断过渡动画的进行状态，浏览器会在过渡动画的执行阶段触发下面事件：</p>
<table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>transitioncancel</code></td>
<td>当 CSS 过渡动画被取消时触发</td>
</tr>
<tr>
<td><code>transitionend</code></td>
<td>当 CSS 过渡动画结束时触发</td>
</tr>
<tr>
<td><code>transitionrun</code></td>
<td>当 CSS 过渡动画被创建，并被放入执行队列时触发，此时动画可能尚未开始</td>
</tr>
<tr>
<td><code>transitionstart</code></td>
<td>当 CSS 过渡动画开始时触发</td>
</tr>
</tbody></table>
<p>同时 <code>TransitionEvent</code> 拥有下面属性：</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>.propertyName</code></td>
<td>包含过渡动画关联属性名称的 <code>DOMString</code></td>
</tr>
<tr>
<td><code>.elapsedTime</code></td>
<td>一个 <code>float</code> 表达过渡动画执行了多长时间，以秒为单位，不受延迟时间影响</td>
</tr>
<tr>
<td><code>.pseudoElement</code></td>
<td>如果过渡动画执行对象是一个伪类元素，则为 <code>::</code> 开头的伪类元素名称的 <code>DOMString</code>，否则为空字符串</td>
</tr>
</tbody></table>
<blockquote>
<p>鼠标悬停，或者点击 <code>start</code> 开始统计事件数据。</p>
</blockquote>
<div class="example-container flex-column">
  <div class="w-100 p-3 d-flex align-items-center justify-content-center position-relative" style="height: 150px">
    <div id="transitionTarget" class="example-def transition radius-hover" style="height: 50px; width: 50px; background-color: rgb(25,135,84)"></div>
    <span class="toggle position-absolute top-0 end-0 m-3 hover-pointer">start</span>
  </div>
  <div class="w-100 mb-3 d-flex flex-column align-items-center justify-content-center text-nowrap">
    <div>
      <div class="text-center fw-bold">Event Status</div>
      <span class="me-3">Transition State: <code id="transitionState">Unknown</code></span>
      <span>Elapsed Time: <code id="elapsedTime">Unknown</code></span>
    </div>
    <div>
      <div class="text-center fw-bold">Event Count</div>
      <code>transitioncancel: <span id="countCancel">0</span></code>
      <code>transitionend: <span id="countEnd">0</span></code><br>
      <code>transitionrun: <span id="countRun">0</span></code>
      <code>transitionstart: <span id="countStart">0</span></code>
    </div>
  </div>
</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#transitionTarget&quot;</span>);</span><br><span class="line">target.addEventListener(<span class="string">&quot;transitioncancel&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">target.addEventListener(<span class="string">&quot;transitionend&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">target.addEventListener(<span class="string">&quot;transitionrun&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">target.addEventListener(<span class="string">&quot;transitionstart&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="变换-transforms"><a href="#变换-transforms" class="headerlink" title="变换 transforms"></a>变换 transforms</h2><p>用下面的 Demo 尝试各种变换的效果，下面的设定可以修改，结果会实时反应到绿色方块上。你可以按 <code>reset</code> 按钮到默认状态。</p>
<style id="example-transform-style"></style>
<div class="example-container example-transform flex-wrap" style="min-height: 240px">
  <div class="control-panel d-flex flex-column highlight css my-3">
    <pre class="bg-transparent m-0"
      ><span class="line hover-pointer" contentEditable="true"
        ><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">120px</span>, <span class="hljs-number">50px</span>);</span
      ><span class="line hover-pointer" contentEditable="true"
        ><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0.5turn</span>);</span
      ><span class="line hover-pointer" contentEditable="true"
        ><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.3</span>);</span
      ><span class="line hover-pointer" contentEditable="true"
        ><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">skew</span>(<span class="hljs-number">30deg</span>, <span class="hljs-number">20deg</span>);</span
      ><span class="line hover-pointer" contentEditable="true"
        ><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">perspective</span>(<span class="hljs-number">500px</span>);</span
    ></pre>
  </div>
  <div class="demo-panel flex-grow-1 d-flex align-items-center justify-content-center mb-3">
    <div id="demo-transform" class="" style="height: 100px; width: 100px; background-color: rgb(25,135,84)"></div>
  </div>
  <span class="reset position-absolute top-0 end-0 m-3 mt-1 hover-pointer">reset</span>
</div>

<h3 id="定义变换属性"><a href="#定义变换属性" class="headerlink" title="定义变换属性"></a>定义变换属性</h3><p>用于定义变换效果的属性主要有 2 个。</p>
<h4 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a><code>transform-origin</code></h4><p>指定原点的位置，默认的位置是元素的中心点。这个属性对旋转、缩放和歪曲等变换效果有效果，因为这些效果需要基于一个点作为参数。</p>
<style id="example-transform-origin-style"></style>
<div class="example-container example-transform-origin flex-wrap" style="min-height: 240px">
  <div class="control-panel d-flex flex-column highlight css my-3">
    <pre class="bg-transparent m-0"
      ><span class="line hover-pointer" contentEditable="true" data-transform="rotate(30deg)" data-origin="top: 50%; left: 50%;"
        ><span class="hljs-attribute">transform-origin</span>: center;</span
      ><span class="line hover-pointer" contentEditable="true" data-transform="rotate(30deg)" data-origin="top: 0; left: 0;"
        ><span class="hljs-attribute">transform-origin</span>: top left;</span
      ><span class="line hover-pointer" contentEditable="true" data-transform="rotate(30deg)" data-origin="top: 20px; left: 50px;"
        ><span class="hljs-attribute">transform-origin</span>: 50px 20px;</span
      ><span class="line hover-pointer" contentEditable="true" data-transform="rotate3d(1, 2, 0, 60deg)" data-origin="top: 100%; left: 100%;"
        ><span class="hljs-attribute">transform-origin</span>: bottom right 60px;</span
      ><span class="line hover-pointer" contentEditable="true" data-transform="rotate(30deg)" data-origin="top: 100%; left: 0;"
        ><span class="hljs-attribute">transform-origin</span>: bottom left;</span
    ></pre>
  </div>
  <div class="demo-panel flex-grow-1 d-flex align-items-center justify-content-center mb-3">
    <div id="demo-transform-origin" class="" style=""></div>
  </div>
  <span class="reset position-absolute top-0 end-0 m-3 mt-1 hover-pointer">reset</span>
</div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* One value */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform-origin</span>: &lt;length&gt;|&lt;percentage&gt;|&lt;keyword&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Two values */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform-origin</span>: &lt;length&gt;|&lt;percentage&gt;|&lt;x-offset-keyword&gt;</span><br><span class="line">    &lt;length&gt;|&lt;percentage&gt;|&lt;y-offset-keyword&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Three values, the third value represents the z offset */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform-origin</span>: &lt;length&gt;|&lt;percentage&gt;|&lt;x-offset-keyword&gt;</span><br><span class="line">    &lt;length&gt;|&lt;percentage&gt;|&lt;y-offset-keyword&gt; &lt;length&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>0%</td>
<td>x-offset-keyword</td>
</tr>
<tr>
<td>center</td>
<td>50%</td>
<td>x-offset-keyword, y-offset-keyword</td>
</tr>
<tr>
<td>right</td>
<td>100%</td>
<td>x-offset-keyword</td>
</tr>
<tr>
<td>top</td>
<td>0%</td>
<td>y-offset-keyword</td>
</tr>
<tr>
<td>bottom</td>
<td>100%</td>
<td>y-offset-keyword</td>
</tr>
</tbody></table>
<h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a><code>transform</code></h4><p>变换属性让你旋转、缩放、歪曲或平移元素。变换属性只能应用在由 CSS 盒子模型控制的可变换元素。你可以只指定一个变换函数，也可以用空格分隔同时指定多个变换函数。</p>
<p>当你指定多个变换函数时构成组合变换 <code>Composition Transforms</code>，每个变换效果将根据<strong>从右到左</strong>的顺序依次应用。</p>
<p>指定多个变换函数时，你可以重复指定同一种函数，这些函数会按照上述顺序执行。请注意有些函数交换位置后不影响结果，但是其他的函数执行顺序至关重要。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Single function */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: &lt;transform-function&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiple functions */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: &lt;transform-function&gt; [&lt;transform-function&gt; ...];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-matrix"><a href="#transform-matrix" class="headerlink" title="transform: matrix"></a><code>transform: matrix</code></h4><p>均匀的 2D 变换矩阵。还有一个 3d 版本 <code>matrix3d</code> 在下文介绍。</p>
<blockquote>
<p><strong>NOTE! 注意！</strong></p>
<p>演示代码中定义了多个 <code>transform</code> 属性，但是实际使用中最后一个定义的变换效果会覆盖之前的定义，如果需要定义多个变换效果，请定义一个 <code>transform</code> 属性，用<strong>空格分隔变换函数</strong>赋值给它。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">matrix</span>(a, b, c, d, tx, ty);</span><br><span class="line">  <span class="comment">/* For each parameters the function at the same position will be applied */</span></span><br><span class="line">  <span class="comment">/* matrix(scaleX(), skewY(), skewX(), scaleY(), translateX(), translateY()) */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Equivalent to the below */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">matrix3d</span>(a, b, <span class="number">0</span>, <span class="number">0</span>, c, d, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, tx, ty, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This line will take effect */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">matrix</span>(<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">80</span>, <span class="number">80</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-translate"><a href="#transform-translate" class="headerlink" title="transform: translate"></a><code>transform: translate</code></h4><p>在 2d 平面平移元素。这个变换函数有几个变种函数。</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Parameters</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>translate()</code></td>
<td><code>&lt;length&gt;[, &lt;length&gt;]</code></td>
<td>在 2d 平面平移元素，如果纵轴没有给值则使用横轴的值</td>
</tr>
<tr>
<td><code>translate3d()</code></td>
<td><code>tx, ty, tz</code></td>
<td>在 3d 空间平移元素，3d 版本具体在下文介绍</td>
</tr>
<tr>
<td><code>translateX()</code></td>
<td><code>tx</code></td>
<td>在水平方向平移元素，等同 <code>translate(tx, 0)</code> 或 <code>translate3d(tx, 0, 0)</code></td>
</tr>
<tr>
<td><code>translateY()</code></td>
<td><code>ty</code></td>
<td>在垂直方向平移元素，等同 <code>translate(0, ty)</code> 或 <code>translate3d(0, ty, 0)</code></td>
</tr>
<tr>
<td><code>translateZ()</code></td>
<td><code>tz</code></td>
<td>围绕 z 轴平移元素，等同 <code>translate3d(0, 0, tz)</code></td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50%</span>);</span><br><span class="line">  <span class="comment">/* This line will take effect */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-scale"><a href="#transform-scale" class="headerlink" title="transform: scale"></a><code>transform: scale</code></h4><p>在 2d 平面缩放元素。这个变换函数有几个变种存在。</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Parameters</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>scale()</code></td>
<td><code>sx[, xy]</code></td>
<td>在 2d 平面缩放元素，如果纵轴没有给值则使用横轴的值</td>
</tr>
<tr>
<td><code>scale3d()</code></td>
<td><code>sx, sy, sz</code></td>
<td>在 3d 空间缩放元素，3d 版本具体在下文介绍</td>
</tr>
<tr>
<td><code>scaleX()</code></td>
<td><code>s</code></td>
<td>调整水平方向元素大小，等同 <code>scale(sx, 1)</code> 或 <code>scale3d(sx, 1, 1)</code></td>
</tr>
<tr>
<td><code>scaleY()</code></td>
<td><code>s</code></td>
<td>调整垂直方向元素大小，等同 <code>scale(1, sy)</code> 或 <code>scale3d(1, sy, 1)</code></td>
</tr>
<tr>
<td><code>scaleZ()</code></td>
<td><code>s</code></td>
<td>围绕 z 轴调整元素大小，等同 <code>scale3d(1, 1, sz)</code></td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">  <span class="comment">/* This line will take effect */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(-<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-rotate"><a href="#transform-rotate" class="headerlink" title="transform: rotate"></a><code>transform: rotate</code></h4><p>在 2d 平面围绕一个固定点旋转元素。这个变换函数有几个变种函数。</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Parameters</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>rotate()</code></td>
<td><code>&lt;angle&gt;</code></td>
<td>在 2d 平面围绕一个<strong>固定点</strong>旋转元素，固定点坐标由 <code>transform-origin</code> 定义</td>
</tr>
<tr>
<td><code>rotate3d()</code></td>
<td><code>x, y, z, &lt;angle&gt;</code></td>
<td>在 3d 空间围绕一个<strong>固定轴</strong>旋转元素，3d 版本具体在下文介绍</td>
</tr>
<tr>
<td><code>rotateX()</code></td>
<td><code>&lt;angle&gt;</code></td>
<td>围绕水平坐标轴旋转元素，等同 <code>rotate3d(1, 0, 0, a)</code></td>
</tr>
<tr>
<td><code>rotateY()</code></td>
<td><code>&lt;angle&gt;</code></td>
<td>围绕垂直坐标轴旋转元素，等同 <code>rotate3d(0, 1, 0, a)</code></td>
</tr>
<tr>
<td><code>rotateZ()</code></td>
<td><code>&lt;angle&gt;</code></td>
<td>围绕 z 轴旋转元素，等同 <code>rotate3d(0, 0, 1, a)</code></td>
</tr>
</tbody></table>
<p><code>&lt;angle&gt;</code> 单位定义。</p>
<table>
<thead>
<tr>
<th>Unit</th>
<th>Definition</th>
</tr>
</thead>
<tbody><tr>
<td><code>deg</code></td>
<td>单位 <code>度</code>，一整圈为 <code>360deg</code></td>
</tr>
<tr>
<td><code>grad</code></td>
<td>单位 <code>梯度</code>，一整圈为 <code>400grad</code></td>
</tr>
<tr>
<td><code>rad</code></td>
<td>单位 <code>弧度</code>，弧度一整圈为 2π，表示接近 <code>6.2832rad</code></td>
</tr>
<tr>
<td><code>turn</code></td>
<td>单位 <code>转</code>，一整圈为 <code>1turn</code></td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0.5turn</span>);</span><br><span class="line">  <span class="comment">/* This line will take effect */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">200grad</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-skew"><a href="#transform-skew" class="headerlink" title="transform: skew"></a><code>transform: skew</code></h4><p>在 2d 平面歪曲元素。这个变换函数有几个变种存在。歪曲函数的参数使用角度单位，与 <code>rotate</code> 一致。</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Parameters</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>skew()</code></td>
<td><code>ax[, ay]</code></td>
<td>在 2d 平面缩放元素，如果纵轴没有给值则使用横轴的值</td>
</tr>
<tr>
<td><code>skewX()</code></td>
<td><code>&lt;angle&gt;</code></td>
<td>在水平方向歪曲元素，等同 <code>skew(a)</code></td>
</tr>
<tr>
<td><code>skewY()</code></td>
<td><code>&lt;angle&gt;</code></td>
<td>在垂直方向歪曲元素</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>);</span><br><span class="line">  <span class="comment">/* This line will take effect */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>, <span class="number">60deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3D-变换属性"><a href="#3D-变换属性" class="headerlink" title="3D 变换属性"></a>3D 变换属性</h3><p>3d 空间的变换效果相对 2d 平面来说参数和概念上复杂很多，并且使用场景差别较大，这一部分我们单独拿出来讨论。</p>
<h4 id="transform-matrix3d"><a href="#transform-matrix3d" class="headerlink" title="transform: matrix3d"></a><code>transform: matrix3d</code></h4><p>均匀的 <code>4 x 4</code> 的 3d 变换矩阵。矩阵变换是 <code>transform</code> 属性实现的基础，所有其他变换函数都是在计算完结果之后应用矩阵变换实现的。</p>
<p>换言之，所有变换效果都有一个与之对应的矩阵变换的写法。对于一般效果而言，使用对应的变换函数是最方便的，但是对于组合变换也难以实现的变换效果来说，就需要用到矩阵变换来实现。</p>
<p>下面是 3d 矩阵变换的参数定义，详细探索以后有机会再具体探讨。</p>
<!-- prettier-ignore-start -->
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">matrix3d</span>(</span><br><span class="line">    a1, b1, c1, d1,</span><br><span class="line">    a2, b2, c2, d2,</span><br><span class="line">    a3, b3, c3, d3,</span><br><span class="line">    a4, b4, c4, d4</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<h4 id="transform-translate3d"><a href="#transform-translate3d" class="headerlink" title="transform: translate3d"></a><code>transform: translate3d</code></h4><p>在 3d 空间平移元素。3d 的元素平移变换相对 2d 版本并没有复杂多少，接受 3 个向量作为横轴、纵轴和 z 轴方向上的移动量。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">/* This line will take effect */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">42px</span>, -<span class="number">662px</span>, -<span class="number">125px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-scale3d"><a href="#transform-scale3d" class="headerlink" title="transform: scale3d"></a><code>transform: scale3d</code></h4><p>在 3d 空间缩放元素。这个变换也接收 3 个向量，分别作为横轴、纵轴和 z 轴的缩放量。如果 3 个向量的值相等，则元素将按照等比在 3d 空间缩放。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="comment">/* 这两个定义将等比缩放 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(<span class="number">1.3</span>, <span class="number">1.3</span>, <span class="number">1.3</span>);</span><br><span class="line">  <span class="comment">/* 下面的定义不是等比缩放 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(<span class="number">0.5</span>, <span class="number">1.4</span>, <span class="number">0.8</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(-<span class="number">1.4</span>, <span class="number">0.5</span>, <span class="number">0.7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-rotate3d"><a href="#transform-rotate3d" class="headerlink" title="transform: rotate3d"></a><code>transform: rotate3d</code></h4><p>在 3d 空间围绕一个<strong>固定轴</strong>旋转元素。3d 空间的旋转相比复杂一点。</p>
<p>在 3d 空间旋转一个元素存在 3 个方向的自由度，由三个向量组成的 3d 坐标 <code>[x, y, z]</code> 和 <code>transform-origin</code> 原点连成一条直线构成 3d 旋转的转轴。</p>
<blockquote>
<p>如果指定的向量未<strong>标准化</strong>（<code>normalized</code>，比如 3 个坐标值的平方和为 <code>1</code>），浏览器会代为进行标准化。但是如果指定的值无法进行标准化，比如指定了 <code>[0, 0, 0]</code>，则旋转会被无视，但是不会导致整个 CSS 属性失效。</p>
<p>另外，2d 平面上的元素旋转应用的顺序不会影响其效果，但是通常 3d 空间的旋转不同，其会根据应用的顺序不同，从而产生不同的效果。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate3d</span>(x, y, z, a);</span><br><span class="line">  <span class="comment">/* Examples */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate3d</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">30deg</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate3d</span>(<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0.5turn</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-perspective"><a href="#transform-perspective" class="headerlink" title="transform: perspective"></a><code>transform: perspective</code></h4><p>透视变换，设定用户与 <code>z=0</code> 平面的距离。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> perspective demo with CSS cube */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">800px</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">23rem</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions">Using CSS transitions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transforms/Using_CSS_transforms">Using CSS transforms</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transition">transition</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform">transform</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent">TransitionEvent</a></li>
</ul>
<!-- Resources used by only this post -->
<style>
.transition {
  cursor: pointer;
  transition: all .25s ease;
  border-radius: 0;
}
.transition-multiple {
  transition: background-color 1s ease, width .25s ease, height .25s ease, border-radius 1s ease, transform .25s ease-in-out;
}
.radius-hover:hover {
  border-radius: 50%!important;
}
.hover-pointer {
  cursor: pointer;
}
.example-container .line {
  display: block;
  margin: 2px 0;
  padding: 5px;
  width: 370px;
  border-left: 4px transparent solid;
  border-bottom: 1px transparent solid;
  overflow: auto;
}
.example-container .line.active {
  border-color: #198754;
}
.example-container .line:focus {
  outline: none;
}

#demo-transform-multiple,
#demo-transform {
  transition: all .25s ease;
}
#demo-transform-origin {
  position: relative;
  border: 3px dashed #dc3545;
  height: 106px;
  width: 106px;
  border-radius: 2px;
}
#demo-transform-origin::before {
  transform: rotate(0);
  content: 'ROTATE ME';
  color: white;
  line-height: 100px;
  text-align: center;
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 100%;
  background-color: rgb(25, 135, 84);
  z-index: -1;
}
#demo-transform-origin::after {
  content: ' ';
  width: 5px;
  height: 5px;
  position: absolute;
  background-color: white;
  border-radius: 50%;
  padding: 3px;
  border: 3px solid #dc3545;
  transform: translate(-50%, -50%);
}
</style>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
<script>
$(function(){
  // example-def start
  const $def = $('.example-def')
  let states = [
    {'background-color': '#d63384',
     'width': '50px', 'height': '100px',
     'transform': 'rotate(.1turn)', 'border-radius': '100%'},
    {'background-color': '#0d6efd',
     'width': '45px', 'height': '45px',
     'transform': 'rotate(.5turn)', 'border-radius': '50%'},
    {'background-color': '#ffc107',
     'width': '100px', 'height': '60px',
     'transform': 'rotate(.6turn)', 'border-radius': '50%'},
    {'background-color': 'rgb(25,135,84)',
     'width': '50px', 'height': '50px',
     'transform': 'rotate(1turn)', 'border-radius': '0%'},
  ]
  let state = 0
  const anime = () => setInterval(() => {
    const curr = states[state++ % 4]
    Object.keys(curr).forEach(key => {
      $def.css(key, curr[key])
    })
  }, 1000)
  let timer = null
  // let timer = anime()
  const toggle = $('.example-container .toggle')
  toggle.click(function () {
    if ($(this).text() === "stop") {
      clearInterval(timer)
      toggle.text('start')
    } else {
      timer = anime()
      toggle.text('stop')
    }
  })
  // example-def end
  // example-event start
  let cancel = 0, run = 0, end = 0, start = 0
  const target = $('#transitionTarget'),
    transitionState = $('#transitionState'),
    elapsedTime = $('#elapsedTime'),
    countCancel = $('#countCancel'),
    countEnd = $('#countEnd'),
    countRun = $('#countRun'),
    countStart = $('#countStart'),
    count = {
      'Cancelled': () => countCancel.text(++cancel),
      'Ended': () => countEnd.text(++end),
      'Run': () => countRun.text(++run),
      'Started': () => countStart.text(++start),
    },
    record = name => e => {
      // console.log(e)
      transitionState.text(name)
      elapsedTime.text(e.originalEvent.elapsedTime)
      count[name]()
    }
  target.on('transitioncancel', record('Cancelled'))
  target.on('transitionend', record('Ended'))
  target.on('transitionrun', record('Run'))
  target.on('transitionstart', record('Started'))
  // example-event end
  // example-transform start
  ;(function() {
    const lines = $('.example-transform .line'),
      transformStyles = $('#example-transform-style')
    lines.each(function(){
      $(this).data('bk', $(this).html())
    })
    lines.click(function() {
      lines.removeClass('active')
      $(this).addClass('active')
      transformStyles.html(`.example-transform #demo-transform {${$(this).text()}}`)
    })
    lines.on('input', function() {
      transformStyles.html(`.example-transform #demo-transform {${$(this).text()}}`)
    })
    $('.example-transform .reset').click(() => lines.each(function() {
      lines.removeClass('active')
      $(this).html($(this).data('bk'))
      transformStyles.html('')
    }))
  })()
  // example-transform end
  // example-transform-origin start
  ;(function() {
    const lines = $('.example-transform-origin .line'),
      transformStyles = $('#example-transform-origin-style')
    lines.each(function(){
      $(this).data('bk', $(this).html())
    })
    lines.click(function() {
      lines.removeClass('active')
      transformStyles.html('')
      $(this).addClass('active')
      setTimeout(()=>
      transformStyles.html(`#demo-transform-origin::before {${$(this).text()}} #demo-transform-origin::after {${$(this).data('origin')}}`)
      ,10)
      setTimeout(()=>
      transformStyles.html(`#demo-transform-origin::before {transition: all .75s ease;${$(this).text()}transform: ${$(this).data('transform')}!important;} #demo-transform-origin::after {${$(this).data('origin')}}`)
      ,100)
    })
    lines.on('input', function() {
      transformStyles.html(`#demo-transform-origin::before {transition: all .75s ease;${$(this).text()}transform: ${$(this).data('transform')}!important;} #demo-transform-origin::after {${$(this).data('origin')}}`)
    })
    $('.example-transform-origin .reset').click(() => lines.each(function() {
      lines.removeClass('active')
      $(this).html($(this).data('bk'))
      transformStyles.html('')
    }))
  })()
  // example-transform-origin end
  // example-transform-multiple start
  ;(function() {
    const lines = $('.example-transform-multiple .line'),
      transformStyles = $('#example-transform-multiple-style')
    lines.each(function(){
      $(this).data('bk', $(this).html())
    })
    lines.click(function() {
      lines.removeClass('active')
      $(this).addClass('active')
      transformStyles.html(`.example-transform-multiple #demo-transform-multiple {${$(this).text()}}`)
    })
    lines.on('input', function() {
      transformStyles.html(`.example-transform-multiple #demo-transform-multiple {${$(this).text()}}`)
    })
    $('.example-transform-multiple .reset').click(() => lines.each(function() {
      lines.removeClass('active')
      $(this).html($(this).data('bk'))
      transformStyles.html('')
    }))
  })()
  // example-transform-multiple end
})
</script>
]]></content>
      <categories>
        <category>study</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
