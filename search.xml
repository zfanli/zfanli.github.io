<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1004. Max Consecutive Ones III (Medium)</title>
    <url>/post/leetcode/1004-Max-Consecutive-Ones-III-Medium/</url>
    <content><![CDATA[<p>给定一个二进制数组 <code>nums</code>（元素的值为 <code>0</code> 或 <code>1</code>），求最长的连续的 <code>1</code> 的长度。</p>
<p>有趣的地方在于你有 <code>k</code> 次机会将 <code>0</code> 翻转为 <code>1</code>，你需要找出最合适的时机使用这些机会。</p>
<p>“连续”是这道题的关键字，看上去我们可以使用滑动窗口来解决这道题。</p>
<span id="more"></span>

<h2 id="思路-1，滑动窗口"><a href="#思路-1，滑动窗口" class="headerlink" title="思路 1，滑动窗口"></a>思路 1，滑动窗口</h2><p>提示说的很清楚，题目要求找出最长的连续出现的 <code>1</code>，那么用 2 个指针实现一个滑动窗口是一个合适的选择。</p>
<p>用一个数组储存所有遇到 <code>0</code> 的位置，当数组长度超过 <code>k</code>，将左边指针设为第一个 <code>0</code> 位置的下一位，并将第一个 <code>0</code> 从数组删除。</p>
<p>每一步都保存一下当前连续的最大值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, i, zeros = <span class="number">0</span>, <span class="number">0</span>, []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] == <span class="number">0</span>:</span><br><span class="line">                zeros.append(j)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(zeros) &gt; k:</span><br><span class="line">                    i = zeros.pop(<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, j - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，滑动窗口-内存优化"><a href="#思路-2，滑动窗口-内存优化" class="headerlink" title="思路 2，滑动窗口+内存优化"></a>思路 2，滑动窗口+内存优化</h2><p>我们可以优化思路 1 的数组方法，仅使用一个计数器来提醒我们是否需要将左边的指针移动到下一个位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">while</span> nums[i] != <span class="number">0</span>:</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, j - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
        <tag>Sliding Window</tag>
        <tag>Prefix Sum</tag>
      </tags>
  </entry>
  <entry>
    <title>101. Symmetric Tree (Easy)</title>
    <url>/post/leetcode/101-Symmetric-Tree-Easy/</url>
    <content><![CDATA[<p>检查给定的二叉树是否对称。如果 root 的左右子树互为镜像，那么这棵树是一棵对称树。</p>
<p>这道题实际上需要我们同时遍历两棵树，来判断它们是否对称。</p>
<p>我们尝试从递归、迭代以及 DFS 和 BFS 等角度来尝试解决这道题。</p>
<span id="more"></span>

<h2 id="思路-1，递归，"><a href="#思路-1，递归，" class="headerlink" title="思路 1，递归，"></a>思路 1，递归，</h2><p>Top-Down 做法。</p>
<p>实际上我们需要对两棵子树同时进行前序遍历，而要确认它们是否对称，需要我们对遍历顺序做一点修改：</p>
<ul>
<li>左子树：root -&gt; left -&gt; right</li>
<li>右子树：root -&gt; right -&gt; left</li>
</ul>
<p>由于遍历过程是同步的，在每一次遍历中我们都要进行下面的操作以确定当前是否依然对称：</p>
<ul>
<li>当前 2 个节点的值是否相等；</li>
<li>左左节点和右右节点是否相等；</li>
<li>左右节点和右左节点是否相等。</li>
</ul>
<p>上述步骤中从上至下，一旦遇到 False，程序就会一步一步退出递归流程，给出结果。</p>
<p>这是一个 DFS 算法，我们会一条路径一条路径的检查整棵树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            <span class="comment"># if one of the nodes does not exist</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">return</span> left == right</span><br><span class="line">            <span class="comment"># if nodes are not equal</span></span><br><span class="line">            <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># check their children symmetrically</span></span><br><span class="line">            <span class="keyword">return</span> dfs(left.left, right.right) <span class="keyword">and</span> dfs(left.right, right.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root.left, root.right)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，迭代"><a href="#思路-2，迭代" class="headerlink" title="思路 2，迭代"></a>思路 2，迭代</h2><p>使用 Stack 数据结构，我们可以把递归过程改成迭代过程。</p>
<p>和递归过程每次传递 2 个参数类似，迭代过程我们用 Stack 每次保存俩个需要对比的节点。</p>
<p>与递归过程的差异体现在 False 的处理，迭代过程中一旦遇到失败的情况，我们可以直接返回结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        stack = [[root.left, root.right]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            left, right = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.append([left.left, right.right])</span><br><span class="line">            stack.append([left.right, right.left])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="思路-3，BFS"><a href="#思路-3，BFS" class="headerlink" title="思路 3，BFS"></a>思路 3，BFS</h2><p>不同的算法针对不同的数据存在不同的效率。如果两棵树的层级数不同，或者靠下层的数据出现差异时，使用 DFS 是高效的，因为每次我们会遍历一整条路径，一旦层级和叶子节点有差异，我们可以快速得到结果并结束程序。</p>
<p>另一方面，如果两棵树的结构没有差异，数据的差异可能出现在树的中段位置，那么相对来说 BFS 会更加高效。</p>
<p>从我提交的结果来看，目前这道题的测试数据是偏向于 BFS 的，Python3 实现的 BFS 平均在 24ms 左右，而 DFS 在 36ms 左右。</p>
<p>下面是 BFS 实现的思路，与之前相同，我们同时遍历两棵树，仅在遍历顺序上做出一点修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        ltree, rtree = [root.left], [root.right]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ltree <span class="keyword">and</span> rtree:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(ltree) != <span class="built_in">len</span>(rtree):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ltree)):</span><br><span class="line">                left, right = ltree.pop(<span class="number">0</span>), rtree.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                ltree.append(left.left)</span><br><span class="line">                ltree.append(left.right)</span><br><span class="line">                rtree.append(right.right)</span><br><span class="line">                rtree.append(right.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>102. Binary Tree Level Order Traversal (Medium)</title>
    <url>/post/leetcode/102-Binary-Tree-Level-Order-Traversal-Medium/</url>
    <content><![CDATA[<p>遍历树的方式除了通常的前序遍历、中序遍历和后序遍历之外，还有本题的层序遍历。</p>
<p>层序遍历的顺序是从左到右依次遍历同层级到节点，然后在进入下一层级重复这个过程，直到不再存在下一层级。这是一个典型的宽度优先搜索（BFS）算法。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>完成层序遍历，我们可以利于先进先出的队列来记录每一个层级的节点数。</p>
<p>具体过程如下：</p>
<ul>
<li>将 root 放入队列，开始进入迭代；</li>
<li>每次迭代开始先取得队列的长度，这个长度表示当前层级的节点数；</li>
<li>循环依次取出所有当前层级的节点，将其子节点按照左右顺序放入队列，并将当前节点的值存入新的列表；</li>
<li>将列表放入答案列表，重复迭代直到队列清空。</li>
</ul>
<p>需要注意的一点是，虽然我们在放入子节点的时候会进行存在判定，但是 root 本身也存在为空（None）的情况，下面代码中我们新建了一个 Dummy 节点来处理这个问题，将 root 作为 Dummy 节点的子节点，然后在放入子节点的过程中进行存在判定，这样就规避了 root 节点本身不存在的问题。</p>
<p>最终在返回结果时，将位于数组 0 位置的 Dummy 节点的值删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        ans, queue = [], [TreeNode(-<span class="number">1</span>, root)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            lst, n = [], <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                lst.append(node.val)</span><br><span class="line">            ans.append(lst)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>

<hr>
<p>bk，旧思路，这个方法会额外创建 log n 个新数组，这个额外空间其实没有必要。</p>
<ul>
<li>同级的元素全都放到一个数组；</li>
<li>按照顺序提取元素的值放到答案数组；</li>
<li>同时将存在的子节点放到新的数组；</li>
<li>重复这个过程直到不存在任何子节点；</li>
<li>此时答案数组已经编辑完成。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        ans, lv = [], [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(lv) != <span class="number">0</span>:</span><br><span class="line">            _ans, _lv = [], []</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> lv:</span><br><span class="line">                <span class="keyword">if</span> n:</span><br><span class="line">                    _ans.append(n.val)</span><br><span class="line">                    _lv.append(n.left)</span><br><span class="line">                    _lv.append(n.right)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(_ans) &gt; <span class="number">0</span>:</span><br><span class="line">                ans.append(_ans)</span><br><span class="line">            lv = _lv</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>BFS</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>104. Maximum Depth of Binary Tree (Easy)</title>
    <url>/post/leetcode/104-Maximum-Depth-of-Binary-Tree-Easy/</url>
    <content><![CDATA[<p>求二叉树的最大深度。二叉树的深度指的是其节点的最大层数。</p>
<p>这是一道简单题，但是可以视作是 Top-Down 和 Bottom-Up 方法的教学题。</p>
<p>我们应用 DFS 来处理之道题，来看看自上而下与自下而上方法的区别。</p>
<span id="more"></span>

<h2 id="思路-1，Top-Down，递归"><a href="#思路-1，Top-Down，递归" class="headerlink" title="思路 1，Top-Down，递归"></a>思路 1，Top-Down，递归</h2><p>在递归过程中，我们先根据当前层的深度更新结果，然后针对子节点进行递归调用，重复这个过程直到遍历完整棵树。这是从上至下的解题方法，顺序体现在我们何时处理当前节点的值。</p>
<p>这个思路可以解决问题，但是从逻辑上来说，如果存在子节点，那么当前节点的深度肯定不是最终答案，Top-Down 方法或许不是最符合这道题目逻辑的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">node, depth</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, depth)</span><br><span class="line">            traverse(node.left, depth + <span class="number">1</span>)</span><br><span class="line">            traverse(node.right, depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        traverse(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，Bottom-Up，递归"><a href="#思路-2，Bottom-Up，递归" class="headerlink" title="思路 2，Bottom-Up，递归"></a>思路 2，Bottom-Up，递归</h2><p>在从下至上的方法中，我们先去计算以当前节点开始其子节点的最大深度，在结果的基础上 +1 作为当前节点的深度结束递归过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(traverse(node.left),</span><br><span class="line">                           traverse(node.right))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> traverse(root)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>1047. Remove All Adjacent Duplicates In String (Easy)</title>
    <url>/post/leetcode/1047-Remove-All-Adjacent-Duplicates-In-String-Easy/</url>
    <content><![CDATA[<p>给定一个由英文小写字母组成的字符串 <code>s</code>，要求去重并返回结果。去重的条件是 2 个字符必须接邻且相等。</p>
<p>这道题的难点在于去重之后的字符串可能会产生新的重复。使用 Stack 可以方便的解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用 Stack 依次确认每一个字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] == c:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>1048. Longest String Chain (Medium)</title>
    <url>/post/leetcode/1048-Longest-String-Chain-Medium/</url>
    <content><![CDATA[<p>给定一个由英文小写字母组成的字符串数组 <code>words</code>，你需要从中挑选单词构成满足下面定义的词汇链（word chain），找到能构成的最长词汇链，返回其长度。</p>
<ul>
<li>词汇链（word chain）指一个字符串数组中，每个字符串都是后一个字符串的前置（predecessor），如果数组只有一个字符串，这个词汇链长度为 <code>1</code>；</li>
<li>前置（predecessor）指一个字符串 A 满足仅向其中添加一个字符可以构成字符串 B 的条件，此时字符串 A 称之为字符串 B 的前置。<ul>
<li>比如 <code>&quot;abc&quot;</code> 是 <code>&quot;abac&quot;</code> 的前置, 而 <code>&quot;cba&quot;</code> 不是 <code>&quot;bcad&quot;</code> 的前置。</li>
</ul>
</li>
</ul>
<p>我们用 DFS 和 DP 两个思路解决这个问题。</p>
<span id="more"></span>

<h2 id="思路-1，hash-table-memoization"><a href="#思路-1，hash-table-memoization" class="headerlink" title="思路 1，hash table + memoization"></a>思路 1，hash table + memoization</h2><p>明确一下要找出最长的链，我们需要完成下面的步骤才能最终确认：</p>
<ul>
<li>遍历所有 word，找到所有可能的 predecessor</li>
<li>遍历所有的 predecessor，找到它的所有可能的 predecessor；如此反复</li>
</ul>
<p>我们可以观察到如果有两个词找到同一个词能作为它的 predecessor，这个被找到的对象就发生了重复计算。我们可以用 memoization 解决这个问题。</p>
<p>此外，寻找 predecessor 的过程也可以用 Hash Table 来进行加速。具体的做法是，我们使用一个 Map 来做 memoization，用 word 作为 key，value 储存它的 predecessor 的数量。</p>
<p>针对每一个词，我们枚举出它的所有可能的 predecessor，到 Hash 表中进行匹配，如果值在表中存在则用这个词继续进行枚举过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestStrChain</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            memo[w] = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">w</span>):</span></span><br><span class="line">            <span class="keyword">if</span> memo[w] != -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> memo[w]</span><br><span class="line">            c = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w)):</span><br><span class="line">                _w = w[:i] + w[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> _w <span class="keyword">in</span> memo:</span><br><span class="line">                    c = <span class="built_in">max</span>(c, dfs(_w))</span><br><span class="line">            memo[w] = c + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> memo[w]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            dfs(w)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(memo)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(memo.values())</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，DP"><a href="#思路-2，DP" class="headerlink" title="思路 2，DP"></a>思路 2，DP</h2><p>思路 1 的非递归版本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestStrChain</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        words.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x))</span><br><span class="line">        dp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            c = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w)):</span><br><span class="line">                _w = w[:i] + w[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> _w <span class="keyword">in</span> dp:</span><br><span class="line">                    c = <span class="built_in">max</span>(c, <span class="number">1</span> + dp[_w])</span><br><span class="line">            dp[w] = c</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp.values())</span><br></pre></td></tr></table></figure>

<p>此外还有按长度分组 Hash 等方法，但性能上比上面两个思路没有优势，逻辑还更加复杂了，就不讨论了。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
        <tag>Hash Table</tag>
        <tag>Two Pointers</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</title>
    <url>/post/leetcode/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium/</url>
    <content><![CDATA[<p><code>No.106</code> 的镜像问题。你需要从一棵树的<code>前序遍历</code>数据和<code>中序遍历</code>数据中尝试重新构建出这棵二叉树。</p>
<p>之前我们尝试基于<code>中序遍历</code>和<code>后序遍历</code>的数据来还原这棵树，这次是<code>前序遍历</code>和<code>中序遍历</code>。</p>
<p>其中区别在于遍历结果中根节点是在开始还是在结束，我们可以应用相同的思路来解决这道题，注意处理顺序的细微差别。</p>
<span id="more"></span>

<h2 id="思路-1，递归-哈希表"><a href="#思路-1，递归-哈希表" class="headerlink" title="思路 1，递归 + 哈希表"></a>思路 1，递归 + 哈希表</h2><p>同样的思路，我们基于前序遍历的数据构建树，用中序遍历的数据确认节点的位置关系。</p>
<ul>
<li><code>前序遍历</code>：根节点、左节点、右节点</li>
<li><code>中序遍历</code>：左节点、根节点、右节点</li>
</ul>
<p>将构建树的问题分解为在知道根节点的情况下判断它是否有左右节点的问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        inordermap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inorder)):</span><br><span class="line">            inordermap[inorder[i]] = i</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">start, end</span>):</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            node = TreeNode(preorder.pop(<span class="number">0</span>))</span><br><span class="line">            middle = inordermap[node.val]</span><br><span class="line">            node.left = dfs(start, middle - <span class="number">1</span>)</span><br><span class="line">            node.right = dfs(middle + <span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，递归，无哈希表"><a href="#思路-2，递归，无哈希表" class="headerlink" title="思路 2，递归，无哈希表"></a>思路 2，递归，无哈希表</h2><p>我们可以采取遍历检查的方法，用元素的相对位置来做到思路 1 的判断。</p>
<p>在思路 1 中，实际起作用的关键代码是 <code>if start &gt; end:</code>，如果下一个节点的值落在这个区间之内则表示其为左节点 or 右节点。</p>
<p>但实际上我们不关注这个值具体是什么，来换个角度考虑一下：</p>
<ul>
<li>我们先从前序遍历结果中取出第一个值，构建一个节点；</li>
<li>接着我们需要判断前序遍历结果第二个值是否是第一个值的左节点；<ul>
<li>将前序遍历第二个值与中序遍历的第一个值对比；</li>
<li>如果两个值不相等，由于中序遍历先左节点在根节点的顺序，据此可以判断出存在左节点；</li>
<li>而如果两个值相等，那么也就没有左节点存在的空间；</li>
<li>对于存在左节点的情况，我们继续重复这个递归过程；</li>
</ul>
</li>
<li>这时已经判断完左节点；</li>
<li>我们要额外的信息来判断右节点是否存在；<ul>
<li>我们从左到右对中序遍历进行递归遍历；</li>
<li>要知道有没有右节点，首先我们要知道检查到哪个位置为止；</li>
<li>这个位置即边界，要确定这个边界，首先要确定当前有没有父节点；</li>
<li>如果当前没有父节点，这是树的根节点，尝试构建右节点；</li>
<li>如果存在父节点，判断父节点的值是否和前序遍历下一个值相等；</li>
<li>如果相等，我们已到达边界，不存在任何右节点；</li>
<li>如果不相等，还未到达边界，尝试构建右节点；</li>
<li>这里还有一个重要的细节，如果决定父节点？<ul>
<li>首先递归入口有两处：构建左节点和构建右节点时；</li>
<li>构建左节点时：中序遍历当前节点往左都是其左节点，所以当前节点是边界；</li>
<li>构建右节点时：中序遍历当前节点到父节点为止的区间是右节点，所以父节点是边界；</li>
</ul>
</li>
</ul>
</li>
<li>这时遍历完了右节点，当前节点遍历结束；</li>
<li>返回当前节点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        self.indexpre = self.indexin = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">parent</span>):</span></span><br><span class="line">            <span class="keyword">if</span> self.indexin == <span class="built_in">len</span>(inorder):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            node = TreeNode(preorder[self.indexpre])</span><br><span class="line">            self.indexpre += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># if current pre value != current in value,</span></span><br><span class="line">            <span class="comment"># the left child exists</span></span><br><span class="line">            <span class="keyword">if</span> node.val != inorder[self.indexin]:</span><br><span class="line">                node.left = dfs(node)</span><br><span class="line"></span><br><span class="line">            self.indexin += <span class="number">1</span></span><br><span class="line">            <span class="comment"># we&#x27;ve come to the right side,</span></span><br><span class="line">            <span class="comment"># if there&#x27;re more nodes exist before the parent node,</span></span><br><span class="line">            <span class="comment"># the right child exists</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> parent <span class="keyword">or</span> parent.val != inorder[self.indexin]:</span><br><span class="line">                node.right = dfs(parent)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，迭代"><a href="#思路-3，迭代" class="headerlink" title="思路 3，迭代"></a>思路 3，迭代</h2><p>思路 2 可以从递归逻辑转化成迭代逻辑，由于同样逻辑递归算法存在调用栈，算上其使用的额外空间后，对内存空间的使用要高于迭代算法，所以对递归算法的优化可以考虑能否将其转化为迭代算法。</p>
<p>和递归方法不同，在迭代版本中我们使用一个 Stack 来管理当前处理的节点。使用 Stack 的目的是管理当前还未遍历完的节点，这一步相当于将递归过程扁平化了。我们在便利根节点的做节点时，发现左节点有自己的左节点，所以我们将其放入栈中，先处理左节点自己的左节点，然后将其丢出栈，继续往后处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        indexpre, indexin = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        stack, parent = [root], <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>].val == inorder[indexin]:</span><br><span class="line">                parent = stack.pop()</span><br><span class="line">                indexin += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> indexin == <span class="built_in">len</span>(inorder):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            node = TreeNode(preorder[indexpre])</span><br><span class="line">            indexpre += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> parent:</span><br><span class="line">                parent.right = node</span><br><span class="line">            <span class="keyword">elif</span> stack:</span><br><span class="line">                stack[-<span class="number">1</span>].left = node</span><br><span class="line"></span><br><span class="line">            stack.append(node)</span><br><span class="line">            parent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Tree</tag>
        <tag>Binary Tree</tag>
        <tag>Hash Table</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</title>
    <url>/post/leetcode/106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Medium/</url>
    <content><![CDATA[<p>你需要从一棵树的<code>中序遍历</code>数据和<code>后序遍历</code>数据中尝试重新构建出这棵二叉树。</p>
<p>要从树的遍历结果逆向还原这棵树，扁平的 1D 数组的信息量是不够的，但是如果有两个不同的遍历结果做参考，我们可以根据树的遍历过程进行逆向操作。</p>
<p>这道题是使用已知的<code>中序遍历</code>和<code>后序遍历</code>的结果来尝试逆向遍历树的过程。</p>
<span id="more"></span>

<h2 id="思路-1，递归"><a href="#思路-1，递归" class="headerlink" title="思路 1，递归"></a>思路 1，递归</h2><p>已知给定的两组数据的排序方式是中序遍历和后序遍历。</p>
<ul>
<li><code>中序遍历</code>：左节点 -&gt; 根节点 -&gt; 右节点</li>
<li><code>后序遍历</code>：左节点 -&gt; 右节点 -&gt; 根节点</li>
</ul>
<p>在知道根节点的情况比较容易去构建一棵二叉树，所以我们以后序遍历的数据为基础进行树的构建。</p>
<p>但是后序遍历的数据无法告诉我们下一个节点是根节点的左节点还是右节点，这时我们需要到中序遍历的数据中进行检查，如果下一个节点在中序遍历中出现在根节点的左侧，则它是根节点的左节点，反之则是根节点的右节点。</p>
<p>递归过程中，一旦我们明确如何寻找根节点和其左右节点，重复这个过程我们就可以构建整棵树。我们给这个思路补充一些细节：</p>
<ul>
<li>我们要依序检查中序遍历中每个值的下标，为了避免重复计算，我们将中序遍历的值和下标放到一张哈希表，方便下标查询；</li>
<li>根据后序遍历的特性，我们从后序遍历数据的末尾取出（<code>pop</code>）一个值，构建一个节点；</li>
<li>找到根节点的值在中序遍历中的下标位置 <code>middle</code>，这时我们得到两个区间 <code>[start, middle - 1]</code> 和 <code>[middle + 1, end]</code>：<ul>
<li><code>[middle + 1, end]</code>：这个区间构成根节点的右子树，如果存在，我们继续依序从后序遍历数据中取出（<code>pop</code>）下一个根节点的值，细分区间直到遍历完这个区间；</li>
<li><code>[start, middle - 1]</code>：这个区间构成根节点的左子树，按照顺序，右节点遍历结束后，剩下的数据将构成左节点；</li>
</ul>
</li>
<li>我们按照中序遍历数据的下标位置来判断是否还存在下一个节点，如果 <code>middle</code> 和起始位置或结束位置重合则相应的左节点和右节点不存在。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        idx = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># make a hash table to map each value with its index,</span></span><br><span class="line">        <span class="comment"># just for reducing the cost of the index searching</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inorder)):</span><br><span class="line">            idx[inorder[i]] = i</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">start, end</span>):</span></span><br><span class="line">            <span class="comment"># fail case</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="comment"># build root node</span></span><br><span class="line">            node = TreeNode(postorder.pop())</span><br><span class="line">            <span class="comment"># find the middle point</span></span><br><span class="line">            middle = idx[node.val]</span><br><span class="line">            <span class="comment"># build right subtree if exists</span></span><br><span class="line">            node.right = dfs(middle + <span class="number">1</span>, end)</span><br><span class="line">            <span class="comment"># build left subtree if exists</span></span><br><span class="line">            node.left = dfs(start, middle - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，递归，无哈希表"><a href="#思路-2，递归，无哈希表" class="headerlink" title="思路 2，递归，无哈希表"></a>思路 2，递归，无哈希表</h2><p>思路 1 使用一个哈希表做下标映射，实际上这个额外的空间使用存在优化的空间。</p>
<p>在思路 2 中我们使用 2 个指针来对当前的处理进行判断。这个方法和思路 1 还有一点不同，这次我们不再直接修改参数数组。</p>
<ul>
<li>初始化 2 个指针，分别指向中序遍历和后序遍历最后一个值；</li>
<li>在递归过程中，首先拿到后序遍历当前指向的值构建根节点；</li>
<li>将后序遍历指针向前推进一个单位；</li>
<li>判断是否存在右子树：<ul>
<li>根据后序遍历的顺序，我们从后往前推进，构建根节点之后首先要判断是否存在右子树；</li>
<li>根据中序遍历的顺序，如果我们判断中序遍历数据的当前位置不等于目前节点值，则表示存在右子树；</li>
<li>如果存在右子树则进行递归调用，注意右子树在中序遍历中的边界是当前节点；</li>
</ul>
</li>
<li>执行到这里表示右子树已经遍历完成，将中序遍历的指针向前推进一个单位；</li>
<li>判断是否存在左子树：<ul>
<li>判断左子树要考虑边界情况，在中序遍历中如果当前指向的值是父节点的值，则表示不存在左子树；</li>
<li>当然如果不存在父节点时，不需要考虑边界直接尝试构建左子树；</li>
<li>如果存在左子树则进行递归调用，注意左子树在中序遍历中的边界是父节点；</li>
</ul>
</li>
<li>结束递归，返回当前根节点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        self.idx_in = <span class="built_in">len</span>(inorder) - <span class="number">1</span></span><br><span class="line">        self.idx_post = <span class="built_in">len</span>(postorder) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">parent</span>):</span></span><br><span class="line">            <span class="keyword">if</span> self.idx_post &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            root = TreeNode(postorder[self.idx_post])</span><br><span class="line">            self.idx_post -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># current value of inorder != root</span></span><br><span class="line">            <span class="comment"># means the right subtree exists</span></span><br><span class="line">            <span class="keyword">if</span> inorder[self.idx_in] != root.val:</span><br><span class="line">                root.right = dfs(root)</span><br><span class="line"></span><br><span class="line">            self.idx_in -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># current value of inorder != parent</span></span><br><span class="line">            <span class="comment"># means the left subtree may exist</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> parent <span class="keyword">or</span> inorder[self.idx_in] != parent.val:</span><br><span class="line">                root.left = dfs(parent)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，迭代"><a href="#思路-3，迭代" class="headerlink" title="思路 3，迭代"></a>思路 3，迭代</h2><p>递归的调用栈也是额外空间占用，想要进一步优化空间复杂度，可以考虑使用迭代方式构建二叉树。</p>
<p>迭代思路基本和思路 2 一致。</p>
<ul>
<li>准备一个 Stack；</li>
<li>从后序遍历数据构建当前节点放入 Stack；</li>
<li>判断 Stack 顶部节点的值是否等于中序遍历当前的值；<ul>
<li>如果不等于，则表示存在右子树；</li>
<li>这时重复迭代过程将后序遍历下一个值设定为 Stack 顶部节点的右子树，并将其放入 Stack；</li>
<li>如果相等，右子树遍历完成，让 Stack 和中序遍历同时移动到下一个位置；</li>
<li>继续进行上个操作，直到 Stack 顶部的节点不再等于中序遍历当前的值；</li>
<li>将最后一个移出的值作为父节点；</li>
<li>构建后续节点时，如果存在父节点，则当前节点应该设定为父节点的左子树；</li>
</ul>
</li>
<li>将父节点重置，继续下一次迭代，直到所有值遍历结束。</li>
</ul>
<p>核心在于根据中序遍历的数据位置，对后序遍历数据进行迭代：</p>
<ul>
<li>当后序遍历的当前值不等于中序遍历的当前值：存在右子树；</li>
<li>当后续遍历的当前值等于中序遍历的当前值：后序遍历的下一个值是左子树的根节点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        root, parent = TreeNode(postorder.pop()), <span class="literal">None</span></span><br><span class="line">        stack = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> inorder:</span><br><span class="line">            <span class="comment"># skip visited nodes</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>].val == inorder[-<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># set the last visited node as parent</span></span><br><span class="line">                parent = stack.pop()</span><br><span class="line">                <span class="comment"># move on</span></span><br><span class="line">                inorder.pop()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># finish the process if no value left</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> inorder:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># build current node</span></span><br><span class="line">            curr = TreeNode(postorder.pop())</span><br><span class="line"></span><br><span class="line">            <span class="comment"># set current node as the left child if parent exists,</span></span><br><span class="line">            <span class="comment"># or set it as the right child of the top of the stack</span></span><br><span class="line">            <span class="keyword">if</span> parent:</span><br><span class="line">                parent.left = curr</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack[-<span class="number">1</span>].right = curr</span><br><span class="line"></span><br><span class="line">            stack.append(curr)</span><br><span class="line">            parent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>时间复杂度上三个方法差异不大，空间复杂度上迭代方法使用的内存空间是最小的，其次是思路 2 的空间优化方法。</p>
<p>这道题的重点在于观察和理解中序遍历和后序遍历在实际运用中的差异，并利用这个差异还原二叉树。可见，虽然这两种遍历顺序从逻辑上很好理解，但是实际运用过程中，数据层级的嵌套，结构的平衡性都会提高实际计算的复杂度。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Tree</tag>
        <tag>Binary Tree</tag>
        <tag>Hash Table</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>1074. Number of Submatrices That Sum to Target (Hard)</title>
    <url>/post/leetcode/1074-Number-of-Submatrices-That-Sum-to-Target-Hard/</url>
    <content><![CDATA[<p>矩阵求和问题。给定一个矩阵 <code>matrix</code> 和一个目标值 <code>target</code>，求和为 <code>target</code> 的子矩阵的数量。</p>
<p>这是典型的前缀和应用场景，我们分别用两种思路应用前缀和来解决这个问题。</p>
<span id="more"></span>

<h2 id="Understanding-the-Problem"><a href="#Understanding-the-Problem" class="headerlink" title="Understanding the Problem"></a>Understanding the Problem</h2><p>With solutions both in Python and Java.</p>
<p>这是一道困难题，先读题。</p>
<blockquote>
<p>Given a <code>matrix</code> and a <code>target</code>, return the number of non-empty submatrices that sum to target.</p>
<p>A submatrix <code>x1, y1, x2, y2</code> is the set of all cells <code>matrix[x][y]</code> with <code>x1 &lt;= x &lt;= x2</code> and <code>y1 &lt;= y &lt;= y2</code>.</p>
<p>Two submatrices (<code>x1, y1, x2, y2</code>) and (<code>x1&#39;, y1&#39;, x2&#39;, y2&#39;</code>) are different if they have some coordinate that is different: for example, if <code>x1</code> != <code>x1&#39;</code>.</p>
</blockquote>
<p>理解一下。</p>
<ul>
<li>参数是 1 个矩阵，一个目标值；</li>
<li>需要返回的是子矩阵的数量，这些子矩阵需要满足：<ul>
<li>非空；</li>
<li>和等于目标值。</li>
</ul>
</li>
</ul>
<p>看看例子。</p>
<p>Example 1:</p>
<p><img src="/images/leetcode/1074.eg.jpg" alt="1074.eg.jpg"></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The four 1x1 submatrices that only contain 0.</span><br></pre></td></tr></table></figure>

<p>这个例子中矩阵如图，需要找出所有和为 0 的子矩阵。可见只有四个角的元素满足，这四个子矩阵只能有一个元素。</p>
<p>Example 2:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Input: matrix = [[1,-1],[-1,1]], target = 0</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">y1</th>
<th align="center">y2</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>x1</strong></td>
<td align="center">1</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center"><strong>x2</strong></td>
<td align="center">-1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>这个例子中，所有元素字面量都不为 0，所以排除 1x1 子矩阵之后，只有尺寸为 2x1 / 1x2 和 2x2 的子矩阵的和可能为 0。</p>
<p>我们来输出一下 2 个元素的组合（2x1/1x2），去除对角线的两种不满足条件的组合，可以发现剩余的四种组合的和都为 0。而唯一一种 2x2 的组合我们也能一眼看出来其和为 0，所以这个例子的答案是 5。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, <span class="built_in">sum</span>(x)) <span class="keyword">for</span> x <span class="keyword">in</span> combinations([<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>], <span class="number">2</span>)]</span><br><span class="line">[((<span class="number">1</span>, -<span class="number">1</span>), <span class="number">0</span>), ((<span class="number">1</span>, <span class="number">1</span>), <span class="number">2</span>), ((<span class="number">1</span>, -<span class="number">1</span>), <span class="number">0</span>), ((-<span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>), ((-<span class="number">1</span>, -<span class="number">1</span>), -<span class="number">2</span>), ((<span class="number">1</span>, -<span class="number">1</span>), <span class="number">0</span>)]</span><br></pre></td></tr></table></figure>

<p>Example 3:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Input: matrix = [[904]], target = 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p>当不存在满足条件的子矩阵时返回 0。</p>
<p>这道题的限制条件比较重要。</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= matrix.length &lt;= 100</code></li>
<li><code>1 &lt;= matrix[0].length &lt;= 100</code></li>
<li><code>-1000 &lt;= matrix[i] &lt;= 1000</code></li>
<li><code>-10^8 &lt;= target &lt;= 10^8</code></li>
</ul>
<p>矩阵的尺寸从最小一个元素到最大 100*100 个元素，并且元素的值可能为负数，这意味着没有取巧的办法，对于每一种子矩阵的组合我们都必须算出和才能断定是否符合条件。</p>
<h2 id="思路-amp-Solutions"><a href="#思路-amp-Solutions" class="headerlink" title="思路 &amp; Solutions"></a>思路 &amp; Solutions</h2><p><strong>递归方法（X 超时）</strong></p>
<p>乍一看题可能你会感觉没有思路，难道只能：</p>
<ul>
<li>遍历长宽得出所有子矩阵尺寸；</li>
<li>遍历每种尺寸去匹配可能出现的子矩阵，硬算矩阵和。</li>
</ul>
<p>（没错，我一开始这样做的…）</p>
<p>这样确实可以计算出答案，问题是计算量指数爆炸，100*100 的 input 必然超过时间限制。</p>
<p><strong>动态规划（DP）</strong></p>
<p>仔细一看这道题有给一个提示，也别客气直接来看看提示。</p>
<blockquote>
<p>Using a 2D prefix sum, we can query the sum of any submatrix in O(1) time. Now for each (r1, r2), we can find the largest sum of a submatrix that uses every row in [r1, r2] in linear time using a sliding window.</p>
</blockquote>
<p>提示给出的思路分为两步：</p>
<ul>
<li>求出矩阵每个元素的前缀和（prefix sum），这一步时间复杂度是 O(n)，但是后续查询某个子矩阵的和只需要 O(1)；</li>
<li>用滑动窗口（Sliding Window）遍历每一个子矩阵，检查和是否等于目标值。</li>
</ul>
<p>要应用这个思路，我们可以得到两种方法。</p>
<h3 id="方法一，计算矩阵所有元素的前缀和"><a href="#方法一，计算矩阵所有元素的前缀和" class="headerlink" title="方法一，计算矩阵所有元素的前缀和"></a>方法一，计算矩阵所有元素的前缀和</h3><ul>
<li>首先计算矩阵所有元素的前缀和；<ul>
<li>prefixSum[x][y] = matrix[x][y] + prefixSum[x-1][y] + prefixSum[x][y-1] - prefixSum[x-1][y-1]<ul>
<li><code>prefixSum[x][y]</code> -&gt; 以<code>(0, 0)</code>为左上角，矩阵中对应位置为右下角的子矩阵的和；</li>
<li><code>matrix[x][y]</code> -&gt; 矩阵对应位置的元素的值；</li>
<li><code>prefixSum[x-1][y]</code> -&gt; 矩阵上一行同列的值，这个值已经计算过了；</li>
<li><code>prefixSum[x][y-1]</code> -&gt; 矩阵上一列同行的值，这个值也已经计算过了；</li>
<li><code>prefixSum[x-1][y-1]</code> -&gt; 需要注意的是，这个值在上面两个子矩阵中被计算了两次，所以这里减去一次。</li>
</ul>
</li>
</ul>
</li>
<li>使用滑动窗口来遍历行或列；<ul>
<li>比如当遍历行时，对于 <code>(r1, r2)</code> （即第一行和第二行中的子矩阵）的情况，我们逐列遍历：<ul>
<li>初始化一个哈希表，初始化 <code>key</code> 为 0 时的值为 1，这一步是为了处理子矩阵的和刚好为目标值的情况；</li>
<li>我们查询 <code>((0,0), (1, 1))</code> 的和，并检查这个和减去目标值后的值在哈希表中对应的值；<ul>
<li>子矩阵的和减去目标值后的数，其实就是之前记录过的和为该值的子矩阵；</li>
<li>如果存在的话，那么意味着现在检查的这个子矩阵减去这个子矩阵，就能得到一个满足条件的子矩阵；</li>
<li>由于在下一步我们按列将每次检查的结果存入列哈希表中，哈希表的 <code>key</code> 对应的值是指 <code>key</code> 出现的次数；</li>
<li>这也就意味着如果同一个值出现了多次，那么就存在这么多子矩阵可以满足条件，所以我们将答案加上哈希表中对应的次数。</li>
</ul>
</li>
<li>将其作为 <code>key</code> 存入一个哈希表中，将值+<code>1（key</code> 不存在的情况设为 1）；</li>
<li>对行的组合重复这一步。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>下面是 Java 代码可以配合理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length,</span><br><span class="line">            cols = matrix[<span class="number">0</span>].length,</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化一个前缀和2D数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] prefixSum = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为避免处理数组越界，我们对第一行数据单独进行遍历</span></span><br><span class="line">        prefixSum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; cols; c++) &#123;</span><br><span class="line">            <span class="comment">// 对于第一行数据，当前值加等于前一个值</span></span><br><span class="line">            prefixSum[<span class="number">0</span>][c] = prefixSum[<span class="number">0</span>][c-<span class="number">1</span>] + matrix[<span class="number">0</span>][c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剩下的数据逐行逐列遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; rows; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">                <span class="comment">// 对应位置的前缀和等于上一行对应位置的值和上一列对应位置的值之和，减去重复计算的区域的值</span></span><br><span class="line">                prefixSum[r][c] = matrix[r][c] + prefixSum[r-<span class="number">1</span>][c]</span><br><span class="line">                    + (c == <span class="number">0</span> ? <span class="number">0</span> : prefixSum[r][c-<span class="number">1</span>] - prefixSum[r-<span class="number">1</span>][c-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算完前缀和，我们对行进行组合遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sr = <span class="number">0</span>; sr &lt; rows; sr++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> er = sr; er &lt; rows; er++) &#123;</span><br><span class="line">                <span class="comment">// 初始化一个哈希表来存储次数</span></span><br><span class="line">                Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">                    <span class="comment">// 计算第一列到当前列组成的矩阵的和</span></span><br><span class="line">                    <span class="keyword">int</span> cur = prefixSum[er][c] - (sr == <span class="number">0</span> ? <span class="number">0</span> : prefixSum[sr-<span class="number">1</span>][c]);</span><br><span class="line">                    <span class="comment">// 查询当前窗口中，需要减去的矩阵是否存在/存在几个</span></span><br><span class="line">                    <span class="keyword">if</span> (map.get(cur - target) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        ans += map.get(cur - target);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将当前矩阵的值存入哈希表，将次数+1</span></span><br><span class="line">                    map.put(cur, map.get(cur) == <span class="keyword">null</span> ? <span class="number">1</span> : map.get(cur) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二，仅按行或列计算前缀和"><a href="#方法二，仅按行或列计算前缀和" class="headerlink" title="方法二，仅按行或列计算前缀和"></a>方法二，仅按行或列计算前缀和</h3><ul>
<li>与方法一最大的区别在于，方法二不去计算一个 2D 矩阵的前缀和，而是逐行计算这一行的前缀和；</li>
<li>这个前缀和数组由循环外部的变量，变成列循环内部的变量，随着基础行的变化而重置；</li>
<li>除去计算前缀和的变化，在滑动窗口内的操作与方法一一致，因此降低了空间复杂度。</li>
</ul>
<p>下面是 Python 帮助理解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubmatrixSumTarget</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        rows, cols, ans = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> sr <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            colsum = [<span class="number">0</span>] * cols</span><br><span class="line">            <span class="keyword">for</span> er <span class="keyword">in</span> <span class="built_in">range</span>(sr, rows):</span><br><span class="line">                d, cur = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;, <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                    colsum[c] += matrix[er][c]</span><br><span class="line">                    cur += colsum[c]</span><br><span class="line">                    ans += d.get(cur-target, <span class="number">0</span>)</span><br><span class="line">                    d[cur] = d.get(cur, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一道困难的题，难点在于把计算计划到规定的复杂度中。</p>
<p>要得到答案，需要一些前置的知识：</p>
<ul>
<li>前缀和的应用；</li>
<li>动态规划的应用；</li>
<li>滑动窗口的应用。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Prefix Sum</tag>
        <tag>Hash Table</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>109. Convert Sorted List to Binary Search Tree (Medium)</title>
    <url>/post/leetcode/109-Convert-Sorted-List-to-Binary-Search-Tree-Medium/</url>
    <content><![CDATA[<p>你有一个链表的 <code>head</code> 元素，链表数组按照升序排列，现在你需要实现一个程序将其转换为高度平衡的二叉查找树。</p>
<p>对这道题来说，高度平衡的二叉树定义为所有节点的子节点深度相差不大于 1。</p>
<p>题目的难点在于你不知道链表的长度。我们从几个思路讨论如何解决这道题。</p>
<span id="more"></span>

<h2 id="思路-1，快慢指针"><a href="#思路-1，快慢指针" class="headerlink" title="思路 1，快慢指针"></a>思路 1，快慢指针</h2><p>比较简洁的解法是快慢指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree(head, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">tree</span><span class="params">(ListNode b, ListNode e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == e) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = b;</span><br><span class="line">        ListNode slow = b;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != e &amp;&amp; fast.next.next != e) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        root.left = tree(b, slow);</span><br><span class="line">        root.right = tree(slow.next, e);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python 强行和官方答案匹配。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span>(<span class="params">self, head: ListNode</span>) -&gt; TreeNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tree</span>(<span class="params">head, end</span>):</span></span><br><span class="line">            <span class="keyword">if</span> head == end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            fast = slow = head</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> fast.<span class="built_in">next</span> != end:</span><br><span class="line">                fast, slow = fast.<span class="built_in">next</span>, slow.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> fast.<span class="built_in">next</span> != end:</span><br><span class="line">                    fast = fast.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            root = TreeNode(slow.val)</span><br><span class="line">            root.left = tree(head, slow)</span><br><span class="line">            root.right = tree(slow.<span class="built_in">next</span>, end)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tree(head, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，-长度二分"><a href="#思路-2，-长度二分" class="headerlink" title="思路 2， 长度二分"></a>思路 2， 长度二分</h2><p>下面是基于长度二分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span>(<span class="params">self, head: ListNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        self.head, n = head, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">b, e</span>):</span></span><br><span class="line">            <span class="keyword">if</span> b &gt;= e:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            m = b + e &gt;&gt; <span class="number">1</span></span><br><span class="line">            left = dfs(b, m)</span><br><span class="line">            root = TreeNode(self.head.val, left)</span><br><span class="line">            self.head = self.head.<span class="built_in">next</span></span><br><span class="line">            root.right = dfs(m + <span class="number">1</span>, e)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, n)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
        <tag>Linked List</tag>
        <tag>Divider and Conquer</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>112. Path Sum (Easy)</title>
    <url>/post/leetcode/112-Path-Sum-Easy/</url>
    <content><![CDATA[<p>二叉树问题。求是否存在和目标值一致的路径和。</p>
<p>路径和指的是从根节点到叶子节点的路径的值相加的结果。</p>
<p>看上去这道题适合 DFS 一条路径一条路径的遍历解决。</p>
<span id="more"></span>

<h2 id="思路-1，递归，前序遍历"><a href="#思路-1，递归，前序遍历" class="headerlink" title="思路 1，递归，前序遍历"></a>思路 1，递归，前序遍历</h2><p>一层一层求和直到叶子节点，判断是否和目标一致。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node, curr</span>):</span></span><br><span class="line">            curr += node.val</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> curr == targetSum</span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">and</span> dfs(node.left, curr):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">and</span> dfs(node.right, curr):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，另一种前序遍历写法"><a href="#思路-2，另一种前序遍历写法" class="headerlink" title="思路 2，另一种前序遍历写法"></a>思路 2，另一种前序遍历写法</h2><p>相同思路，另一种写法。这次我们用解题函数自身作为 DFS 函数，也不再进行求和判断，相反我们每次遍历从目标值中减去遇到的值。</p>
<p>这两种方法没有本质区别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.val == targetSum:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.hasPathSum(root.left, targetSum - root.val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.hasPathSum(root.right, targetSum - root.val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="思路-3，迭代"><a href="#思路-3，迭代" class="headerlink" title="思路 3，迭代"></a>思路 3，迭代</h2><p>有递归的地方就有 Stack，来试试用迭代的方式实现这个过程。</p>
<p>迭代的方式注意点在于我们需要同时保存节点和累积值。</p>
<p>这个思路的逻辑看上去要更简洁。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        stack = [(root, root.val)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, val = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> val == targetSum:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, node.left.val + val))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, node.right.val + val))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>114. Flatten Binary Tree to Linked List (Medium)</title>
    <url>/post/leetcode/114-Flatten-Binary-Tree-to-Linked-List-Medium/</url>
    <content><![CDATA[<p>将二叉树结构数据扁平化为链表，采用前序遍历（pre-order traversal）顺序。</p>
<p>题目要求修改二叉树结构去构成数组，在这个限制下我们要对前序遍历做一些修改才能解决这道题。</p>
<span id="more"></span>

<h2 id="思路-1，有序递归"><a href="#思路-1，有序递归" class="headerlink" title="思路 1，有序递归"></a>思路 1，有序递归</h2><p>重复先左后右的递归，用递归方法实现 O(1) 的难点在于将右节点挂在左节点的末尾，这里我们将递归函数的返回值设为递归最后一个元素，来解决这个难题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_flatten</span>(<span class="params">node</span>):</span></span><br><span class="line">            left, right = node.left, node.right</span><br><span class="line">            <span class="keyword">if</span> left:</span><br><span class="line">                left = _flatten(left)</span><br><span class="line">                left.right = node.right</span><br><span class="line">                node.right = node.left</span><br><span class="line">                node.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> right:</span><br><span class="line">                right = _flatten(right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = left</span><br><span class="line">            <span class="keyword">return</span> right <span class="keyword">if</span> right <span class="keyword">else</span> node</span><br><span class="line"></span><br><span class="line">        _flatten(root)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，学习题解的思路"><a href="#思路-2，学习题解的思路" class="headerlink" title="思路 2，学习题解的思路"></a>思路 2，学习题解的思路</h2><p>如果我们发现有左节点，找到左节点最下端的右节点，将 root 的右节点挂在上面，将左节点替换为 root 的右节点，重置 root 的左节点为空，root 节点向右进一位，检查左节点，如此往复，直到最后一个左节点消失，二分树转链表结束。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                left = root.left</span><br><span class="line">                <span class="keyword">while</span> left.right:</span><br><span class="line">                    left = left.right</span><br><span class="line">                left.right = root.right</span><br><span class="line">                root.right = root.left</span><br><span class="line">                root.left = <span class="literal">None</span></span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，从下而上"><a href="#思路-3，从下而上" class="headerlink" title="思路 3，从下而上"></a>思路 3，从下而上</h2><p>和之前思路不同之处在于，这次我们从下而上的去将二叉树转化为链表，转化的顺序是 right -&gt; left -&gt; node，因为我们需要先 node，再 left，再 right 的顺序去组成这个链表。我们用递归来帮助完成这个过程，使用一个全局变量 <code>head</code> 来储存当前处理的节点，因为我们已经确保有序递归，所以 <code>head</code> 将从空（链表最后一个节点的子节点）开始，每次指向上一个节点，直到达到 <code>root</code> 节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                f(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                f(node.left)</span><br><span class="line">            node.left, node.right, self.head = <span class="literal">None</span>, self.head, node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            f(root)</span><br></pre></td></tr></table></figure>

<p>相同思路的 Java 代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) f(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) f(node.right);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) f(node.left);</span><br><span class="line">        node.left = <span class="keyword">null</span>; node.right = head; head = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JS 代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> flatten = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> f = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right) f(node.right);</span><br><span class="line">    <span class="keyword">if</span> (node.left) f(node.left);</span><br><span class="line">    (node.left = <span class="literal">null</span>), (node.right = head), (head = node);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (root) f(root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
        <tag>Stack</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>116. Populating Next Right Pointers in Each Node (Medium)</title>
    <url>/post/leetcode/116-Populating-Next-Right-Pointers-in-Each-Node-Medium/</url>
    <content><![CDATA[<p>你需要给一棵完全二叉树的每个一节点添加一个 <code>next</code> 指针，指向同一层的右边一个节点。</p>
<p>题目中完全二叉树的定义：所有叶子节点都在同一层，除了叶子节点外所有节点都拥有左右子节点，节点的数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目标是给所有节点的 <code>next</code> 赋值，如果不存在则为空，默认为空。</p>
<span id="more"></span>

<h2 id="思路-1，BFS"><a href="#思路-1，BFS" class="headerlink" title="思路 1，BFS"></a>思路 1，BFS</h2><p>我们需要知道每一层有多少节点才能完成这道题的目标，一个简单的宽度优先的层序遍历算法可以解决这道题。</p>
<p>具体可以参考 <code>No.102</code>，我们用一个 Stack 存每一层的节点，每一次迭代遍历完这一层的节点，同时放入下一层的节点。</p>
<p>这个简单的算法在时间复杂度上还有优化的空间，因为我们并未将完全二叉树这个特性纳入考虑的范围。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stack), <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                node = stack.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> i != <span class="number">1</span>:</span><br><span class="line">                    node.<span class="built_in">next</span> = stack[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack.append(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，DFS"><a href="#思路-2，DFS" class="headerlink" title="思路 2，DFS"></a>思路 2，DFS</h2><p>DFS 的思路中，我们只要知道 2 个相邻的节点，就能对所有节点进行遍历。</p>
<p>比如我们知道当前节点 <code>curr</code> 和它的下一个节点 <code>next</code>，要保证当前的节点和其子节点相互连接：</p>
<ul>
<li>需要将 <code>curr.next</code> 设置为 <code>next</code>；</li>
<li>需要将 <code>curr.left</code> 和 <code>curr.right</code> 作为参数继续递归；</li>
<li>需要将 <code>curr.right</code> 和 <code>next.left</code> 作为参数继续递归；</li>
<li>如果 <code>next</code> 不存在，需要将 <code>curr.right</code> 和 <code>None</code> 作为参数继续递归（因为需要递归子节点）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">curr, nxt</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> curr:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            curr.<span class="built_in">next</span> = nxt</span><br><span class="line">            dfs(curr.left, curr.right)</span><br><span class="line">            dfs(curr.right, nxt.left <span class="keyword">if</span> nxt <span class="keyword">else</span> <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">return</span> curr</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，BFS-空间优化"><a href="#思路-3，BFS-空间优化" class="headerlink" title="思路 3，BFS 空间优化"></a>思路 3，BFS 空间优化</h2><p>思路 1 和思路 2 效率上相差无几，区别仅在于遍历的顺序。但是使用 Stack 的 BFS 和使用递归调用栈的 DFS 算法都使用了额外的 O(n) 的空间。</p>
<p>由于树的节点多了一个 <code>next</code> 属性，让我们能知道当前节点的层级中下一个节点是谁，相当于每一层的节点连城一个链表，这个数据结构让我们可以避免使用 Stack 也能完成层序遍历。</p>
<p>具体的思路就是，只要我们知道 2 个父节点，我们就可以知道这一层的所有节点。</p>
<ul>
<li>从 <code>root</code> 的子节点开始迭代，我们先保留 <code>root.left</code> 的引用，这将作为下一层的开始位置；</li>
<li>根据完全二叉树的特性，我们判断当前节点和其左节点存在才进行遍历；</li>
<li>如果存在，现将当前节点的左右子节点关联，然后将右节点和当前节点的 <code>next.left</code> 关联；</li>
<li>将 <code>next</code> 设为当前节点继续遍历，直到不再存在 <code>next</code>；</li>
<li>这一层遍历节点，将最初保存的下一层开始位置设为当前节点继续迭代。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="comment"># start point of the next level</span></span><br><span class="line">            nxt = curr.left</span><br><span class="line">            <span class="comment"># because its a perfect binary tree,</span></span><br><span class="line">            <span class="comment"># only connect its children if any of them exists</span></span><br><span class="line">            <span class="keyword">while</span> curr <span class="keyword">and</span> curr.left:</span><br><span class="line">                curr.left.<span class="built_in">next</span> = curr.right</span><br><span class="line">                curr.right.<span class="built_in">next</span> = curr.<span class="built_in">next</span>.left <span class="keyword">if</span> curr.<span class="built_in">next</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># set up the start point of the next level</span></span><br><span class="line">            curr = nxt</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>思路 1 和思路 2 在时间复杂度和空间复杂度上相似，LeetCode 的测试集的结果也不相上下。</p>
<p>思路 3 优化了空间复杂度，在同样测试集下平均结果要比前两者稍好，但是目测测试集的数据量不会很大，所以根据系统资源情况执行结果偶尔会有波动。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>117. Populating Next Right Pointers in Each Node II (Medium)</title>
    <url>/post/leetcode/117-Populating-Next-Right-Pointers-in-Each-Node-II-Medium/</url>
    <content><![CDATA[<p>在 <code>No.116</code> 中我们解决了在完全二叉树的情况下将每一层的节点向右关联的需求，这道题需要解决同样的需求，但是 <code>input</code> 不再确保是完全二叉树了。也就是说，当前节点可能不存在左节点、右节点或者左右节点都不存在，它的相邻节点也是一样，甚至所谓“相邻”其实也隔了好几个分支。</p>
<p>我们需要加入更多条件分歧来解决这道题。</p>
<span id="more"></span>

<h2 id="思路-1，迭代-BFS"><a href="#思路-1，迭代-BFS" class="headerlink" title="思路 1，迭代 BFS"></a>思路 1，迭代 BFS</h2><p>尝试空间复杂度 O(1) 的算法解决这道题。</p>
<p>首先这道题虽然和 <code>No.116</code> 需求一致，但是由于数据的变化，我们需要先抛开它的解题思路，换一个角度思考一下这个问题。</p>
<p>这里有一个思考陷阱：不要去找下一个存在的节点。</p>
<p>或许你会拓展 116 的思路，在知道当前存在的节点的情况下，尝试寻找它的 <code>next</code> 应该是谁。但是这中间存在太多条件，与其穷举这些条件，不如换个思路：去“找”上一个存在的节点。</p>
<ul>
<li>实现一个 BFS 算法，我们按层序遍历，因为存在 <code>next</code> 属性绑定，省去 Stack 操作；</li>
<li>遍历这层每一个节点，如果其存在子节点；<ul>
<li>检查 <code>prev</code> 是否存在，如果存在则将当前子节点设置为它的 <code>next</code>；</li>
<li>将当前子节点为 <code>prev</code>，最为后面节点的前置；</li>
</ul>
</li>
<li>用一个变量保存每一层的第一个节点 <code>head</code>，如果这一层遍历结束，将 <code>head</code> 作为下一层迭代的开始。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        head, prev, curr = <span class="literal">None</span>, <span class="literal">None</span>, root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">while</span> curr:</span><br><span class="line">                <span class="keyword">if</span> curr.left:</span><br><span class="line">                    <span class="keyword">if</span> prev:</span><br><span class="line">                        <span class="comment"># connect currrent node with previous one</span></span><br><span class="line">                        prev.<span class="built_in">next</span> = curr.left</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># or set current one as the first one</span></span><br><span class="line">                        head = curr.left</span><br><span class="line">                    prev = curr.left</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> curr.right:</span><br><span class="line">                    <span class="keyword">if</span> prev:</span><br><span class="line">                        <span class="comment"># connect currrent node with previous one</span></span><br><span class="line">                        prev.<span class="built_in">next</span> = curr.right</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># or set current one as the first one</span></span><br><span class="line">                        head = curr.right</span><br><span class="line">                    prev = curr.right</span><br><span class="line"></span><br><span class="line">                <span class="comment"># iterate the next node</span></span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># setup the next level</span></span><br><span class="line">            curr = head</span><br><span class="line">            head = prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，DFS"><a href="#思路-2，DFS" class="headerlink" title="思路 2，DFS"></a>思路 2，DFS</h2><p>等等，题目提示递归是 OK 的， 对这道题我们可以不考虑调用栈的内存占用，“找下一个”的方法是可以实现的，何不试试这个方法？</p>
<p>对于每个跟节点我们需要处理：</p>
<ul>
<li>如果左节点存在：<ul>
<li>如果右节点存在，连接它们；</li>
<li>如果右节点不存在，连接左节点和下一个存在的节点；</li>
</ul>
</li>
<li>接着接触如果右节点存在：<ul>
<li>将右节点和下一个存在的节点连接；</li>
</ul>
</li>
<li>对右节点递归，顺序很重要：<ul>
<li>从上至下、从右往左遍历才能保证 <code>next</code> 被引用时指向正确的节点；</li>
</ul>
</li>
<li>对左节点递归。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                <span class="keyword">return</span> node.left</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> node.right</span><br><span class="line">            <span class="keyword">return</span> find(node.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    node.left.<span class="built_in">next</span> = node.right</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node.left.<span class="built_in">next</span> = find(node.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                node.right.<span class="built_in">next</span> = find(node.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">            dfs(node.right)</span><br><span class="line">            dfs(node.left)</span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>118. Pascal&#39;s Triangle (Easy)</title>
    <url>/post/leetcode/118-Pascal-s-Triangle-Easy/</url>
    <content><![CDATA[<p>杨辉三角问题。在杨辉三角中每个元素 <code>i</code> 的值由上一行同位置 <code>i</code> 的值加上上一行前一个位置 <code>i-1</code> 的值决定。</p>
<p>你需要实现一个程序接受一个行数，返回到这行位置的杨辉三角数组。枚举问题，DP 解决。</p>
<span id="more"></span>

<h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><p>杨辉三角，做完这题发现，这就是 DP 呀，简明扼要。思路就是用当前行计算下一行，每一个值都等于上一行相同位置加上前一位，注意首位两个特殊 case 即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">self, numRows: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        ans = [[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, numRows):</span><br><span class="line">            curr, nxt = ans[-<span class="number">1</span>], []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i - <span class="number">1</span> &lt; <span class="number">0</span> <span class="keyword">or</span> i == n:</span><br><span class="line">                    nxt.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nxt.append(curr[i - <span class="number">1</span>] + curr[i])</span><br><span class="line">            ans.append(nxt)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>1192. Critical Connections in a Network (Hard)</title>
    <url>/post/leetcode/1192-Critical-Connections-in-a-Network-Hard/</url>
    <content><![CDATA[<p>图论问题。一共有 <code>n</code> 台服务器，我们将存在于任意 2 台服务器之间链接定义为边，可以构成一张无向图。</p>
<p>给定一个 <code>connections</code> 数组定义这个服务器网络的所有链接（边），在这个网络上任何节点都可以直接或间接的相互访问。</p>
<p>关键链接指的是这个网络中的某一个节点如果被移除，将导致一部分服务器无法访问到另一部分。</p>
<p>要求找到所有关键链接。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>解题思路需要 review 和重新记录。理论上思路是依次尝试移除一个链接，然后检查所有服务器是否还能互联。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">criticalConnections</span>(<span class="params">self, n: <span class="built_in">int</span>, connections: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="comment"># make adjacency-list of connections</span></span><br><span class="line">        adj = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> connections:</span><br><span class="line">            adj[u].append(v)</span><br><span class="line">            adj[v].append(u)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># define dfs</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">u, prev, <span class="built_in">id</span>, ids, ans</span>):</span></span><br><span class="line">            ids[u] = <span class="built_in">id</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> adj[u]:</span><br><span class="line">                <span class="keyword">if</span> v == prev:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> ids[v] == -<span class="number">1</span>:</span><br><span class="line">                    ids[u] = <span class="built_in">min</span>(ids[u], dfs(v, u, <span class="built_in">id</span>+<span class="number">1</span>, ids, ans))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ids[u] = <span class="built_in">min</span>(ids[u], ids[v])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">id</span> != <span class="number">0</span> <span class="keyword">and</span> ids[u] == <span class="built_in">id</span>:</span><br><span class="line">                ans.append([u, prev])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ids[u]</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        ids = [-<span class="number">1</span>] * n</span><br><span class="line">        dfs(<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, ids, ans)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>Graph</tag>
        <tag>Biconnected Component</tag>
        <tag>Need Review</tag>
      </tags>
  </entry>
  <entry>
    <title>120. Triangle (Medium)</title>
    <url>/post/leetcode/120-Triangle-Medium/</url>
    <content><![CDATA[<p>你有一个三角形形状的 2D 数组，你需要找到从最顶层走到最底层的最短路径。</p>
<p>限制是每一步你只能下一层，且每一步你只能选择下一层的同下标位置或者下标 +1 位置。</p>
<blockquote>
<p>Given a <code>triangle</code> array, return the minimum path sum from top to bottom.</p>
<p>For each step, you may move to an adjacent number of the row below. More formally, if you are on index <code>i</code> on the current row, you may move to either index <code>i</code> or index <code>i + 1</code> on the next row.</p>
</blockquote>
<p>看看例子才能更好理解题目，这题看上去需要计算所有可能才能知道答案，或许是 DP 的用武之地。</p>
<span id="more"></span>

<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: The triangle looks like:</span><br><span class="line">   2</span><br><span class="line">  3 4</span><br><span class="line"> 6 5 7</span><br><span class="line">4 1 8 3</span><br><span class="line">The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: triangle = [[-10]]</span><br><span class="line">Output: -10</span><br></pre></td></tr></table></figure>

<p>Constraints:</p>
<p>1 &lt;= triangle.length &lt;= 200<br>triangle[0].length == 1<br>triangle[i].length == triangle[i - 1].length + 1<br>-104 &lt;= triangle[i][j] &lt;= 104</p>
<h2 id="思路-amp-Solutions"><a href="#思路-amp-Solutions" class="headerlink" title="思路 &amp; Solutions"></a>思路 &amp; Solutions</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span>(<span class="params">self, triangle: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">for</span> depth <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(triangle)):</span><br><span class="line">            lastsz = <span class="built_in">len</span>(triangle[depth-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">for</span> pos, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(triangle[depth]):</span><br><span class="line">                <span class="keyword">if</span> pos == <span class="number">0</span>:</span><br><span class="line">                    prev = triangle[depth-<span class="number">1</span>][pos]</span><br><span class="line">                <span class="keyword">elif</span> pos == lastsz:</span><br><span class="line">                    prev = triangle[depth-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    prev = <span class="built_in">min</span>(triangle[depth-<span class="number">1</span>][pos-<span class="number">1</span>], triangle[depth-<span class="number">1</span>][pos])</span><br><span class="line">                triangle[depth][pos] = x + prev</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(triangle[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>128. Longest Consecutive Sequence (Medium)</title>
    <url>/post/leetcode/128-Longest-Consecutive-Sequence-Medium/</url>
    <content><![CDATA[<p>你有一个未排序的整数数组 <code>nums</code>，你要在 O(n) 时间复杂度内找到最长的连续子序列，返回其长度</p>
<p><code>nums</code> 数组的元素可以构成诺干个连续的子数组，我们需要找到最大的子数组，返回其长度。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要找到最大的子数组，首先我们要找到子数组的第一个元素，可以将 <code>nums</code> 转成一个 HashSet，然后遍历它：</p>
<ul>
<li>查询每个元素的前一个值（<code>n - 1</code>）是否存在；<ul>
<li>存在则表示这个元素不是子数组的最小值，直接跳过；</li>
<li>不存在时，循环查询这个值的下一个值是否存在（<code>n + 1</code>），直到下一个值不存在为止；</li>
<li>在查询下一个值的过程中保持一个计数器，一直计数到不存在下一个值；</li>
<li>将其和全局变量取一个最大值；</li>
</ul>
</li>
<li>返回全局最大值。</li>
</ul>
<p>因为我们只在子数组的最小值开始遍历，所以能避免不需要的运算，让时间复杂度在 O(n)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, nums = <span class="number">0</span>, <span class="built_in">set</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> n + <span class="number">1</span> <span class="keyword">in</span> nums:</span><br><span class="line">                    n, count = n + <span class="number">1</span>, count + <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, count)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title>1302. Deepest Leaves Sum (Medium)</title>
    <url>/post/leetcode/1302-Deepest-Leaves-Sum-Medium/</url>
    <content><![CDATA[<p>求二叉树最深层的所有节点的值之和。二叉树层序遍历的应用场景。</p>
<p>虽然题目的 tag 包含 DFS，但是感觉用 DFS 思路比 BFS 还要复杂并且低效，所以这题我们只讨论 BFS 思路。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>计算每一层的和，直到最后一层完成计算，返回计算的和。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deepestLeavesSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                ans += node.val</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>135. Candy (Hard)</title>
    <url>/post/leetcode/135-Candy-Hard/</url>
    <content><![CDATA[<p>分糖果 🍬 问题。有 <code>n</code> 个小朋友站成一排，每个人被分配一个分值，现在你要给他们分糖果，有两个要求。</p>
<ol>
<li>每个小朋友至少要有一个糖果 🍬；</li>
<li>分数高的小朋友要比两边分数低的小朋友糖果 🍬 多。</li>
</ol>
<p>你需要找到一个分配方案需要最少的糖果 🍬 数量。</p>
<span id="more"></span>

<blockquote>
<p>做完后才意识到是一道 hard 难度的题。</p>
</blockquote>
<h2 id="思路-1，野路子-提取依赖。"><a href="#思路-1，野路子-提取依赖。" class="headerlink" title="思路 1，野路子 提取依赖。"></a>思路 1，<del>野路子</del> 提取依赖。</h2><p>最初的想法是根据左右位置的 <code>rating</code> 值决定当前位置的糖果数量，但是仅仅如此的话会由于无法预知后面的值是否被改变，从而造成漏算；要解决漏算，可以根据 <code>rating</code> 值计算出当前位置的糖果数量是否依赖左右的值，这样遍历一次列表之后我们就获得了所有位置的依赖。</p>
<p>接着我们准备一个递归函数来根据这些依赖，最终去计算糖果数量。</p>
<p>数据结构上，对于无依赖项，我们直接储存字面量（int），如果存在依赖则存入 list。</p>
<p>递归时，如果目标是字面量则直接返回，如果存在进一步的依赖则调用递归进一步计算。这样可以在 O(n) 时间内完成递归。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span>(<span class="params">self, ratings: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(ratings)</span><br><span class="line">        c = [-<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> ratings[i - <span class="number">1</span>] &lt; ratings[i]:</span><br><span class="line">                res.append(i - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> i &lt; n - <span class="number">1</span> <span class="keyword">and</span> ratings[i + <span class="number">1</span>] &lt; ratings[i]:</span><br><span class="line">                res.append(i + <span class="number">1</span>)</span><br><span class="line">            c[i] = <span class="number">1</span> <span class="keyword">if</span> <span class="built_in">len</span>(res) == <span class="number">0</span> <span class="keyword">else</span> res</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">idx</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">type</span>(c[idx]) == <span class="built_in">int</span>:</span><br><span class="line">                <span class="keyword">return</span> c[idx]</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> c[idx]:</span><br><span class="line">                res.append(cal(x) + <span class="number">1</span>)</span><br><span class="line">            c[idx] = <span class="built_in">max</span>(res)</span><br><span class="line">            <span class="keyword">return</span> c[idx]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cal(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(c)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，双列表。"><a href="#思路-2，双列表。" class="headerlink" title="思路 2，双列表。"></a>思路 2，双列表。</h2><p>换一个角度看下思路一，我们能发现从左到右遍历列表时，我们无法预知右边的值是否会变动，但是我们知道左边的值都是看过的，不会发生变动。于是，我们可以准备另一个列表从右到左的遍历一次列表，这样我们就获得了一个能确保右边值都考虑到了的数据。</p>
<p>要保证每个位置的糖果都符合题目要求，我们需要对两个列表相同位置的糖果取最大值，结果将是我们的答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span>(<span class="params">self, ratings: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(ratings)</span><br><span class="line">        left, right = [<span class="number">1</span>] * n, [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> ratings[i - <span class="number">1</span>] &lt; ratings[i]:</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; n - <span class="number">1</span> <span class="keyword">and</span> ratings[i + <span class="number">1</span>] &lt; ratings[i]:</span><br><span class="line">                right[i] = right[i + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            ans += <span class="built_in">max</span>(left[i], right[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，单列表。"><a href="#思路-3，单列表。" class="headerlink" title="思路 3，单列表。"></a>思路 3，单列表。</h2><p>思路 2 的优化版本，使用双列表时，实际上我们没有同时使用到它们，所以优化的思路就是在第二次遍历时对列表进行更新，而不是重新准备一个列表。</p>
<p>这样完成第二次遍历之后，列表的和就是答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span>(<span class="params">self, ratings: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(ratings)</span><br><span class="line">        c = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> ratings[i - <span class="number">1</span>] &lt; ratings[i]:</span><br><span class="line">                c[i] = c[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; n - <span class="number">1</span> <span class="keyword">and</span> ratings[i + <span class="number">1</span>] &lt; ratings[i]:</span><br><span class="line">                c[i] = <span class="built_in">max</span>(c[i], c[i + <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(c)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>1354. Construct Target Array With Multiple Sums (Hard)</title>
    <url>/post/leetcode/1354-Construct-Target-Array-With-Multiple-Sums-Hard/</url>
    <content><![CDATA[<p>构建目标数组问题。给你一个长度为 <code>n</code> 的目标数组 <code>target</code>，你需要从一个包含 <code>n</code> 个 <code>1</code> 的数组 <code>arr</code> 开始执行下面的过程：</p>
<ul>
<li>设当前的 <code>arr</code> 数组的和为 <code>x</code>；</li>
<li>选择 <code>0</code> 到 <code>n</code> 之间的一个下标 <code>i</code>，让 <code>arr[i]</code> 等于 <code>x</code>；</li>
<li>重复这个过程。</li>
</ul>
<p>判断最终能否构建出目标数组。</p>
<span id="more"></span>

<h2 id="Highlight"><a href="#Highlight" class="headerlink" title="Highlight:"></a>Highlight:</h2><ul>
<li>Backward from the max value</li>
<li>Mod operation on max value with rest sum to get replacement value</li>
<li>Push replacement value back to heap</li>
<li>Repeat the procedure until the max value becomes to 1, which means succeed</li>
<li>Or until the exception occurs and return <code>False</code><ul>
<li>when the rest sum is greater than the max value</li>
<li>when the rest sum less than 1</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPossible</span>(<span class="params">self, target: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">        total = <span class="built_in">sum</span>(target)</span><br><span class="line">        <span class="comment"># Transform min heap to max heap.</span></span><br><span class="line">        heap = [-x <span class="keyword">for</span> x <span class="keyword">in</span> target]</span><br><span class="line">        heapify(heap)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If the max value of heap is 1</span></span><br><span class="line">        <span class="keyword">while</span> -heap[<span class="number">0</span>] != <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># Get max value of current heap.</span></span><br><span class="line">            num = -heap[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># Get the rest sum except the max value.</span></span><br><span class="line">            total += heappop(heap)</span><br><span class="line">            <span class="comment"># print(num, total, heap)</span></span><br><span class="line">            <span class="keyword">if</span> total &gt;= num <span class="keyword">or</span> total == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># Get last replacement value.</span></span><br><span class="line">            <span class="comment"># It&#x27;s the point to reduce time complicity.</span></span><br><span class="line">            <span class="comment"># With using the mod operator, we avoid to iterate through every step.</span></span><br><span class="line">            num %= total</span><br><span class="line">            <span class="comment"># Add up the replacement and add to heap.</span></span><br><span class="line">            total += num</span><br><span class="line">            heappush(heap, -num <span class="keyword">or</span> -total)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Heap (Priority Queue)</tag>
      </tags>
  </entry>
  <entry>
    <title>1383. Maximum Performance of a Team (Hard)</title>
    <url>/post/leetcode/1383-Maximum-Performance-of-a-Team-Hard/</url>
    <content><![CDATA[<p>你需要从 <code>n</code> 个工程师中选择最多 <code>k</code> 位构成一个小组，并保证获得最好的绩效表现。</p>
<p>你有两个数组 <code>speed</code> 和 <code>efficiency</code> 分别表示每个工程师的速度和效率。</p>
<p>小组的绩效表现计算方法：小组所有成员的速度之和乘以小组成员效率的最小值。由于结果数组可能会非常大，将结果和 <code>10^9 + 7</code> 取模作为答案返回。</p>
<p>工程师的速度和效率是捆绑的，所以要知道答案，我们只能尝试将每一位工程师编入小组，可以使用贪心算法解决问题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>解题思路是先计算局部最优解，再计算全局的最优解，是典型的贪心算法的应用场景。但这道题困难之处在于需要保持两个排序，而意识到这个解决方案需要一定的直觉。</p>
<p>读完题我们可以了解到团队的表现计算公式为：<code>sum(speeds) * min(efficiencies)</code>，这里的细节是选择的团队成员最多可以达到<code>k</code>位，意味着当团队人数少于<code>k</code>能取得更好的表现时的结果可以作为局部最优解。</p>
<p>据此我们开始思考，暴力解法最大的问题在于做了很多没有意义的运算，如果能找到一个方法对暴力算法进行剪枝，我们就能更快的得到答案。这道题的瓶颈在于 <code>efficiency</code> 取其最小值，而换句话来说，如果我们指定了一个队员的 <code>efficiency</code> 为最小值，那么此时的局部最优解将会是所有效率高于这个队员的人之中速度最快的前 <code>k-1</code> 个人加上这个队员的速度（我们一共选了 <code>k</code> 个人），将结果乘以这个队员的效率（因为这个队员是最小值）。</p>
<p>要实现这个思路需要保持 2 个排序：</p>
<ul>
<li><code>efficiency</code> 降序：将队员按照效率以降序排序，这样遍历的时候当前的队员永远是效率低于前面队员的；</li>
<li><code>speed</code> 动态排序：按照效率遍历，每次挑选一个队员，动态计算出速度的排序，还需要关注几个细节：<ul>
<li><code>speed</code> 排序元素的长度达到 <code>k</code> 时意味着接下来如果我们加了一个队员，就一定要放走一个已有的队员，我们放走速度最慢的队员；</li>
<li>堆的数据结构非常适合 <code>speed</code> 排序，我们可以将新的值丢入堆中，每次从堆顶移出一个最小值。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPerformance</span>(<span class="params">self, n: <span class="built_in">int</span>, speed: <span class="type">List</span>[<span class="built_in">int</span>], efficiency: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        es = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(efficiency, speed), key=<span class="keyword">lambda</span> x: -x[<span class="number">0</span>])</span><br><span class="line">        ans, total, q = <span class="number">0</span>, <span class="number">0</span>, []</span><br><span class="line">        <span class="keyword">for</span> e, s <span class="keyword">in</span> es:</span><br><span class="line">            total, ans = total + s, <span class="built_in">max</span>(ans, (total + s) * e)</span><br><span class="line">            heapq.heappush(q, s)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(q) == k:</span><br><span class="line">                total -= heapq.heappop(q)</span><br><span class="line">        <span class="keyword">return</span> ans % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
        <tag>Heap (Priority Queue)</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>1423. Maximum Points You Can Obtain from Cards (Medium)</title>
    <url>/post/leetcode/1423-Maximum-Points-You-Can-Obtain-from-Cards-Medium/</url>
    <content><![CDATA[<p>抽卡求最大得分问题。有一堆卡排成一行，每张卡的卡面有其对应的分值，你有 <code>k</code> 次机会抽取卡片，每次机会中你可以选择抽取最左边的一张卡，或者抽取最右边的一张卡。你所抽取的所有卡片的分值之和是你的得分。求你能获得的最大分数。</p>
<span id="more"></span>

<h2 id="思路-1，滑动窗口"><a href="#思路-1，滑动窗口" class="headerlink" title="思路 1，滑动窗口"></a>思路 1，滑动窗口</h2><p>用滑动窗口检查 k 以外的连续元素的最小值，然后用数组和减去这个最小值。计算过程用 DP 简化，仅需计算数组前缀和。优势是思路简单，前缀和使用 in-place 不会占用额外空间。虽然思路简单，但是代码不算简洁。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScore</span>(<span class="params">self, cp: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(cp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Calculate prefix sum.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            cp[i] += cp[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == k:</span><br><span class="line">            <span class="keyword">return</span> cp[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        sz = n - k</span><br><span class="line">        m = cp[sz - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sz, n):</span><br><span class="line">            m = <span class="built_in">min</span>(m, cp[i] - cp[i - sz])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cp[-<span class="number">1</span>] - m</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，滑动窗口-V2"><a href="#思路-2，滑动窗口-V2" class="headerlink" title="思路 2，滑动窗口 V2"></a>思路 2，滑动窗口 V2</h2><p>就是直接按照提问的思路，计算所有组合并且求最大值，逻辑捋清楚之后也比较简单，这里只需要滑动窗口，每次减去离开窗口的值、加上进入窗口的值，然后取最大值。思路捋清楚后代码比较简洁.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScore</span>(<span class="params">self, cp: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = curr = <span class="built_in">sum</span>(cp[:k])</span><br><span class="line">        <span class="comment"># From k - 1 to 0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            curr += cp[i - k] - cp[i]</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, curr)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Sliding Window</tag>
        <tag>Prefix Sum</tag>
      </tags>
  </entry>
  <entry>
    <title>144. Binary Tree Preorder Traversal (Easy)</title>
    <url>/post/leetcode/144-Binary-Tree-Preorder-Traversal-Easy/</url>
    <content><![CDATA[<p>遍历树有三种方法，分别是前序 pre-order、中序 in-order 和后序 post-order 遍历。这道题是前序遍历。</p>
<p>前序遍历的递归写法没有难度。</p>
<span id="more"></span>

<h2 id="思路-1，递归"><a href="#思路-1，递归" class="headerlink" title="思路 1，递归"></a>思路 1，递归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            traverse(node.left)</span><br><span class="line">            traverse(node.right)</span><br><span class="line"></span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，遍历"><a href="#思路-2，遍历" class="headerlink" title="思路 2，遍历"></a>思路 2，遍历</h2><p>使用 stack 或队列按顺序记录需要检查的节点，需要关注的是：</p>
<ul>
<li>stack 是先进后出，要保证先左后右的顺序，需要先放入右 child，再放入左 child；</li>
<li>队列是先进先出，按正常顺序放入左右 child 即可。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans, stack = [], [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>145. Binary Tree Postorder Traversal (Easy)</title>
    <url>/post/leetcode/145-Binary-Tree-Postorder-Traversal-Easy/</url>
    <content><![CDATA[<p>遍历树通常有三种方法，分别是前序遍历（pre-order traversal）、中序遍历（in-order traversal）和后序遍历（post-order traversal）。这道题是后序遍历。</p>
<span id="more"></span>

<h2 id="思路-1，递归"><a href="#思路-1，递归" class="headerlink" title="思路 1，递归"></a>思路 1，递归</h2><p>三种递归遍历方式的区别仅在于处理的顺序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            traverse(node.left)</span><br><span class="line">            traverse(node.right)</span><br><span class="line">            ans.append(node.val)</span><br><span class="line"></span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，迭代遍历"><a href="#思路-2，迭代遍历" class="headerlink" title="思路 2，迭代遍历"></a>思路 2，迭代遍历</h2><p>后序遍历按照 left -&gt; right -&gt; root 的顺序遍历树，你会发现这和前序遍历相似，我们只需要将前序遍历方法中左右子节点的遍历顺序对调，并将其结果颠倒一下顺序，即可得到后序遍历的结果。</p>
<p>但是这样不够优雅。</p>
<p>我们延续 stack 的思路，通过观察我们知道要完成后序遍历，每次迭代过程中我们可以把当前节点、右节点、左节点按顺序放入 stack 中，针对当前节点，需要将其左右子节点置空表示已经遍历过。</p>
<p>我们的 Base Case 的条件是当前节点没有左右子节点，这表示该节点是叶子节点，或是已经遍历过的节点，针对这两种情况我们直接记录它的值。</p>
<p>重复这个过程，直到完成遍历。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans, stack = [], [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> curr:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left, right = curr.left, curr.right</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                ans.append(curr.val)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            curr.left, curr.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">            stack.append(curr)</span><br><span class="line">            stack.append(right)</span><br><span class="line">            stack.append(left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，迭代遍历，基于中序迭代遍历优化"><a href="#思路-3，迭代遍历，基于中序迭代遍历优化" class="headerlink" title="思路 3，迭代遍历，基于中序迭代遍历优化"></a>思路 3，迭代遍历，基于中序迭代遍历优化</h2><p>由于 root 的值是最后记录的，在当前节点存在右节点的情况，还需要将当前节点的右节点置空，重新存入 stack。在空间复杂度上比思路 2 而言没有太大优化。</p>
<p>这个思路下，我们先到达左节点的最下层左节点（即最后一个左节点，该节点的左节点为空），然后根据右节点发生下面分支：</p>
<ul>
<li>右节点不存在：The Base Case，这个节点是叶子节点或访问过的节点，记录它的值；</li>
<li>右节点存在：置空当前节点的右节点并存入 stack，将右节点标记为当前节点进入下一个迭代过程。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans, stack, curr = [], [], root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">or</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> curr:</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr = curr.left</span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> curr.right:</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                <span class="comment"># 置空当前节点的右节点，标记右节点为当前节点</span></span><br><span class="line">                curr.right, curr = <span class="literal">None</span>, curr.right</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            ans.append(curr.val)</span><br><span class="line">            <span class="comment"># 节点已经遍历完成，注意需要清空指针</span></span><br><span class="line">            curr = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts (Medium)</title>
    <url>/post/leetcode/1465-Maximum-Area-of-a-Piece-of-Cake-After-Horizontal-and-Vertical-Cuts-Medium/</url>
    <content><![CDATA[<p>切蛋糕问题。给你一个尺寸为 <code>h</code> x <code>w</code> 的矩形蛋糕，还有两个数组 <code>horizontalCuts</code> 和 <code>verticalCuts</code> 分别表示水平方式切的位置和垂直方向切的位置。</p>
<ul>
<li>水平切面的值从蛋糕的最上边开始计算；</li>
<li>相同的，垂直切面的值从蛋糕的最左边开始计算。</li>
</ul>
<p>求蛋糕切分之后的单块蛋糕的最大面积。因为结果可能是一个很大的数字，将其和 <code>109 + 7</code> 取模之和作为答案返回。</p>
<p>实际上是求两个数组的最大差之积，需要考虑的细节是四条边的值不在数组中，如果漏掉它们将不能得到正确答案。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将横切和竖切排序，不要忘记加上最大的长宽 <code>h</code> 和 <code>w</code>，对每条切线求出实际长度（当前长度减去前一条线的长度），保留最大值。对取得的最大长宽求面积，结果用 1e9 + 7 取模。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, h: <span class="built_in">int</span>, w: <span class="built_in">int</span>, horizontalCuts: <span class="type">List</span>[<span class="built_in">int</span>], verticalCuts: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        horizontalCuts.sort()</span><br><span class="line">        horizontalCuts.append(h)</span><br><span class="line">        verticalCuts.sort()</span><br><span class="line">        verticalCuts.append(w)</span><br><span class="line">        mh, mv = horizontalCuts[<span class="number">0</span>], verticalCuts[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(horizontalCuts) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            mh = <span class="built_in">max</span>(mh, horizontalCuts[i] - horizontalCuts[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(verticalCuts) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            mv = <span class="built_in">max</span>(mv, verticalCuts[i] - verticalCuts[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> (mh * mv) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>1480. Running Sum of 1d Array (Easy)</title>
    <url>/post/leetcode/1480-Running-Sum-of-1d-Array-Easy/</url>
    <content><![CDATA[<p>求动态和，也就是前缀和。让你熟悉一下什么是前缀和。</p>
<p>给定一个数组，根据下标遍历，将每个位置 <code>n</code> 的值更新为原数组位置 <code>0</code> 到 <code>n</code> 的和。</p>
<p>连续几天 Hard 题目突然蹦出来一道 Easy 还有点不适应，提交之前都在想肯定没这么简单，有那里没考虑到，结果就 Accepted 了。</p>
<span id="more"></span>

<h2 id="简直-leetcode-pstd。"><a href="#简直-leetcode-pstd。" class="headerlink" title="简直 leetcode pstd。"></a>简直 leetcode pstd。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runningSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Prefix Sum</tag>
      </tags>
  </entry>
  <entry>
    <title>150. Evaluate Reverse Polish Notation (Medium)</title>
    <url>/post/leetcode/150-Evaluate-Reverse-Polish-Notation-Medium/</url>
    <content><![CDATA[<p>演算反向波兰表示法。反向波兰表示法是一种为减少内存访问的使用 Stack 的演算表达法，这种方法按照先操作对象后操作符的方式表达算术运算。</p>
<p>所以我们讨论如何使用 Stack 解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>反向波兰表示法是一种使用 Stack 达到方便计算目的的一种数学方法。</p>
<p>使用递归或 Stack 都能简单的完成计算。使用 Stack 为例，算法过程如下：</p>
<ul>
<li>遍历 tokens<ul>
<li>遇到数字则加到栈顶</li>
<li>遇到操作符和取出栈顶的 2 个数字做运算，运算结果放回栈顶</li>
</ul>
</li>
<li>最终栈中存在的元素就是答案</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>&#125;:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(t))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right, left = stack.pop(), stack.pop()</span><br><span class="line">                <span class="comment"># print(left, t, right)</span></span><br><span class="line">                <span class="keyword">if</span> t == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.append(left + right)</span><br><span class="line">                <span class="keyword">elif</span> t == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.append(left - right)</span><br><span class="line">                <span class="keyword">elif</span> t == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stack.append(left * right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(trunc(left / right))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>用 Java 实现相同的算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String t : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(t)) &#123;</span><br><span class="line">                stack.offerLast(stack.pollLast() + stack.pollLast());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(t)) &#123;</span><br><span class="line">                stack.offerLast(-stack.pollLast() + stack.pollLast());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(t)) &#123;</span><br><span class="line">                stack.offerLast(stack.pollLast() * stack.pollLast());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(t)) &#123;</span><br><span class="line">                Integer right = stack.pollLast(), left = stack.pollLast();</span><br><span class="line">                stack.offerLast(left / right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.offerLast(Integer.valueOf(t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Stack</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>155. Min Stack (Easy)</title>
    <url>/post/leetcode/155-Min-Stack-Easy/</url>
    <content><![CDATA[<p>设计一个栈数据结构，需要支持入栈、出栈、查看栈顶和常量时间内获取最小值的操作。</p>
<blockquote>
<p>Implement the <code>MinStack</code> class:</p>
<ul>
<li><code>MinStack()</code> initializes the stack object.</li>
<li><code>void push(val)</code> pushes the element val onto the stack.</li>
<li><code>void pop()</code> removes the element on the top of the stack.</li>
<li><code>int top()</code> gets the top element of the stack.</li>
<li><code>int getMin()</code> retrieves the minimum element in the stack.</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="思路：栈-小根堆"><a href="#思路：栈-小根堆" class="headerlink" title="思路：栈 + 小根堆"></a>思路：栈 + 小根堆</h2><p>看上去这道题要实现一个栈和小根堆结合的一个数据结构，数据的添加和删除是基于栈的后进先出的原则，与此同时每次数据操作我们更新一个小根堆来对这些数据进行排序，来确定最小数据的位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.heap = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.append(val)</span><br><span class="line">        self.heap.append(val)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.heap) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> self.heap[i] &lt; self.heap[i - <span class="number">1</span>]:</span><br><span class="line">                self.heap[i], self.heap[i - <span class="number">1</span>] = self.heap[i - <span class="number">1</span>], self.heap[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        val = self.stack.pop()</span><br><span class="line">        self.heap.pop(self.heap.index(val))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h2 id="思路：单独的栈-val-min-pairs"><a href="#思路：单独的栈-val-min-pairs" class="headerlink" title="思路：单独的栈 + (val, min) pairs"></a>思路：单独的栈 + (val, min) pairs</h2><p>另一个思路，我们只要保证每一个元素加入栈时的最小值即可，换一句话说，就是我们每次添加一个元素时拿到上一个最小值比较，检查最小值是否变化即可，这样就算移出一个元素，上一轮计算的最小值还是有效的。</p>
<p>要完成这个思路，我们将栈设计为每次储存一个元组，第一个元素为原始的值，第二个元素为最小值。每次添加新元素，取上次最小值判断。这个思路在时间复杂度上比上一个思路要高效，因为计算量上我们省去了排序的步骤。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        curr_min = self.getMin()</span><br><span class="line">        self.stack.append((val, val <span class="keyword">if</span> curr_min <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="built_in">min</span>(curr_min, val)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="思路：单独的栈，2-倍长度"><a href="#思路：单独的栈，2-倍长度" class="headerlink" title="思路：单独的栈，2 倍长度"></a>思路：单独的栈，2 倍长度</h2><p>上面的思路中栈每次存入一个元组依然会造成更多的空间使用，这次我们每次加入元素时向栈中加入 2 个值，第一次我们放入最小值，第二次放入原始值。然后为了方便起见，我们根据题目的约束删掉一些不必要的空值 check。</p>
<p>这个思路可以有效优化空间复杂度，相对使用元组每次储存 2 个值，在一个数组中依次存入 2 个值会使用更少的空间。毕竟，元组本身也会占据内存空间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack) &gt; <span class="number">0</span>:</span><br><span class="line">            self.stack.append(<span class="built_in">min</span>(self.stack[-<span class="number">2</span>], val))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.append(val)</span><br><span class="line">        self.stack.append(val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>164. Maximum Gap (Hard)</title>
    <url>/post/leetcode/164-Maximum-Gap-Hard/</url>
    <content><![CDATA[<p>给定一个整数数组 <code>nums</code>，你需要将其排序后，找到相邻两个数之间的最大间隙（差）。如果不足两个元素则返回 0。</p>
<p>你必须在线性时间内，仅使用线性额外空间完成计算。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>桶排序实现常数 n 的 O(n)复杂度。</p>
<p>桶排序是指将数据划分为诺干子数组，称之为桶，在桶内使用一般排序算法（比如 O(n^2)的插入排序等）排序，等到每一个桶就完成各自的排序之后，将所有桶按照顺序组合起来，获得最终排序完成的数组。</p>
<p>这样做的优势，通过一个例子可以清晰的明白：我们有一个长度为 10 的数组需要排序；</p>
<ul>
<li>使用插入排序，O(n^2)的情况下最差的情况将进行 10*10=100 次操作；</li>
<li>使用桶排序，选择最大的桶将数组分为两个长度为 5 的子数组，分别应用排序，最差情况将进行 10（分桶）+5*5（插入排序）*2（2 个桶） =60 次操作。</li>
</ul>
<p>但是桶的尺寸为 2 对于这个场景并不是最优的选择，这个例子解释了就算用极限分桶，也比单独使用插入排序高效。</p>
<p>桶排序的重点在于决定桶的尺寸，这直接影响到排序效率，对于这道题来说，通过数学归纳可以得知，最大间距的最小可能应该是间距的平均值，而当所有数的间隔都是平均分布的时候才会遇到这个场景，比如 <code>[0, 5, 10, 15]</code>，其中总间距为最大值减去最小值，即 <code>15-0=15</code>，通过观察得知间距的数量为数组长度减去 <code>1</code>，即 <code>4-1=3</code>，那么平均间距为 <code>15/3=5</code>，对于这个数组来说，平均间距就是最大间距，但是一旦其中任何一个值变大或变小任意长度，比如 <code>[0, 4, 10, 15]</code>，第一个间距从 <code>5</code> 变为 <code>4</code>，就必定意味着第二个间距从 <code>5</code> 变为 <code>6</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, n, hi, lo = <span class="number">0</span>, <span class="built_in">len</span>(nums), <span class="built_in">max</span>(nums), <span class="built_in">min</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># Set 1 for case that max gap less than its length.</span></span><br><span class="line">        bsize = (hi - lo) // (n - <span class="number">1</span>) <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">        buckets = [[-<span class="number">1</span>, -<span class="number">1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>((hi - lo) // bsize + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            b = (x - lo) // bsize</span><br><span class="line">            buckets[b][<span class="number">0</span>] = <span class="built_in">min</span>(buckets[b][<span class="number">0</span>], x) <span class="keyword">if</span> buckets[b][<span class="number">0</span>] != -<span class="number">1</span> <span class="keyword">else</span> x</span><br><span class="line">            buckets[b][<span class="number">1</span>] = <span class="built_in">max</span>(buckets[b][<span class="number">1</span>], x)</span><br><span class="line">        prev = buckets[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(buckets)):</span><br><span class="line">            <span class="keyword">if</span> buckets[i][<span class="number">0</span>] == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, buckets[i][<span class="number">0</span>] - prev)</span><br><span class="line">            prev = buckets[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Sorting</tag>
        <tag>Bucket Sort</tag>
        <tag>Radix Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>1642. Furthest Building You Can Reach (Medium)</title>
    <url>/post/leetcode/1642-Furthest-Building-You-Can-Reach-Medium/</url>
    <content><![CDATA[<p>爬楼游戏。给你一个数组 <code>heights</code> 表示你面前的大楼的高度，你从 <code>0</code> 出发，你有一些砖块的梯子。当你从当前位置爬到下一个位置时需要满足下面的条件。</p>
<ul>
<li>如果当前楼层高度<strong>大于或等于</strong>下一个大楼的高度，你可以直接过去，不需要使用砖块或梯子；</li>
<li>如果当前楼岑高度<strong>小于</strong>下一个大楼的高度，你可以选择使用 1 个梯子，或者两栋楼高度差数量的砖块过去。</li>
</ul>
<p>重点在于梯子可以爬任意高度，砖块则需要消耗高度差的数量。求你可以到达的最远距离。贪心算法和优先队列可以解决这个问题。</p>
<span id="more"></span>

<h2 id="思路…算了直接-Solution"><a href="#思路…算了直接-Solution" class="headerlink" title="思路…算了直接 Solution"></a>思路…算了直接 Solution</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">furthestBuilding</span>(<span class="params">self, h: <span class="type">List</span>[<span class="built_in">int</span>], bricks: <span class="built_in">int</span>, ladders: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        lv = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(h)):</span><br><span class="line">            gap = h[x] - h[x-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> gap &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            lv.append(gap)</span><br><span class="line">            <span class="keyword">if</span> gap &lt;= bricks:</span><br><span class="line">                bricks -= gap</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> ladders != <span class="number">0</span>:</span><br><span class="line">                lv.sort()</span><br><span class="line">                ladders -= <span class="number">1</span></span><br><span class="line">                bricks += lv.pop() - gap</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> x - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(h) - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Ver 2.0 using max heap.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">furthestBuilding</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>], bricks: <span class="built_in">int</span>, ladders: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        heap = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(heights)):</span><br><span class="line">            <span class="keyword">if</span> heights[i] &gt; heights[i - <span class="number">1</span>]:</span><br><span class="line">                h = heights[i] - heights[i - <span class="number">1</span>]</span><br><span class="line">                heappush(heap, -h)</span><br><span class="line">                bricks -= h</span><br><span class="line">                <span class="keyword">if</span> bricks &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> ladders != <span class="number">0</span>:</span><br><span class="line">                    bricks -= heappop(heap)</span><br><span class="line">                    ladders -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(heights) - <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
        <tag>Heap (Priority Queue)</tag>
      </tags>
  </entry>
  <entry>
    <title>1689. Partitioning Into Minimum Number Of Deci-Binary Numbers (Medium)</title>
    <url>/post/leetcode/1689-Partitioning-Into-Minimum-Number-Of-Deci-Binary-Numbers-Medium/</url>
    <content><![CDATA[<p>给定一个字符串格式的十进制整数 <code>n</code>，要求你分析最少需要多少个“二进制式十进制数”（Deci-Binary）求和可以得到这个给定的数 <code>n</code>。</p>
<p>“二进制式十进制数”的定义：一个十进制的整数，并且每一位数都只能是 <code>0</code> 或 <code>1</code>，不能有前置 <code>0</code>。比如 <code>101</code> 和 <code>1100</code> 符合要求，但是 <code>112</code> 和 <code>3001</code> 不符合要求。</p>
<blockquote>
<p>这道题确定不是脑筋急转弯吗？！</p>
</blockquote>
<span id="more"></span>

<h2 id="Medium-Seriously"><a href="#Medium-Seriously" class="headerlink" title="???Medium??? Seriously?!"></a>???Medium??? Seriously?!</h2><p>解释一句，仔细观察你会发现，由于二进制式十进制数每一位最大值是 <code>1</code>，想要从 <code>0</code> 开始用最少数量的二进制式十进制数来求和得到 <code>n</code>，你只需要知道 <code>n</code> 每一位数字的最大值即可，所以答案会在 <code>1-9</code> 之间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPartitions</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : n.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c - <span class="string">&#x27;0&#x27;</span> &gt; ans) ans = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">9</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPartitions</span>(<span class="params">self, n: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> n)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>1695. Maximum Erasure Value (Medium)</title>
    <url>/post/leetcode/1695-Maximum-Erasure-Value-Medium/</url>
    <content><![CDATA[<p>有一个正整数数组 <code>nums</code>，你需要找到一个不存在重复元素的子数组，子数组的值之和是你获得的分数。求你可以获得的最大分数。这道题可以运用滑动窗口来解决。</p>
<span id="more"></span>

<h2 id="思路-1，双指针-Sliding-Window-nmap"><a href="#思路-1，双指针-Sliding-Window-nmap" class="headerlink" title="思路 1，双指针 Sliding Window + nmap"></a>思路 1，双指针 Sliding Window + nmap</h2><p>入参数值上限 10^4，所以我们可以准备一个能容纳最大数字的数组来储存每个数字出现的次数。</p>
<p>双指针方法，准备 <code>left</code>、<code>right</code> 两个指针，<code>right</code> 指针遍历整个数组，每次迭代计算合计值和最大值，当数字出现次数超过 1 时，迭代 <code>left</code> 指针直到数字出现次数回到 1，迭代过程中将移出窗口的数字从合计值中减去。重复这个过程直到 <code>right</code> 到达终点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumUniqueSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        score, left, total, mask = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, [<span class="number">0</span>] * <span class="number">10001</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> nums:</span><br><span class="line">            mask[right] += <span class="number">1</span></span><br><span class="line">            total += right</span><br><span class="line">            <span class="keyword">while</span> mask[right] &gt; <span class="number">1</span>:</span><br><span class="line">                mask[nums[left]] -= <span class="number">1</span></span><br><span class="line">                total -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            score = <span class="built_in">max</span>(score, total)</span><br><span class="line">        <span class="keyword">return</span> score</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumUniqueSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line">        <span class="keyword">int</span> score = <span class="number">0</span>, left = <span class="number">0</span>, total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right : nums) &#123;</span><br><span class="line">            total += right;</span><br><span class="line">            map[right]++;</span><br><span class="line">            <span class="keyword">while</span> (map[right] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                total -= nums[left];</span><br><span class="line">                map[nums[left++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            score = Math.max(score, total);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Sliding Window</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>1696. Jump Game VI (Medium)</title>
    <url>/post/leetcode/1696-Jump-Game-VI-Medium/</url>
    <content><![CDATA[<p>跳跃游戏问题。你有一个数组 <code>nums</code> 和一个步数 <code>k</code>，最初你站在 0 的位置。游戏每一回合你可以向前跳最多 <code>k</code> 步，你的得分就是向前跳的步数对于 <code>nums</code> 中的值。求你可以获得的最大得分。</p>
<span id="more"></span>

<h2 id="思路-1，DP-Heap"><a href="#思路-1，DP-Heap" class="headerlink" title="思路 1，DP + Heap"></a>思路 1，DP + Heap</h2><p>这道题很容易想到用 DP 来解决，我们记录 k 步以内的值，每一次用最大值来计算下一个值，可以用 O(n*k) 的复杂度完成计算，但是可惜 k 的最大值能到 10^5，O(n*k) 无法通过测试 case。</p>
<p>我们需要减少计算最大值的次数，可以考虑用大根堆数据结构来处理最大值的计算，但是这道题的复杂度在于我我们需要根据下标来判断这个值能不能选用，毕竟如果下标不在跳跃的范围内，这个最大值对我们来说就失效了。</p>
<p>为了处理这个问题，我们在创建大根堆的时候以 <code>(value, index)</code> 形式将值和下标建立联系。在每次迭代过程中，我们将失效的最大值从堆中移出掉，再去计算当前应该放入堆中的值。</p>
<p>使用 Python 时需要注意 heapq 没有原生提供大根堆的支持，我们可以在存值的使用使用负号颠倒一下值的大小，达到大根堆的效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxResult</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, q = nums[<span class="number">0</span>], [(-nums[<span class="number">0</span>], <span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">while</span> i - q[<span class="number">0</span>][<span class="number">1</span>] &gt; k:</span><br><span class="line">                heappop(q)</span><br><span class="line">            ans = nums[i] - q[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            heappush(q, (-ans, i))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Sliding Window</tag>
        <tag>DP</tag>
        <tag>Heap (Priority Queue)</tag>
        <tag>Queue</tag>
        <tag>Monotonic Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>1710. Maximum Units on a Truck (Easy)</title>
    <url>/post/leetcode/1710-Maximum-Units-on-a-Truck-Easy/</url>
    <content><![CDATA[<p>卡车装箱问题。你有一辆卡车和一个货物清单（2D 数组），货物清单每个项目列出了这种货物的数量和每个货物所占的容量。</p>
<p>你需要求出给定尺寸的卡车最多能装下多少个货物。这道题运用贪心算法。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将 <code>boxTypes</code> 按照 <code>units</code> 排序，从最大的 <code>units</code> 开始装入卡车，直到装满 <code>truckSize</code> 的数量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumUnits</span>(<span class="params">self, boxTypes: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], truckSize: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        boxTypes.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> nums, units <span class="keyword">in</span> boxTypes:</span><br><span class="line">            <span class="keyword">if</span> truckSize &lt;= nums:</span><br><span class="line">                <span class="keyword">return</span> ans + truckSize * units</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += nums * units</span><br><span class="line">                truckSize -= nums</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>19. Remove Nth Node From End of List (Medium)</title>
    <url>/post/leetcode/19-Remove-Nth-Node-From-End-of-List-Medium/</url>
    <content><![CDATA[<p>删除链表的指定节点，返回修改后的链表 <code>head</code>。</p>
<blockquote>
<p>Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the <strong>end of the list</strong> and return its <code>head</code>.</p>
<p><strong>Follow up</strong>: Could you do this in one pass?</p>
</blockquote>
<span id="more"></span>

<p>With solutions both in Java and Python.</p>
<p>移除一个 linked list 末尾第 n 个节点，返回这个 linked list 的 head。最好是 One-pass 算法， 即一个流程里面获得想要的结果。</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5], n = 2</span><br><span class="line">Output: [1,2,3,5]</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1], n = 1</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p>Example 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2], n = 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>

<p>Constraints:</p>
<ul>
<li>The number of nodes in the list is <code>sz</code>.</li>
<li>1 &lt;= <code>sz</code> &lt;= 30</li>
<li>0 &lt;= <code>Node.val</code> &lt;= 100</li>
<li>1 &lt;= <code>n</code> &lt;= <code>sz</code></li>
</ul>
<h2 id="思路-amp-Solutions"><a href="#思路-amp-Solutions" class="headerlink" title="思路 &amp; Solutions"></a>思路 &amp; Solutions</h2><p>最简单的方法是先遍历一遍 Linked list 获得列表长度，然后重新遍历一次，在 <code>L - n - 1</code> 处停下，删掉下一个节点。</p>
<p>但是这样就不算 One-pass 算法了。</p>
<p>为了达成 One-pass 算法，我们可以维护 2 个指针。</p>
<ul>
<li>用 2 个指针，first 指向底部，一直遍历到最后；</li>
<li>second 指向需要删除的节点的上一个节点，与 first 维持 <code>n + 1</code> 的距离。</li>
</ul>
<p>为了避免处理例子 2 中的那种删除唯一节点的情况，我们初始化一个 dummy 节点，从这里开始遍历。</p>
<p>下面是 Python 代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = first = second = ListNode()</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        dis = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> first.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            first = first.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 注意由于second指向需要删除的节点的上一个节点，所以需要与first保持n+1的距离</span></span><br><span class="line">            <span class="keyword">if</span> dis != n + <span class="number">1</span>:</span><br><span class="line">                dis += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                second = second.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        second.<span class="built_in">next</span> = second.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>下面是相同逻辑的 Java 代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode first = dummy;</span><br><span class="line">        ListNode second = dummy;</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dis = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (first.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            <span class="comment">// 注意由于second指向需要删除的节点的上一个节点，所以需要与first保持n+1的距离</span></span><br><span class="line">            <span class="keyword">if</span> (dis != n + <span class="number">1</span>) &#123;</span><br><span class="line">                dis++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                second = second.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Two Pointers</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>20. Valid Parentheses (Easy)</title>
    <url>/post/leetcode/20-Valid-Parentheses-Easy/</url>
    <content><![CDATA[<p>给你一个字符串仅由 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、<code>&#39;&#123;&#39;</code>、<code>&#39;&#125;&#39;</code>、<code>&#39;[&#39;</code> 和 <code>&#39;]&#39;</code> 组成。你需要判断这个字符串是否是有效的。</p>
<p>字符串如果满足下面两个条件则判断为有效的字符串。</p>
<ul>
<li>所有开始的括号必须有相同类型的括号闭合；</li>
<li>所有开始的括号和闭合的括号需要按照正确的顺序排列。</li>
</ul>
<p>有效的例子：</p>
<p><code>&quot;()&quot;</code>, <code>&quot;()[]&#123;&#125;&quot;</code>, <code>&quot;&#123;[]&#125;&quot;</code></p>
<p>无效的例子：</p>
<p><code>&quot;(]&quot;</code>, <code>&quot;([)]&quot;</code></p>
<span id="more"></span>

<h2 id="思路：栈"><a href="#思路：栈" class="headerlink" title="思路：栈"></a>思路：栈</h2><p>这道题很适合使用栈来解决，我们遇到开始的括号直接放入栈中，遇到结束的括号时比对是否和栈顶的开始括号属于同一类型。如果不属于同一类型则匹配失败，直接放回否。所有字符遍历结束后判断栈是否清空，清空时表示所有括号都闭合了，否则就表示无效。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = &#123;<span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> B:</span><br><span class="line">                stack.append(x)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> <span class="keyword">or</span> x != B[stack.pop()]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>200. Number of Islands (Medium)</title>
    <url>/post/leetcode/200-Number-of-Islands-Medium/</url>
    <content><![CDATA[<p>有一个 <code>m x n</code> 的 2D 数组 <code>grid</code>，其中每个元素的值为 <code>&#39;1&#39;</code> 时表示土地，为 <code>&#39;0&#39;</code> 时表示海水。你需要找到一共存在多少个小岛。小岛的定义：小岛由相邻的土地构成，四面环海。土地相邻表示相互共有一条边。</p>
<span id="more"></span>

<h2 id="思路-BFS-追踪已访问元素"><a href="#思路-BFS-追踪已访问元素" class="headerlink" title="思路 BFS + 追踪已访问元素"></a>思路 BFS + 追踪已访问元素</h2><p>这个思路偏重不去修改输入数据，所以我们需要准备一个 <code>visited</code> 2D 数组来追踪遍历的状态，来避免重复遍历相同的元素。</p>
<p>主要的计算过程在于我们依次遍历 2D 输入数据，使用一个 <code>search</code> 辅助方法来搜索并标记所有已经遍历过的元素。<code>search</code> 做的事情实际上是使用 BFS 算法每次将所有相邻的土地放入队列，重复直到不存在相邻的陆地为止，细节可以参考代码注释。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        q, ans = deque(), <span class="number">0</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        visited = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            visited[i][j] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果目标并非陆地则直接返回找到 0 个小岛</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j] != <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 初始化队列准备开始 BFS</span></span><br><span class="line">            q.append([i, j])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                <span class="comment"># 拿到下一个坐标</span></span><br><span class="line">                x, y = q.popleft()</span><br><span class="line">                <span class="comment"># 遍历 4 个方向的坐标</span></span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>)]:</span><br><span class="line">                    <span class="comment"># 计算相邻坐标</span></span><br><span class="line">                    x1, y1 = x + dx, y + dy</span><br><span class="line">                    <span class="comment"># 如果相邻坐标不存在或已经遍历过则跳过</span></span><br><span class="line">                    <span class="keyword">if</span> x1 &lt; <span class="number">0</span> <span class="keyword">or</span> x1 == m <span class="keyword">or</span> y1 &lt; <span class="number">0</span> <span class="keyword">or</span> y1 == n <span class="keyword">or</span> visited[x1][y1]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 检查是否存在相邻的陆地</span></span><br><span class="line">                    <span class="keyword">if</span> grid[x1][y1] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        q.append([x1, y1])</span><br><span class="line">                    <span class="comment"># 标记已遍历</span></span><br><span class="line">                    visited[x1][y1] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 所有小岛范围的陆地遍历结束，返回找到 1 个小岛</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[i][j]:</span><br><span class="line">                    ans += search(i, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-BFS-优化空间复杂度"><a href="#思路-BFS-优化空间复杂度" class="headerlink" title="思路 BFS + 优化空间复杂度"></a>思路 BFS + 优化空间复杂度</h2><p>这个版本在上一个思路上直接修改输入数据来优化额外的空间使用。具体看代码注释。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        q, ans = deque(), <span class="number">0</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="comment"># 标记已遍历</span></span><br><span class="line">            grid[i][j] = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="comment"># 初始化 BFS 队列</span></span><br><span class="line">            q.append([i, j])</span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                <span class="comment"># 拿到下一个坐标</span></span><br><span class="line">                x, y = q.popleft()</span><br><span class="line">                <span class="comment"># 遍历 4 个方向的坐标</span></span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>)]:</span><br><span class="line">                    <span class="comment"># 计算相邻坐标</span></span><br><span class="line">                    x1, y1 = x + dx, y + dy</span><br><span class="line">                    <span class="comment"># 如果相邻坐标不存在或不为陆地则跳过</span></span><br><span class="line">                    <span class="keyword">if</span> x1 &lt; <span class="number">0</span> <span class="keyword">or</span> x1 == m <span class="keyword">or</span> y1 &lt; <span class="number">0</span> <span class="keyword">or</span> y1 == n <span class="keyword">or</span> grid[x1][y1] != <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 保存坐标进行下一轮搜索</span></span><br><span class="line">                    q.append([x1, y1])</span><br><span class="line">                    <span class="comment"># 标记已遍历</span></span><br><span class="line">                    grid[x1][y1] = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    search(i, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>Python 的成绩不是很理想，尝试用 Java 实现这个算法。结果还是很糟糕。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] MATRIX = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    search(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;);</span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] idx = q.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] delta : MATRIX) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = idx[<span class="number">0</span>] + delta[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = idx[<span class="number">1</span>] + delta[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x == grid.length || y == grid[<span class="number">0</span>].length) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[x][y] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    grid[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路-DFS"><a href="#思路-DFS" class="headerlink" title="思路 DFS"></a>思路 DFS</h2><p>DFS 思路比较简洁明了，<code>search</code> 中如果发现当前坐标是陆地，则继续向四个方向搜索。从结果上来看这道题的 DFS 的效率与 BFS 相差无几。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m, n, ans = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> i == m <span class="keyword">or</span> j == n <span class="keyword">or</span> grid[i][j] != <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            grid[i][j] = <span class="string">&quot;&quot;</span></span><br><span class="line">            search(i + <span class="number">1</span>, j)</span><br><span class="line">            search(i - <span class="number">1</span>, j)</span><br><span class="line">            search(i, j + <span class="number">1</span>)</span><br><span class="line">            search(i, j - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    search(i, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                ans += search(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i == m || j == n || grid[i][j] != <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        search(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        search(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        search(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        search(grid, i, j - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路-Union-Find"><a href="#思路-Union-Find" class="headerlink" title="思路 Union-Find"></a>思路 Union-Find</h2><p>并查集的思路在于准备一个 1D 数组，每次查找到一个陆地则将其索引对应的位置设为陆地的起始值，这样连成一个小岛的陆地对应的数据都指向同一个值。这样当我们搜索完 2D 数组之后，对这个 1D 数组计算不重复的元素数量即为答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        par = [-<span class="number">1</span>] * (m * n)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">x</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;查找并更新起始位置&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> par[x] == x:</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            par[x] = find(par[x])</span><br><span class="line">            <span class="keyword">return</span> par[x]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">x, y</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;合并2个集合&quot;&quot;&quot;</span></span><br><span class="line">            f1, f2 = find(x), find(y)</span><br><span class="line">            <span class="keyword">if</span> f1 != f2:</span><br><span class="line">                par[f1] = par[f2]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    par[i * n + j] = i * n + j</span><br><span class="line">                    <span class="keyword">if</span> i - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> grid[i - <span class="number">1</span>][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        union(i * n + j, (i - <span class="number">1</span>) * n + j)</span><br><span class="line">                    <span class="keyword">if</span> j - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> grid[i][j - <span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        union(i * n + j, i * n + j - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(par)):</span><br><span class="line">            <span class="keyword">if</span> par[i] != -<span class="number">1</span>:</span><br><span class="line">                res.add(find(i))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(res)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>或许这道题是经典题目，上面几个思路的算法结果来看效率相差不大，但是成绩不是很理想。猜测是同样算法提交了很多次，根据解题机器的负载情况对成绩有一定影响，或许多跑几次会得到一个好成绩吧。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Matrix</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title>204. Count Primes (Easy)</title>
    <url>/post/leetcode/204-Count-Primes-Easy/</url>
    <content><![CDATA[<p>计算所有小于非负整数 <code>n</code> 的质数的数量。</p>
<blockquote>
<p>质数（Prime）： 只能被 1 和其本身整除的数。</p>
</blockquote>
<p>可以暴力、枚举解题，也可以找到一定规律优化一下暴力算法。</p>
<span id="more"></span>

<h2 id="思路-Sieve-of-Eratosthenes"><a href="#思路-Sieve-of-Eratosthenes" class="headerlink" title="思路 Sieve of Eratosthenes"></a>思路 Sieve of Eratosthenes</h2><p>埃拉托色尼筛法。</p>
<p>准备一个长度为 <code>n</code> 的数组并且用 1 填充。</p>
<p>思路在于从 2 开始到 <code>n</code> 的平方根为止，将每个值到 <code>n</code> 为止的倍数作为下标，将数组中的值标记为 0，即非质数。</p>
<p>最终将数组求和，剩下的 1 都是质数。注意 0 和 1 不是质数，需要将其从结果中排除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">        isprime = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(math.sqrt(n)) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> isprime[i] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i ** <span class="number">2</span>, n, i):</span><br><span class="line">                    isprime[j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 0 and 1 are not prime.</span></span><br><span class="line">        ans = <span class="built_in">sum</span>(isprime) - <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
        <tag>Enumeration</tag>
        <tag>Number Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>206. Reverse Linked List (Easy)</title>
    <url>/post/leetcode/206-Reverse-Linked-List-Easy/</url>
    <content><![CDATA[<p>给定一个链表（LinkedList）的 <code>head</code> 节点，你需要反转并返回它。</p>
<span id="more"></span>

<h2 id="迭代思路"><a href="#迭代思路" class="headerlink" title="迭代思路"></a>迭代思路</h2><p>翻转链表只需要将每一个节点的 <code>next</code> 与该节点的关系颠倒一下即可，为此我们需要 <code>prev</code> 和 <code>next</code> 变量帮助我们保存中间的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        prev = <span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="comment"># hold the next one, and reassign the prev one as current node&#x27;s next</span></span><br><span class="line">            <span class="built_in">next</span>, head.<span class="built_in">next</span> = head.<span class="built_in">next</span>, prev</span><br><span class="line">            <span class="comment"># hold the current node as the prev and the next as current</span></span><br><span class="line">            prev, head = head, <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># the loop above ends with None as the head so the prev is the tail node</span></span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>

<p>实际上上面的 <code>next</code> 也可以消除掉，只需要 <code>prev</code> 一个变量即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            head.<span class="built_in">next</span>, prev, head = prev, head, head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>

<h2 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h2><p>这道题的迭代思路比较简单，所以完全没有必要考虑递归方法。但是如果你就想写递归，也没人能拉住你。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recu</span>(<span class="params">node, prev</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> prev</span><br><span class="line">            node.<span class="built_in">next</span>, prev = prev, node.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> recu(prev, node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recu(head, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>LinkedList</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>22. Generate Parentheses (Medium)</title>
    <url>/post/leetcode/22-Generate-Parentheses-Medium/</url>
    <content><![CDATA[<p>给你一个数字 <code>n</code>，你需要用 <code>n</code> 对括号进行组合，找到所有可能的组合。</p>
<p>没对括号需要正常关闭才算一个有效的组合。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把括号转换成数字，我们可以观察到其中的规律。转数字的方法在于对括号嵌套的层级进行计数，比如 <code>((()))</code> 一共嵌套了 3 层，所以转化为数字为 <code>123</code>，而 <code>()(())</code> 可以转化为 <code>112</code>。</p>
<blockquote>
<p>Input: n = 3</p>
<p>Output: [“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p>
</blockquote>
<blockquote>
<p>Layout: [123, 122, 121, 112, 111]</p>
</blockquote>
<p>规律在答案中的所有组合都属于 <code>1..n</code> 到 <code>1..1</code> 的枚举。比如 <code>123, 122, 121</code> 的过程中最高位 3 被枚举到 1，而下一个数第二位 2 降为 1，第三位从第二位原本的值开始继续枚举到 1。</p>
<p>我们可以将其转化为算法，计算出所有可能的嵌套布局，然后用一个 <code>draw</code> 方法来将布局转化为实际的括号字符串。转化过程有三种模式：</p>
<ul>
<li>对排列的最后一个元素的处理：插入一对括号，然后关闭其他所有括号；</li>
<li>对当前元素 &gt;= 下一个元素的处理：插入一对括号，关闭到下一个元素为止层级的括号；</li>
<li>对当前元素 &lt; 下一个元素对处理：插入左半边括号。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">layout:[<span class="built_in">int</span>] = [<span class="number">1</span>]</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(layout) == n:</span><br><span class="line">                ans.append(draw(layout))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(layout[-<span class="number">1</span>]) + <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                generate(layout + [i])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">layout:[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">            res = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> i == n - <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># Add a left parentheses and close all others.</span></span><br><span class="line">                    res += <span class="string">&quot;(&quot;</span>  + <span class="string">&quot;)&quot;</span> * layout[i]</span><br><span class="line">                <span class="keyword">elif</span> layout[i] &gt;= layout[i + <span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># Add a left parentheses and close all others.</span></span><br><span class="line">                    res += <span class="string">&quot;(&quot;</span>  + <span class="string">&quot;)&quot;</span> * (layout[i] - layout[i + <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># Add a left parentheses only.</span></span><br><span class="line">                    res += <span class="string">&quot;(&quot;</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        generate()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>上面的思路只是找到了题目的答案，但是算不上优雅。对字符串的编辑可以在计算布局的适合完成，或者说，一旦我们知道了布局的规律，我们就可以完全没有额外操作的找到所有组合。</p>
<p>但是在编辑字符串的适合很容易陷入到对多种情况的考虑，但是只要换一个角度想想问题就可以解决：括号会出现在哪里？</p>
<p>实际上合理的括号只会出现在两个位置：当前括号的里面（嵌套变深），当前括号的右边（非嵌套）。</p>
<p>下一个问题是，哪些括号放在里面，哪些放在右边呢？答案是，从 <code>n</code> 到 <code>1</code> 遍历，当前的 <code>index</code> 在括号里面，<code>n - index</code> 在括号的右边，当然反之亦然，影响的只是答案中每个元素出现的顺序而已。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> self.generateParenthesis(i):</span><br><span class="line">                <span class="keyword">for</span> right <span class="keyword">in</span> self.generateParenthesis(n - <span class="number">1</span> - i):</span><br><span class="line">                    ans.append(<span class="string">f&quot;(<span class="subst">&#123;left&#125;</span>)<span class="subst">&#123;right&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>236. Lowest Common Ancestor of a Binary Tree (Medium)</title>
    <url>/post/leetcode/236-Lowest-Common-Ancestor-of-a-Binary-Tree-Medium/</url>
    <content><![CDATA[<p>你有一棵二叉树，给你 2 个节点，让你寻找它们的最近公共祖先节点。根据 Wiki 描述最近公共祖先的定义如下。</p>
<blockquote>
<p>在图论和计算机科学中，最近公共祖先（英語：lowest common ancestor）是指在一个树或者有向无环图中同时拥有 v 和 w 作为后代的最深的节点。在这里，我们定义一个节点也是其自己的后代，因此如果 v 是 w 的后代，那么 w 就是 v 和 w 的最近公共祖先。</p>
<p>最近公共祖先是两个节点所有公共祖先中离根节点最远的，计算最近公共祖先和根节点的长度往往是有用的。比如为了计算树中两个节点 v 和 w 之间的距离，可以使用以下方法：分别计算由 v 到根节点和 w 到根节点的距离，两者之和减去最近公共祖先到根节点的距离的两倍即可得到 v 到 w 的距离。</p>
</blockquote>
<p>节点本身可以是自己的后代，也就是说对于要寻找的节点 A 和 B，如果节点 B 是节点 A 的子节点，那么它们的最近公共祖先节点是节点 A。</p>
<span id="more"></span>

<h2 id="思路-1，DFS"><a href="#思路-1，DFS" class="headerlink" title="思路 1，DFS"></a>思路 1，DFS</h2><p>这道题用 DFS 的思路比较直观。</p>
<ul>
<li>我们设计一个 DFS 算法遍历搜索节点的后代是否存在目标节点；</li>
<li>这个算法返回一个 <code>flag</code>；</li>
<li>当有节点第一次集齐了 2 个 <code>flag</code>，我们就找到了答案。</li>
</ul>
<p>将这个思路详细化，就可以得到我们的代码了。其中我们要考虑 2 个<code>flag</code>，出于方便考虑，我们使用整数值来做这个 <code>flag</code>，一旦这个值变成 2，就表示在当前的节点集齐了两个目标。</p>
<ul>
<li>DFS 的不执行的条件是节点不存在，或已找到答案（剪枝）；</li>
<li>这是一个从下而上的算法，我们首先搜索左右子节点，将结果汇集起来（<code>res</code>）；</li>
<li>然后判断当前节点是否符合要求，更新结果（<code>res</code>）；</li>
<li>接着是我们的 base case，如果结果等于 2，更新答案并结束递归；</li>
<li>如果没找到答案，返回结果，继续递归。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        self.ans = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="comment"># pruning</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node <span class="keyword">or</span> self.ans:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            res = dfs(node.left) + dfs(node.right)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node == p <span class="keyword">or</span> node == q:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> res == <span class="number">2</span>:</span><br><span class="line">                self.ans = node</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，迭代-父节点指针"><a href="#思路-2，迭代-父节点指针" class="headerlink" title="思路 2，迭代 + 父节点指针"></a>思路 2，迭代 + 父节点指针</h2><p>使用迭代思路可以优化递归的调用栈的额外空间使用。</p>
<p>迭代过程中，</p>
<ul>
<li>我们先做一个简单的前序遍历拿到所有需要的子节点和与其对应的父节点的指针；</li>
<li>然后将其中一个目标节点包括其所有父节点存入一个集合中；</li>
<li>用另一个目标节点一层一层匹配其本身或其父节点是否存在集合中；</li>
<li>当找到存在集合中的父节点（包含其本身），作为答案返回。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        stack, parents = [root], &#123;root: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># create the parent pointer table until we find both the target nodes</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">not</span> <span class="keyword">in</span> parents <span class="keyword">or</span> q <span class="keyword">not</span> <span class="keyword">in</span> parents:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">                parents[node.right] = node</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">                parents[node.left] = node</span><br><span class="line"></span><br><span class="line">        ancestors = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># make the ancestors set using one of the target nodes</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            ancestors.add(p)</span><br><span class="line">            p = parents[p]</span><br><span class="line">        <span class="comment"># check the parents using the another node</span></span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">not</span> <span class="keyword">in</span> ancestors:</span><br><span class="line">            q = parents[q]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，迭代-无父节点指针"><a href="#思路-3，迭代-无父节点指针" class="headerlink" title="思路 3，迭代 + 无父节点指针"></a>思路 3，迭代 + 无父节点指针</h2><p>思路 2 的父节点指针可以用另一个思路来避免使用。</p>
<p>这个方法中我们尝试维护每一个节点的状态：</p>
<ul>
<li>还未访问：<code>PENDING = 2</code></li>
<li>访问了一个节点：<code>HALF_DONE = 1</code>（实际上这个状态未显式使用）</li>
<li>访问了所有节点：<code>DONE = 0</code></li>
</ul>
<p>然后针对当前节点处于某个状态，进行不同的处理：</p>
<ul>
<li>如果当前节点还没访问所有节点：<code>!= DONE</code>；<ul>
<li>如果当前节点第一次进入循环：<code>== PENDING</code>；<ul>
<li>检查当前节点是否是目标节点：如果是的；<ul>
<li>检查是否已经找到上一个：<code>one_node_found</code>；<ul>
<li>返回父节点指针的节点，这是这个算法的 base case；</li>
</ul>
</li>
<li>如果这是找到的第一个节点：<ul>
<li>更新 flag，设置当前节点为父节点指针的对象；</li>
</ul>
</li>
</ul>
</li>
<li>将左节点作为下一个目标；</li>
</ul>
</li>
<li>如果并非第一次进入循环，说明左节点已经遍历过了，将右节点作为下一个目标；</li>
</ul>
</li>
<li>如果当前节点已经被完全访问；<ul>
<li>如果父节点指针指向当前节点，将指针指向父节点；</li>
<li>删除栈顶的节点；</li>
</ul>
</li>
<li>failed case：直接返回 None。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PENDING = <span class="number">2</span></span><br><span class="line">DONE = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        stack = [[root, PENDING]]</span><br><span class="line">        one_node_found, parent_index = <span class="literal">False</span>, -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, state = stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># if iteration not done for this node</span></span><br><span class="line">            <span class="keyword">if</span> state != DONE:</span><br><span class="line">                <span class="comment"># if not visiting yet</span></span><br><span class="line">                <span class="keyword">if</span> state == PENDING:</span><br><span class="line">                    <span class="comment"># check if current node is the target</span></span><br><span class="line">                    <span class="keyword">if</span> node == p <span class="keyword">or</span> node == q:</span><br><span class="line">                        <span class="keyword">if</span> one_node_found:</span><br><span class="line">                            <span class="comment"># if one is already found then return the result</span></span><br><span class="line">                            <span class="keyword">return</span> stack[parent_index][<span class="number">0</span>]</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="comment"># else update the parent index</span></span><br><span class="line">                            one_node_found = <span class="literal">True</span></span><br><span class="line">                            parent_index = <span class="built_in">len</span>(stack) - <span class="number">1</span></span><br><span class="line">                    <span class="comment"># next visits the left child if not visited yet</span></span><br><span class="line">                    child_node = node.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># next visits the right child if the left is visited</span></span><br><span class="line">                    child_node = node.right</span><br><span class="line"></span><br><span class="line">                <span class="comment"># update the state of the parent node</span></span><br><span class="line">                stack[-<span class="number">1</span>][<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># set the next node to visit</span></span><br><span class="line">                <span class="keyword">if</span> child_node:</span><br><span class="line">                    stack.append([child_node, PENDING])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># update the index if current one node is found</span></span><br><span class="line">                <span class="keyword">if</span> parent == <span class="built_in">len</span>(stack) - <span class="number">1</span>:</span><br><span class="line">                    parent -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># move to parent node</span></span><br><span class="line">                stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>279. Perfect Squares (Medium)</title>
    <url>/post/leetcode/279-Perfect-Squares-Medium/</url>
    <content><![CDATA[<p>给你一个数 <code>n</code>，你需要计算出最少需要多少个<strong>完全平方数</strong>可以组成 <code>n</code>。</p>
<p><strong>完全平方数</strong>是指数字本身是另一个数的平方，比如 <code>1</code>、<code>4</code>、<code>9</code> 是完全平方数，因为它们分别是 <code>1</code>、<code>2</code>、<code>3</code> 的平方，但是 <code>3</code>、<code>11</code> 不是完全平方数。</p>
<span id="more"></span>

<h2 id="BFS-思路"><a href="#BFS-思路" class="headerlink" title="BFS 思路"></a>BFS 思路</h2><p>要找到一个数最少需要多少个完全平方数组成，我们可以使用宽度优先的搜索算法来实现。比如当 <code>n = 12</code> 时，我们可以像下面的流程图实例的步骤这样，每一层枚举出所有可能的完全平方数，直到某一层数值归零，则这一层的层数就是最少需要的完全平方数的个数。</p>
<pre class="text-center"><code class="d-inline-block mt-0 mb-3 text-start">
                                                 n = 12
                  +-------------------------------------------------------------+
                  |                                 |                           |
             11(12-1^2)                         <span class="text-danger">8(12-2^2)</span>                   3(12-3^2)
      +----------------------+            +------------------+                  -
      |           +          |            |                  |                  +
 10(11-1^2)  7(11-2^2)  2(11-3^2)     7(8-1^2)            <span class="text-danger">4(8-2^2)</span>           2(3-1^2)
  +-------+    +---+        -        +---------+        +----------+            -
  |   +   |    |   |        +        |         |        |          |            +
     ...        ...        ...   6(7-1^2)  3(7-2^2)  3(4-1^2)   <span class="text-danger">0(4-2^2)</span>     1(2-1^2)
   +-----+       -          -      +--+        +        -                       -
   |     |       +          +      |  |        |        +                       +
     ...        ...        ...     ...        ...      ...                   0(1-1^2)
</code><div>BFS while n = 12</div></pre>

<p>我们使用队列来完成这个算法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">        q = deque([n])</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                curr = q.popleft()</span><br><span class="line">                j, val = <span class="number">1</span>, curr - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> val &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> val == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> step</span><br><span class="line">                    q.append(val)</span><br><span class="line">                    j, val = j + <span class="number">1</span>, curr - j ** <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="DP-思路"><a href="#DP-思路" class="headerlink" title="DP 思路"></a>DP 思路</h2><p>用动态规划分别求出需要多少个完全平方数构成 <code>1</code> 到 <code>n</code> 为止的所有数字。我们从 <code>1</code> 开始计算，每次计算下一个数时，由于差值为 <code>1</code>，所以一定能得到这个数需要由多少个完全平方数组成的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [math.inf] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            minval = math.inf</span><br><span class="line">            j = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i - j ** <span class="number">2</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                minval = <span class="built_in">min</span>(minval, dp[i - j ** <span class="number">2</span>] + <span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            dp[i] = minval</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<p>算法完成了，但是使用 Python 时会遇到超时报错，这是由于 Python 属于高级语言，执行效率相对较慢。我们换 Java 尝试实现一样的算法。这个算法可以通过所有测试 case，并且效率良好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i - j * j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                min = Math.min(min, dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DP-思路：静态优化"><a href="#DP-思路：静态优化" class="headerlink" title="DP 思路：静态优化"></a>DP 思路：静态优化</h2><p>观察上面的算法，我们会发现如果测试集中存在 <code>100</code> 和 <code>200</code> 的话，计算前者时我们会从 <code>1</code> 到 <code>100</code> 分别计算最少完全平方数，计算后者时从 <code>1</code> 到 <code>200</code> 分别计算最少完全平方数。发现了什么？是的，<code>1</code> 到 <code>100</code> 这个区间的数被重复计算了，作为优化，可以考虑使用全局变量或者静态变量来存储这些结果来避免重复计算。比如上面的 Java 算法我们将 <code>dp</code> 变量变成静态之后，从结果来看，测试数据集的处理效率有了很大提升。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; dp = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = dp.size(); i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i - j * j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                min = Math.min(min, dp.get(i - j * j) + <span class="number">1</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.add(min);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们尝试对之前的 Python 算法进行修改，将 <code>dp</code> 提升为全局变量，结果以较好的效率通过测试 case。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp), n + <span class="number">1</span>):</span><br><span class="line">            minval = math.inf</span><br><span class="line">            j = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i - j ** <span class="number">2</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                minval = <span class="built_in">min</span>(minval, dp[i - j ** <span class="number">2</span>] + <span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            dp.append(minval)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DP</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>297. Serialize and Deserialize Binary Tree (Hard)</title>
    <url>/post/leetcode/297-Serialize-and-Deserialize-Binary-Tree-Hard/</url>
    <content><![CDATA[<p>你需要设计一个序列化：将二叉树转换为字符串 / 反序列化：将字符串还原成二叉树的算法。题目对于序列化的格式没有限制，你只需要设计一个算法可以把二叉树序列化，然后反序列化构建出原本的二叉树即可。</p>
<span id="more"></span>

<h2 id="思路-1，DFS"><a href="#思路-1，DFS" class="headerlink" title="思路 1，DFS"></a>思路 1，DFS</h2><p>序列化过程中我们需要保留空元素，这样能保证每一个节点都存在 2 个子节点。有了这个前提，我们只需要前序遍历二叉树，将遍历的值依次拼接成字符串即可完成序列化。</p>
<blockquote>
<p>如果遍历结果不包括空元素，我们就无法仅从前序遍历的结果中重构一棵二叉树，因为 root 节点之后的值可能是左节点，也可能是右节点。但如果空节点也作为对象输出到序列化的结构，那么至少保证了每个节点都有 2 个子节点被记录，这意味着反序列化时遇到 root 节点的下一个节点一定是左节点，就算它是空。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                res.append(<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="built_in">str</span>(node.val))</span><br><span class="line">                dfs(node.left)</span><br><span class="line">                dfs(node.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;,&quot;</span>.join(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        data = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">data</span>):</span></span><br><span class="line">            val = data.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> val == <span class="string">&quot;&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            node = TreeNode(<span class="built_in">int</span>(val))</span><br><span class="line">            node.left = dfs(data)</span><br><span class="line">            node.right = dfs(data)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">return</span> dfs(data)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，BFS"><a href="#思路-2，BFS" class="headerlink" title="思路 2，BFS"></a>思路 2，BFS</h2><p>BFS 的方法更加直观，我们首先层序遍历，将包括空节点在内的所有值都序列化。</p>
<p>反序列化的过程中，我们按照顺序一层一层恢复这棵二叉树。规则在于维护一个指针和一个队列，从队列中取出元素，并移动指针读取后两位，作为这个节点左右子节点，然后将非空的子节点放入队列。重复这个过程直到结束。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        res, queue = [], deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                res.append(<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="built_in">str</span>(node.val))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;,&quot;</span>.join(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        data = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        root = TreeNode(<span class="built_in">int</span>(data[<span class="number">0</span>]))</span><br><span class="line">        queue, index = deque([root]), <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> data[index] != <span class="string">&quot;&quot;</span>:</span><br><span class="line">                node.left = TreeNode(<span class="built_in">int</span>(data[index]))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> data[index] != <span class="string">&quot;&quot;</span>:</span><br><span class="line">                node.right = TreeNode(<span class="built_in">int</span>(data[index]))</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
        <tag>String</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>303. Range Sum Query - Immutable (Easy)</title>
    <url>/post/leetcode/303-Range-Sum-Query-Immutable-Easy/</url>
    <content><![CDATA[<p>你有一个整数数组 <code>nums</code>，你需要实现一个程序处理范围求和的查询</p>
<p>每次查询得到两个下标 <code>left</code> 和 <code>right</code> 作为参数，查询区间 [<code>left</code>, <code>right</code>] 的和，其中 <code>left &lt;= right</code>。</p>
<p>前缀和的教学题，我们讨论前缀和如何解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>前缀和，然后查询区间，最右减去最左，注意一个 index 的 offset。</p>
<p>查询 0 开始的范围，需要减去 -1 下标的和，这不合理，所以遇到 -1 可以选择重置为 0，但这不优雅。</p>
<p>通过向数组左端添加一个 0，可以避免处理 query 范围左端为 -1 的场景。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.q = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            self.q.append(self.q[-<span class="number">1</span>] + n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.q[right + <span class="number">1</span>] - self.q[left]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Prefix Sum</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>304. Range Sum Query 2D - Immutable (Medium)</title>
    <url>/post/leetcode/304-Range-Sum-Query-2D-Immutable-Medium/</url>
    <content><![CDATA[<p>你有一个 2D 矩阵 <code>matrix</code>，你需要实现一个程序处理多次子矩阵求和的查询。</p>
<p>每次查询你会得到 2 个坐标，分别代表子矩阵的左上坐标和右下坐标，返回这个子矩阵的和。</p>
<p>典型的前缀和问题，所以我们讨论如何应用前缀和解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>类似 1074，先求 Prefix Sum，然后计算子矩阵和。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            matrix[<span class="number">0</span>][j] += matrix[<span class="number">0</span>][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    matrix[i][j] += matrix[i][j - <span class="number">1</span>] - matrix[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                matrix[i][j] += matrix[i - <span class="number">1</span>][j]</span><br><span class="line"></span><br><span class="line">        self._m = matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = self._m[row2][col2]</span><br><span class="line">        <span class="keyword">if</span> row1 &gt; <span class="number">0</span>:</span><br><span class="line">            ans -= self._m[row1 - <span class="number">1</span>][col2]</span><br><span class="line">        <span class="keyword">if</span> col1 &gt; <span class="number">0</span>:</span><br><span class="line">            ans -= self._m[row2][col1 - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> row1 &gt; <span class="number">0</span> <span class="keyword">and</span> col1 &gt; <span class="number">0</span>:</span><br><span class="line">            ans += self._m[row1 - <span class="number">1</span>][col1 - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = NumMatrix(matrix)</span></span><br><span class="line"><span class="comment"># param_1 = obj.sumRegion(row1,col1,row2,col2)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Prefix Sum</tag>
        <tag>Matrix</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>307. Range Sum Query - Mutable (Medium)</title>
    <url>/post/leetcode/307-Range-Sum-Query-Mutable-Medium/</url>
    <content><![CDATA[<p>你有一个整数数组 <code>nums</code>，你需要实现一个程序处理下面两种类型的多次查询：</p>
<ul>
<li>更新：更新数组中某个字段的值；</li>
<li>求和：通过下标 <code>left</code> 和 <code>right</code> 查询区间 [<code>left</code>, <code>right</code>] 的和，其中 <code>left &lt;= right</code>。</li>
</ul>
<p>看到求和或许你开始思考能否用前缀和解题，但是题目要求能对原数组进行更新，显然前缀和不是最好的方案。这题可以运用线段树解决。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定数组，可以更新元素，还要快速查询范围内的和、最大最小值，这是典型的 Segment Tree （线段树）的应用场景。</p>
<p>线段树可以用数组和 TreeNode 的结构表达。这里需要构建一个和线段树，方便起见用数组来表达线段树。</p>
<h3 id="Build-Tree"><a href="#Build-Tree" class="headerlink" title="Build Tree"></a>Build Tree</h3><p>线段树是一个二叉树结构，在给定数组上构建一个线段树，最终节点数约等于原数组长度的 2 倍，所以我们准备一个原数组长度 2 倍的数组，将原数组的元素放在从 <code>n</code> 开始的后半段。</p>
<p>前半段从 <code>n - 1</code> 开始遍历到 <code>0</code>，每个位置的值等于 <code>2 * i</code> + <code>2 * i + 1</code>，即其左右节点的和。树的构建就完成了。</p>
<h3 id="Update-Values"><a href="#Update-Values" class="headerlink" title="Update Values"></a>Update Values</h3><p>更新线段树时，只需要更新从目标叶子节点开始到根节点的路径。</p>
<p>我们从叶子节点出发，用下标除以 2，更新每一个途径的节点，直到根节点，我们一共更新 log n 个元素。</p>
<h3 id="Range-Sum-Query"><a href="#Range-Sum-Query" class="headerlink" title="Range Sum Query"></a>Range Sum Query</h3><p>查询给定范围的和，分左右边界进行讨论：</p>
<p>左边界：</p>
<ul>
<li>如果左边元素属于节点的 right child，这意味着它的父节点包含一个值在查询的范围之外，所以我们仅加上左边元素的值本身，然后将边界向右移动一位；</li>
<li>如果左边元素属于节点的 left child，我们查询它的父元素即可。</li>
</ul>
<p>右边界：</p>
<ul>
<li>相反，如果右边元素属于节点的 left child，我们仅加上元素本身的值，将边界向左移动一位；</li>
<li>如果右边元素属于节点的 right child，我们查询它的父元素。</li>
</ul>
<p>我们更新左右边界，重复这个过程直到左右边界接错开（left &gt; right），这时我们得到了答案。</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        tree = [<span class="number">0</span>] * <span class="number">2</span> * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            tree[i + n] = nums[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        self.n = n</span><br><span class="line">        self.tree = tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        n, tree = self.n, self.tree</span><br><span class="line">        index += n</span><br><span class="line">        tree[index] = val</span><br><span class="line">        <span class="keyword">while</span> index != <span class="number">0</span>:</span><br><span class="line">            index //= <span class="number">2</span></span><br><span class="line">            tree[index] = tree[<span class="number">2</span> * index] + tree[<span class="number">2</span> * index + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n, tree = self.n, self.tree</span><br><span class="line">        left += n</span><br><span class="line">        right += n</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> left % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                ans += tree[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                ans += tree[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            left //= <span class="number">2</span></span><br><span class="line">            right //= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Design</tag>
        <tag>Binary Indexed Tree</tag>
        <tag>Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>318. Maximum Product of Word Lengths (Medium)</title>
    <url>/post/leetcode/318-Maximum-Product-of-Word-Lengths-Medium/</url>
    <content><![CDATA[<p>字符串问题。给定一个字符串数组，求数组中字符串 A 和字符串 B 的长度的最大乘积，其中 A 和 B 中不能有任何相同的字母存在。</p>
<p>应用位掩码解决这个问题。</p>
<span id="more"></span>

<h2 id="思路-1，暴力法"><a href="#思路-1，暴力法" class="headerlink" title="思路 1，暴力法"></a>思路 1，暴力法</h2><p>找到所有组合求最大值，用一个帮助函数 <code>pair</code> 来帮助我们判断是否需要进行相乘。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pair</span>(<span class="params">w1, w2</span>):</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> w1:</span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">in</span> w2:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        ans, n = <span class="number">0</span>, <span class="built_in">len</span>(words)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> pair(words[i], words[j]):</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">len</span>(words[i]) * <span class="built_in">len</span>(words[j]))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，位掩码"><a href="#思路-2，位掩码" class="headerlink" title="思路 2，位掩码"></a>思路 2，位掩码</h2><p>英文小写字母只有 26 位，设想我们有一个长度为 26 的二进制数字，按照顺序将每一位映射成一个字母，0 表示有这个字母，1 则表示没有，这就是位掩码。判断相同字符串经常用到位掩码操作，在计算机中位操作往往有更好的效率。要判断两个字符串是否有共同的字母，只需要将他们的位掩码进行 <code>&amp;</code> 操作，这样相同位存在 1 的情况就会让结果大于 0，相反如果没有任何一位存在两边都为 1 的情况，则结果一定是 0。所以我们仅在结果为 0 的时候去计算长度相乘。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        bitmasks, ans = &#123;&#125;, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            bitmask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> w:</span><br><span class="line">                bitmask |= <span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> bitmasks.items():</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> bitmask &amp; k:</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">len</span>(w) * v)</span><br><span class="line">            bitmasks[bitmask] = <span class="built_in">max</span>(<span class="built_in">len</span>(w), bitmasks.get(bitmask, <span class="number">0</span>))</span><br><span class="line">            <span class="comment"># print(bitmask, ans)</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>另一种位掩码的实现，按照下标映射位掩码，省去了 HashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bitmasks = <span class="keyword">new</span> <span class="keyword">int</span>[words.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) &#123;</span><br><span class="line">                bitmasks[i] |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((bitmasks[i] &amp; bitmasks[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = Math.max(ans, words[i].length() * words[j].length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>341. Flatten Nested List Iterator (Medium)</title>
    <url>/post/leetcode/341-Flatten-Nested-List-Iterator-Medium/</url>
    <content><![CDATA[<p>你需要实现一个迭代器来扁平化一个嵌套的整数数组。嵌套整数数组中可能存在整数元素和嵌套整数数组两种元素。</p>
<p>如果你选择的语言有生成器机制，那么这题会很简单。我们分别从生成器和 Stack 的应用来解决这道题。</p>
<span id="more"></span>

<p>With solutions both in Python and JavaScript.</p>
<p>先读题：</p>
<blockquote>
<p>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.</p>
<p>Implement the <code>NestedIterator</code> class:</p>
<ul>
<li><code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> Initializes the iterator with the nested list <code>nestedList</code>.</li>
<li><code>int next()</code> Returns the next integer in the nested list.</li>
<li><code>boolean hasNext()</code> Returns <code>true</code> if there are still some integers in the nested list and <code>false</code> otherwise.</li>
</ul>
</blockquote>
<p>题目比较明确，需要我们用迭代器接口来扁平化嵌套数组，需要实现 <code>next</code> 和 <code>hasNext</code> 接口。测试 Case 会调用 <code>hasNext</code> 来检查是否还有值没输出，然后调用 <code>next</code> 获取具体的值。</p>
<p>需求比较明确，例子看看就好。</p>
<p>Example 1:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Input: nestedList = [[1,1],2,[1,1]]</span><br><span class="line">Output: [1,1,2,1,1]</span><br><span class="line">Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Input: nestedList = [1,[4,[6]]]</span><br><span class="line">Output: [1,4,6]</span><br><span class="line">Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].</span><br></pre></td></tr></table></figure>

<h2 id="Submissions"><a href="#Submissions" class="headerlink" title="Submissions"></a>Submissions</h2><p>先贴一下我的结果，防止剧透，具体代码会贴在最后。</p>
<p><strong>Python</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
<th>Complexity</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>60 ms</td>
<td>92.67%</td>
<td>O(n)</td>
</tr>
<tr>
<td>Memory</td>
<td>17.5 MB</td>
<td>89.70%</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p><strong>JavaScript</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
<th>Complexity</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>88 ms</td>
<td>100.00%</td>
<td>O(n) for initialization, O(1) for retrieve values</td>
</tr>
<tr>
<td>Memory</td>
<td>49.6 MB</td>
<td>72.22%</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h2 id="思路-amp-Solutions"><a href="#思路-amp-Solutions" class="headerlink" title="思路 &amp; Solutions"></a>思路 &amp; Solutions</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>先来说说 Python 方案，说到最优的迭代方法，这就不得不说 Python 的生成器机制了。</p>
<p>下面是我的代码，可以看到逻辑上只是一个简单的递归，但是使用了生成器，让时间复杂度可以控制在 O(n)，同时由于没有使用额外的变量，空间复杂度为 O(1)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span>:</span></span><br><span class="line">    _gen = <span class="literal">None</span></span><br><span class="line">    _<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nestedList: [NestedInteger]</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">integer_retriever</span>(<span class="params">l</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">                <span class="keyword">if</span> i.isInteger():</span><br><span class="line">                    <span class="keyword">yield</span> i.getInteger()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">for</span> _i <span class="keyword">in</span> integer_retriever(i.getList()):</span><br><span class="line">                        <span class="keyword">yield</span> _i</span><br><span class="line"></span><br><span class="line">        self._gen = integer_retriever(nestedList)</span><br><span class="line">        self._retrieve()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_retrieve</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._<span class="built_in">next</span> = <span class="built_in">next</span>(self._gen)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            self._<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res = self._<span class="built_in">next</span></span><br><span class="line">        self._retrieve()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下。</p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
<th>Complexity</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>60 ms</td>
<td>92.67%</td>
<td>O(n)</td>
</tr>
<tr>
<td>Memory</td>
<td>17.5 MB</td>
<td>89.70%</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>再来看看一般思路。在初始化时将嵌套数组解构，然后每次从缓存中取值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;NestedInteger[]&#125;</span> <span class="variable">nestedList</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> NestedIterator = <span class="function"><span class="keyword">function</span> (<span class="params">nestedList</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._list = [];</span><br><span class="line">  <span class="keyword">const</span> denest = <span class="function">(<span class="params">nl</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (nest <span class="keyword">of</span> nl) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nest.isInteger()) &#123;</span><br><span class="line">        <span class="built_in">this</span>._list.push(nest.getInteger());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        denest(nest.getList());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  denest(nestedList);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@this <span class="variable">NestedIterator</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NestedIterator.prototype.hasNext = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._list.length &gt; <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@this <span class="variable">NestedIterator</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;integer&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NestedIterator.prototype.next = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._list.shift();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果如下。</p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
<th>Complexity</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>88 ms</td>
<td>100.00%</td>
<td>O(n) for initialization, O(1) for retrieve value</td>
</tr>
<tr>
<td>Memory</td>
<td>49.6 MB</td>
<td>72.22%</td>
<td>O(n)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Stack</tag>
        <tag>Design</tag>
        <tag>Queue</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title>37. Sudoku Solver (Hard)</title>
    <url>/post/leetcode/37-Sudoku-Solver-Hard/</url>
    <content><![CDATA[<p>数独问题。你需要实现一个游戏解决数独问题，数独游戏的规则如下：</p>
<ul>
<li>每一行中数字 <code>1 - 9</code> 只能出现一次；</li>
<li>每一列中数字 <code>1 - 9</code> 只能出现一次；</li>
<li>每个 <code>3 x 3</code> 的子矩阵中数字 <code>1 - 9</code> 只能出现一次。</li>
</ul>
<p>典型的回溯算法问题。</p>
<span id="more"></span>

<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>数独问题，适合回溯算法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Save board for further use.</span></span><br><span class="line">        self.board = board</span><br><span class="line">        <span class="comment"># print(self.solve())</span></span><br><span class="line">        self.solve()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findEmptyCell</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Find the next place need to be filled.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> self.board[i][j] == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> i, j</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkRow</span>(<span class="params">self, row, num</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Check if the target number is safe in row.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> num <span class="keyword">not</span> <span class="keyword">in</span> self.board[row]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkCol</span>(<span class="params">self, col, num</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Check if the target number is safe in column.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> self.board[row][col] == num:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkSquare</span>(<span class="params">self, row, col, num</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Check if the target number is safe in the nearest square.</span></span><br><span class="line"><span class="string">        We should find the first cell of the nearest square,</span></span><br><span class="line"><span class="string">        just subtract the result of modulo 3 from col and row to get it.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sr, sc = row - row % <span class="number">3</span>, col - col % <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sr, sr + <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sc, sc + <span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> self.board[i][j] == num:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The main body of our backtracking algorithm.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        row, col = self.findEmptyCell()</span><br><span class="line">        <span class="keyword">if</span> row == -<span class="number">1</span> <span class="keyword">and</span> col == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> [<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]:</span><br><span class="line">            <span class="keyword">if</span> (self.checkRow(row, num)</span><br><span class="line">                <span class="keyword">and</span> self.checkCol(col, num)</span><br><span class="line">                <span class="keyword">and</span> self.checkSquare(row, col, num)):</span><br><span class="line">                self.board[row][col] = num</span><br><span class="line">                <span class="keyword">if</span> self.solve():</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                self.board[row][col] = <span class="string">&quot;.&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>39. Combination Sum (Medium)</title>
    <url>/post/leetcode/39-Combination-Sum-Medium/</url>
    <content><![CDATA[<p>先读题，这种题真是脑细胞的初见杀。</p>
<blockquote>
<p>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.</p>
<p>The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p>
<p>It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</p>
</blockquote>
<span id="more"></span>

<h2 id="思路-amp-Solutions"><a href="#思路-amp-Solutions" class="headerlink" title="思路 &amp; Solutions"></a>思路 &amp; Solutions</h2><p>Backtrack</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">candidates</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum = <span class="function"><span class="keyword">function</span> (<span class="params">candidates, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">const</span> sz = candidates.length;</span><br><span class="line">  candidates.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">c, tar, comb, begin</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tar === <span class="number">0</span>) ans.push(comb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; sz; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tar &lt; c[i]) <span class="keyword">break</span>;</span><br><span class="line">      dfs(c, tar - c[i], [...comb, c[i]], i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dfs(candidates, target, [], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sz = candidates.length;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(candidates, target, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] c, <span class="keyword">int</span> tar, List&lt;Integer&gt; comb, <span class="keyword">int</span> begin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tar == <span class="number">0</span>) ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(comb));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tar &lt; c[i]) <span class="keyword">break</span>;</span><br><span class="line">            comb.add(c[i]);</span><br><span class="line">            dfs(c, tar - c[i], comb, i);</span><br><span class="line">            comb.remove(comb.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>45. Jump Game II (Medium)</title>
    <url>/post/leetcode/45-Jump-Game-II-Medium/</url>
    <content><![CDATA[<p>跳跃游戏。你有一个非负整数数组，最开始你在 0 的位置，数组每个数字意味你接下来能跳多远。</p>
<p>游戏的目标是到达数组的最后一个位置，你需要找到最少的跳跃次数到达终点。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n, ans, curr, nxt = <span class="built_in">len</span>(nums), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># No need of the last iteration so skip it here by `n - 1`.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            nxt = <span class="built_in">max</span>(nxt, i + nums[i])</span><br><span class="line">            <span class="keyword">if</span> i == curr:</span><br><span class="line">                curr = nxt</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, ans = <span class="number">0</span>, curr = <span class="number">0</span>, next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            next = Math.max(next, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == curr) &#123;</span><br><span class="line">                curr = next;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> jump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = nums.length,</span><br><span class="line">    curr = <span class="number">0</span>,</span><br><span class="line">    next = <span class="number">0</span>,</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    next = next &lt; i + nums[i] ? i + nums[i] : next;</span><br><span class="line">    <span class="keyword">if</span> (curr === i) &#123;</span><br><span class="line">      curr = next;</span><br><span class="line">      ans++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>453. Minimum Moves to Equal Array Elements (Easy)</title>
    <url>/post/leetcode/453-Minimum-Moves-to-Equal-Array-Elements-Easy/</url>
    <content><![CDATA[<p>你有一个长度为 <code>n</code> 的数组，允许你每次操作将 <code>n - 1</code> 个元素的值 +1，求最少需要多少操作次数让数组中的所有元素相等。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求每次给 <code>n - 1</code> 个元素加 1，重复这个步骤直到数组所有元素相等。我们不应该给 <code>max</code> 加 1，所以这一步实际上是给最大值以外的所有元素加 1，其等价于最大值减去 1。</p>
<p>一旦在脑子中把这个思路捋顺了，方案就简单了。实际上我们要找到的是每一个元素减到最小值需要减去的次数。</p>
<p>算法已经浮出水面，我们先找到最小值，然后计算每个元素和最小值的差的和，这个和就是答案。</p>
<blockquote>
<p>这是数学法，也称“感觉智商丢掉”法。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m, ans = <span class="built_in">min</span>(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            ans += n - m</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>基于这个思路，实际上我们把最小值减去了 <code>n</code> 次，那么找到最小值之后，我们对数组求和之后再减去数组长度乘以最小值，得到的结果就是答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(nums) - <span class="built_in">min</span>(nums) * <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>462. Minimum Moves to Equal Array Elements II (Medium)</title>
    <url>/post/leetcode/462-Minimum-Moves-to-Equal-Array-Elements-II-Medium/</url>
    <content><![CDATA[<p>你有一个数组，允许你每次操作将任意一个元素的值 +1 或 -1，求最少需要多少操作次数让数组中的所有元素相等。</p>
<span id="more"></span>

<h2 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h2><p>题目要求我们用最少的步数将数组元素修正到全部相等，换句话来说就是需要找到一个合适的目标，将其他数补上差值修正到与这个数相等，答案就是这些差值的和。</p>
<p>题目的难点在于如何意识到我们要寻找的目标是数组的中位数。</p>
<p>我们可以准备一个数组，首先将其排序，思考一下第一个数和最后一个数修正到目标数需要的步数。</p>
<p>我们会发现，第一个数和最后一个数中间的任何数都符合要求，因为最少步数实际上就是第一个数和最后一个数的差值。</p>
<p>我们进一步发现需要确认合适的目标，我们还需要继续确认第二个数和倒数第二个数修正到目标需要的步数。</p>
<p>我们重复这个过程，最终会有两种情况。</p>
<ul>
<li>如果数组的长度为奇数：最后找到的唯一一个数就是目标值；</li>
<li>如果数组的长度为偶数：最后找到的一对数之间的任何值都是目标值，也包括这对数本身。</li>
</ul>
<p>再仔细想想，我们在寻找的其实就是数组的中位数。现在算法浮出水面了。</p>
<ul>
<li>方便起见我们将数组进行排序；</li>
<li>根据长度找到数组中位数的值，不用考虑太多，直接取长度除以 2 的整数值；</li>
<li>计算所有元素与目标的差的绝对值，进行求和。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves2</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        m = nums[<span class="built_in">len</span>(nums) &gt;&gt; <span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            ans += <span class="built_in">abs</span>(i - m)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Sorting</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>48. Rotate Image (Medium)</title>
    <url>/post/leetcode/48-Rotate-Image-Medium/</url>
    <content><![CDATA[<p>矩阵问题。旋转图片 90 度。</p>
<p>图片本身是一组储存了颜色信息的矩阵数据，旋转一张图片即将矩阵中对应的颜色值移动到对应的位置上。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, m: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sz = <span class="built_in">len</span>(m)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sz // <span class="number">2</span> + sz % <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sz // <span class="number">2</span>):</span><br><span class="line">                m[i][j], m[j][~i], m[~i][~j], m[~j][i] = m[~j][i], m[i][j], m[j][~i], m[~i][~j]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Matrix</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>509. Fibonacci Number (Easy)</title>
    <url>/post/leetcode/509-Fibonacci-Number-Easy/</url>
    <content><![CDATA[<p>生成指定位置的斐波那契数。Hello World 级别的问题，难点是对时间和空间复杂度的控制。</p>
<blockquote>
<p>The Fibonacci numbers, commonly denoted <code>F(n)</code> form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,</p>
<ul>
<li>F(0) = 0, F(1) = 1</li>
<li>F(n) = F(n - 1) + F(n - 2), for n &gt; 1.</li>
<li>Given n, calculate F(n).</li>
</ul>
</blockquote>
<span id="more"></span>

<blockquote>
<p>官解比较变态。</p>
</blockquote>
<p>不多说，上正文。</p>
<h2 id="思路-amp-Solutions"><a href="#思路-amp-Solutions" class="headerlink" title="思路 &amp; Solutions"></a>思路 &amp; Solutions</h2><h3 id="方法一，递归（不推荐）"><a href="#方法一，递归（不推荐）" class="headerlink" title="方法一，递归（不推荐）"></a>方法一，递归（不推荐）</h3><p>实现一个 <code>F(n) = F(n - 1) + F(n - 2)</code>，缺点就是时间复杂度是 O(2^n)。</p>
<h3 id="方法二，递归-DP"><a href="#方法二，递归-DP" class="headerlink" title="方法二，递归+DP"></a>方法二，递归+DP</h3><p>实现一个 <code>F(n) = F(n - 1) + F(n - 2)</code>，但是每次计算结果缓存起来，不再重复相同的计算。</p>
<p>跳过。</p>
<h3 id="方法三，Bottom-Up"><a href="#方法三，Bottom-Up" class="headerlink" title="方法三，Bottom-Up"></a>方法三，Bottom-Up</h3><p>抛开递归，记录前一个值，按照斐波那契数列的规律计算到 n 为止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">          <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = <span class="number">0</span></span><br><span class="line">            ans = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">                ans, pre = ans + pre, ans</span><br><span class="line">            <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<blockquote>
<p>官解给出了矩阵幂和黄金比例的方法，跳过…</p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Math</tag>
        <tag>Recursion</tag>
        <tag>Memoization</tag>
      </tags>
  </entry>
  <entry>
    <title>51. N-Queens (Hard)</title>
    <url>/post/leetcode/51-N-Queens-Hard/</url>
    <content><![CDATA[<p>国际象棋问题。给你一个 <code>n x n</code> 大小的棋盘，你需要在上面摆放 Queen 棋子，并且让棋子之间不能相互攻击。</p>
<blockquote>
<p>Tips</p>
<p>Queen 可以在行、列、对角线和反对角线这四条线上随意行动，我们在放 Queen 时要保证这四个方向上没有 Queen 存在。</p>
</blockquote>
<p>我们需要遍历尽可能多的摆放方法才能确认最终的答案，我们用回溯算法对枚举进行剪纸来解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一个典型回溯法的应用场景，即我们需要尝试把 Queen 放在这一行的每个位置之后，才能知道所有可能的摆法。</p>
<p>比较容易忽视的点是，虽然我们可以轻松观察得知一行只有一个 Queen，所以行是不需要判断的，只需要判断列、对角线和反对角线上是否存在 Queen，但是这三条线是需要分开判断的。</p>
<p>我们需要准备 3 个 set 来保存已经使用过的列、对角线和反对角线。逻辑比较简单，我们通过代码和注释来理解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">        <span class="comment"># Prepare the answer list and an empty board in the required format.</span></span><br><span class="line">        ans, board = [], [[<span class="string">&#x27;.&#x27;</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">format</span>(<span class="params">res</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;Produce the output to meet to required format.&quot;&quot;&quot;</span></span><br><span class="line">            out = []</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> res:</span><br><span class="line">                out.append(<span class="string">&#x27;&#x27;</span>.join(row))</span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">row, cols, diag, anti, res</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;Solve recursively.&quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># The base case that we know we&#x27;ve got a right answer.</span></span><br><span class="line">            <span class="keyword">if</span> row == n:</span><br><span class="line">                ans.append(<span class="built_in">format</span>(res))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Try each position at this row.</span></span><br><span class="line">            <span class="keyword">for</span> q <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># Calculate the top point of diagonal and anti-diagonal.</span></span><br><span class="line">                d, a = q - row, q + row</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Check if the current place can place a Queen.</span></span><br><span class="line">                <span class="keyword">if</span> q <span class="keyword">not</span> <span class="keyword">in</span> cols <span class="keyword">and</span> d <span class="keyword">not</span> <span class="keyword">in</span> diag <span class="keyword">and</span> a <span class="keyword">not</span> <span class="keyword">in</span> anti:</span><br><span class="line">                    cols.add(q)</span><br><span class="line">                    diag.add(d)</span><br><span class="line">                    anti.add(a)</span><br><span class="line">                    res[row][q] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line"></span><br><span class="line">                    solve(row + <span class="number">1</span>, cols, diag, anti, res)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># Backtracking.</span></span><br><span class="line">                    cols.remove(q)</span><br><span class="line">                    diag.remove(d)</span><br><span class="line">                    anti.remove(a)</span><br><span class="line">                    res[row][q] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line"></span><br><span class="line">        solve(<span class="number">0</span>, <span class="built_in">set</span>(), <span class="built_in">set</span>(), <span class="built_in">set</span>(), board)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>52. N-Queens II (Hard)</title>
    <url>/post/leetcode/52-N-Queens-II-Hard/</url>
    <content><![CDATA[<p>国际象棋问题。求在 <code>n x n</code> 的棋盘上摆放 Queen 棋子并让其不能相互攻击的布局数量。</p>
<p>和 51 是孪生问题，不再赘述。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>感觉在刷分 hhh。和 51 完全一样，不同之处在于这题只要计数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">place</span>(<span class="params">pos, cols, diag, anti</span>):</span></span><br><span class="line">            <span class="keyword">if</span> pos == n:</span><br><span class="line">                self.ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                d, a = i - pos, i + pos</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> cols <span class="keyword">and</span> d <span class="keyword">not</span> <span class="keyword">in</span> diag <span class="keyword">and</span> a <span class="keyword">not</span> <span class="keyword">in</span> anti:</span><br><span class="line">                    cols.add(i)</span><br><span class="line">                    diag.add(d)</span><br><span class="line">                    anti.add(a)</span><br><span class="line">                    place(pos + <span class="number">1</span>, cols, diag, anti)</span><br><span class="line">                    cols.remove(i)</span><br><span class="line">                    diag.remove(d)</span><br><span class="line">                    anti.remove(a)</span><br><span class="line"></span><br><span class="line">        place(<span class="number">0</span>, <span class="built_in">set</span>(), <span class="built_in">set</span>(), <span class="built_in">set</span>())</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>583. Delete Operation for Two Strings (Medium)</title>
    <url>/post/leetcode/583-Delete-Operation-for-Two-Strings-Medium/</url>
    <content><![CDATA[<p>字符串问题。你有两个字符串，允许你每次在任意一个字符串上删除一个字符，求需要多少步才能让两个字符串相等。</p>
<p>使用 DP 解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i, j] = i + j</span><br><span class="line">                <span class="keyword">elif</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i, j] = dp[i - <span class="number">1</span>, j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i, j] = <span class="number">1</span> + <span class="built_in">min</span>(dp[i - <span class="number">1</span>, j], dp[i, j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m, n]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>589. N-ary Tree Preorder Traversal (Easy)</title>
    <url>/post/leetcode/589-N-ary-Tree-Preorder-Traversal-Easy/</url>
    <content><![CDATA[<p>N 叉树前序遍历问题。和二叉树前序遍历的区别在于…多了几个 child，仅此而已。</p>
<blockquote>
<p>Given the root of an n-ary tree, return the preorder traversal of its nodes’ values.</p>
<p>Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)</p>
</blockquote>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        ans, stack = [], [root,]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            top = stack.pop()</span><br><span class="line">            ans.append(top.val)</span><br><span class="line">            stack.extend(top.children[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>609. Find Duplicate File in System (Medium)</title>
    <url>/post/leetcode/609-Find-Duplicate-File-in-System-Medium/</url>
    <content><![CDATA[<p>寻找系统中的重复文件。你会得到下面结构的字符串数组，这表示在 <code>root/d1/d2/.../dm</code> 目录下存在 <code>n</code> 个文件，分别命名为 <code>f1, f2, ..., fn</code>，文件名后括号内为文件的内容。你需要找到所有内容重复的文件，并返回文件的路径。</p>
<blockquote>
<p>“root/d1/d2/…/dm f1.txt(f1_content) f2.txt(f2_content) … fn.txt(fn_content)”</p>
</blockquote>
<span id="more"></span>

<h2 id="思路-1-使用哈希表"><a href="#思路-1-使用哈希表" class="headerlink" title="思路 1 使用哈希表"></a>思路 1 使用哈希表</h2><p>以文件内容为 key，拼出文件名存到字典中，最后遍历字典所有值，存在长度大于 1 的列表则表示存在内容重复。这道题还是比较亲切，实际工作中确实会遇到这类问题。</p>
<p>下面是代码例子。</p>
<blockquote>
<p>其实做的粗糙一点，去掉 <code>c = c[:-1]</code> 这句也能实现，而且少一个字符串处理性能会更好。毕竟我们不在意文件内容实际是什么，只在意有没有重复。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, paths: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">        table = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> paths:</span><br><span class="line">            f = f.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">            p = f[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> f[<span class="number">1</span>:]:</span><br><span class="line">                fn, c = i.split(<span class="string">&quot;(&quot;</span>)</span><br><span class="line">                c = c[:-<span class="number">1</span>]</span><br><span class="line">                table[c].append(<span class="string">f&quot;<span class="subst">&#123;p&#125;</span>/<span class="subst">&#123;fn&#125;</span>&quot;</span>)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> table.values():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(v) &gt; <span class="number">1</span>:</span><br><span class="line">                ans.append(v)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>Java 例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findDuplicate(String[] paths) &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; table = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String p : paths) &#123;</span><br><span class="line">            String[] f = p.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            String pr = f[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; f.length; i++) &#123;</span><br><span class="line">                String[] file = f[i].split(<span class="string">&quot;\\(&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (!table.containsKey(file[<span class="number">1</span>])) &#123;</span><br><span class="line">                    table.put(file[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                table.get(file[<span class="number">1</span>]).add(pr + <span class="string">&quot;/&quot;</span> + file[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; val : table.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                ans.add(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JS 例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">paths</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findDuplicate = <span class="function"><span class="keyword">function</span> (<span class="params">paths</span>) </span>&#123;</span><br><span class="line">  table = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paths) &#123;</span><br><span class="line">    p = p.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> pr = p[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; p.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> file = p[i].split(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (!table[file[<span class="number">1</span>]]) table[file[<span class="number">1</span>]] = [];</span><br><span class="line">      table[file[<span class="number">1</span>]].push(pr + <span class="string">&#x27;/&#x27;</span> + file[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> table) &#123;</span><br><span class="line">    <span class="keyword">if</span> (table[k].length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      ans.push(table[k]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>62. Unique Paths (Medium)</title>
    <url>/post/leetcode/62-Unique-Paths-Medium/</url>
    <content><![CDATA[<p>组合问题。机器人在矩阵的左上角需要去矩阵的右下角，且机器人只能向下和向右行动。</p>
<p>你需要实现一个程序计算机器人有多少条路径到达右下角。</p>
<span id="more"></span>

<h2 id="思路-DP"><a href="#思路-DP" class="headerlink" title="思路 DP"></a>思路 DP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [[<span class="number">1</span>]*n] * m</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[x][y] = dp[x-<span class="number">1</span>][y] + dp[x][y-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Math</tag>
        <tag>Combinatorics</tag>
      </tags>
  </entry>
  <entry>
    <title>622. Design Circular Queue (Medium)</title>
    <url>/post/leetcode/622-Design-Circular-Queue-Medium/</url>
    <content><![CDATA[<p>设计并实现一个循环队列。循环队列是一个线性数据结构，遵循先进先出原则，队列头尾相互连接形成一个环，也叫做环形缓冲区（Ring Buffer）。</p>
<p>在常规队列中，一旦队列满了也就无法再添加元素入列，就算队列头前面存在空位。但是使用循环队列，无论空位在队列头的前面还是后面，只要存在空位就可以被利用上。</p>
<p>这道题要求实现的循环队列要有下面的方法：</p>
<ul>
<li><code>MyCircularQueue(k)</code> 以指定值 <code>k</code> 初始化队列大小</li>
<li><code>int Front()</code> 返回队列头的元素，如果队列为空则返回 <code>-1</code></li>
<li><code>int Rear()</code> 返回队列尾的元素，如果队列为空则返回 <code>-1</code></li>
<li><code>boolean enQueue(int value)</code> 添加新的元素入列，如果成功则返回 <code>true</code></li>
<li><code>boolean deQueue()</code> 让队列头元素出列，如果成功则返回 <code>true</code></li>
<li><code>boolean isEmpty()</code> 检查队列是否为空</li>
<li><code>boolean isFull()</code> 检查队列是否已满</li>
</ul>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照每个方法分别讨论一下思路，这道题的注意点在于索引是循环的，我们通过取模来保证索引不会超过数组长度。</p>
<h3 id="MyCircularQueue-k"><a href="#MyCircularQueue-k" class="headerlink" title="MyCircularQueue(k)"></a><code>MyCircularQueue(k)</code></h3><p>初始化时只需要准备一个指定长度的数组，初始化队列头尾的指针即可。将 <code>k</code> 的值保留，后续需要使用它来取模。</p>
<h3 id="int-Front"><a href="#int-Front" class="headerlink" title="int Front()"></a><code>int Front()</code></h3><p>对于返回队列头的逻辑，我们只需要判断当前队列是否为空：为空时返回 <code>-1</code>；否则返回队列头指针对应的元素。</p>
<h3 id="int-Rear"><a href="#int-Rear" class="headerlink" title="int Rear()"></a><code>int Rear()</code></h3><p>对于返回队列尾的逻辑，我们只需要判断当前队列是否为空：为空时返回 <code>-1</code>；否则返回队列尾指针对应的元素。</p>
<h3 id="boolean-enQueue-int-value"><a href="#boolean-enQueue-int-value" class="headerlink" title="boolean enQueue(int value)"></a><code>boolean enQueue(int value)</code></h3><p>入列逻辑需要考虑几个条件。</p>
<ul>
<li>如果当前队列已满直接返回 <code>False</code>；</li>
<li>继续判断如果队列为空则将值放在 <code>0</code> 位置，将队列头尾指针都置为 <code>0</code>；</li>
<li>否则给队列尾指针右移一个位置，将新的值放在对应位置。<ul>
<li>指针向右移动时给尾指针的值 <code>+1</code>，这可能会造成指针的值超过数组长度，所以还需将其与 <code>k</code> 取模。</li>
</ul>
</li>
</ul>
<h3 id="boolean-deQueue"><a href="#boolean-deQueue" class="headerlink" title="boolean deQueue()"></a><code>boolean deQueue()</code></h3><p>出列逻辑相似。</p>
<ul>
<li>如果当前队列为空直接返回 <code>False</code>；</li>
<li>继续判断如果当前头尾指针指向同一个元素，则将 2 个指针都置为 <code>-1</code>；</li>
<li>否则将头指针向右移一个位置。<ul>
<li>指针向右移动时给头指针的值 <code>+1</code>，这可能会造成指针的值超过数组长度，所以还需将其与 <code>k</code> 取模。</li>
</ul>
</li>
</ul>
<h3 id="boolean-isEmpty"><a href="#boolean-isEmpty" class="headerlink" title="boolean isEmpty()"></a><code>boolean isEmpty()</code></h3><p>检查队列是否为空我们只需要检查 2 个指针是否为 <code>-1</code>。实际上如果一个指针为 <code>-1</code> 时，另一个同样也必须为 <code>-1</code>，所以实际上我们只需要判断头指针是否为 <code>-1</code>。</p>
<h3 id="boolean-isFull"><a href="#boolean-isFull" class="headerlink" title="boolean isFull()"></a><code>boolean isFull()</code></h3><p>检查队列是否已满我们可以判断尾指针与头指针是否相差 1 个单位。可以手动计算尾指针加 1 后的值是够等于头指针，需要注意指针的值增加可能会导致超过长度 <code>k</code>，所以在对比头指针之前还需要做取模操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.queue = [<span class="literal">None</span>] * k</span><br><span class="line">        self.front = self.rear = -<span class="number">1</span></span><br><span class="line">        self.k = k</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enQueue</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            self.front = self.rear = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.rear += <span class="number">1</span></span><br><span class="line">            self.rear %= self.k</span><br><span class="line"></span><br><span class="line">        self.queue[self.rear] = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deQueue</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.queue[self.front] = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.front == self.rear:</span><br><span class="line">            self.front = self.rear = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.front += <span class="number">1</span></span><br><span class="line">            self.front %= self.k</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Front</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.front == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[self.front]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Rear</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.rear == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[self.rear]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.front == -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.rear + <span class="number">1</span>) % self.k == self.front</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Linked List</tag>
        <tag>Design</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>63. Unique Paths II (Medium)</title>
    <url>/post/leetcode/63-Unique-Paths-II-Medium/</url>
    <content><![CDATA[<p>路径问题。一个机器人在 <code>m x n</code> 矩阵的左上角 (0, 0) 位置，矩阵中存在诺干障碍物，机器人只能向下或者向右移动，你需要实现一个程序计算机器人有多少条路径可以到达右下角的 (m, n) 位置。</p>
<p>这是典型的 DP 问题。</p>
<span id="more"></span>

<h2 id="思路-DP"><a href="#思路-DP" class="headerlink" title="思路 DP"></a>思路 DP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, og: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(og)):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(og[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">and</span> y == <span class="number">0</span>:</span><br><span class="line">                    up, left = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    up = og[x-<span class="number">1</span>][y] <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                    left = og[x][y-<span class="number">1</span>] <span class="keyword">if</span> y &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> og[x][y] == <span class="number">0</span>:</span><br><span class="line">                    og[x][y] = up + left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    og[x][y] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> og[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DP</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>630. Course Schedule III (Hard)</title>
    <url>/post/leetcode/630-Course-Schedule-III-Hard/</url>
    <content><![CDATA[<p>课程安排问题。一共有 <code>n</code> 门不同的在线课程，你会得到一个 <code>courses</code> 数组包含每门课程的持续时间和最后期限。</p>
<p>你将从第 1 天开始课程学习，你 1 天只能专注一门课程，不能多门课程同时进行。</p>
<p>计算出你最多能完成多少门课程。</p>
<span id="more"></span>

<h2 id="思路-1，优先队列"><a href="#思路-1，优先队列" class="headerlink" title="思路 1，优先队列"></a>思路 1，优先队列</h2><p>虽然做出来了，但是成绩比较差，这一块需要研究一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scheduleCourse</span>(<span class="params">self, courses: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        c = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">sorted</span>(courses, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])]</span><br><span class="line">        heap = []</span><br><span class="line">        time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(c):</span><br><span class="line">            <span class="keyword">if</span> time + x[<span class="number">0</span>] &lt;= x[<span class="number">1</span>]:</span><br><span class="line">                time += x[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(heap) &gt; <span class="number">0</span> <span class="keyword">and</span> heap[-<span class="number">1</span>] &gt; x[<span class="number">0</span>] <span class="keyword">and</span> time - heap[-<span class="number">1</span>] + x[<span class="number">0</span>] &lt;= x[<span class="number">1</span>]:</span><br><span class="line">                time +=  - heap.pop() + x[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            heap.append(x[<span class="number">0</span>])</span><br><span class="line">            heap.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(heap)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2-大根堆"><a href="#思路-2-大根堆" class="headerlink" title="思路 2, 大根堆"></a>思路 2, 大根堆</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scheduleCourse</span>(<span class="params">self, courses: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        c = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">sorted</span>(courses, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])]</span><br><span class="line">        time, heap = <span class="number">0</span>, []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(c):</span><br><span class="line">            <span class="keyword">if</span> time + x[<span class="number">0</span>] &lt;= x[<span class="number">1</span>]:</span><br><span class="line">                time += x[<span class="number">0</span>]</span><br><span class="line">                heappush(heap, -x[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">elif</span> heap:</span><br><span class="line">                <span class="keyword">if</span> -heap[<span class="number">0</span>] &gt; x[<span class="number">0</span>]:</span><br><span class="line">                    time += heappop(heap) + x[<span class="number">0</span>]</span><br><span class="line">                    heappush(heap, -x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(heap)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
        <tag>Heap (Priority Queue)</tag>
      </tags>
  </entry>
  <entry>
    <title>65. Valid Number (Hard)</title>
    <url>/post/leetcode/65-Valid-Number-Hard/</url>
    <content><![CDATA[<p>字符串问题。一个字符串数字，你需要判断这个数字是否有效。需要满足一堆条件。</p>
<p>考验归纳的问题。我们从正则取巧和数学归纳的角度来解决这道题。</p>
<span id="more"></span>

<h2 id="正则思路"><a href="#正则思路" class="headerlink" title="正则思路"></a>正则思路</h2><p>取巧使用正则，一行方案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        ptn = <span class="string">r&#x27;^[+-]?(\d+\.|\d*\.\d+|\d+)([eE][+-]?\d+)?$&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> re.match(ptn, s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><p>使用数学归纳法的思路。先整理无效数字的模式。</p>
<ul>
<li><code>+/-</code> 出现在数字之后</li>
<li><code>.</code> 重复或出现在 exp 之后</li>
<li><code>e/E</code> 重复或前面没数字</li>
</ul>
<p>总结得知，我们需要对应是否为数字、小数、符号、指数设置 4 个 flag，然后依次迭代字符串的每一个字符，根据当前 flag 的值进行判断。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isNumber = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num, dec, sign, exp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> s.split(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// Check number.</span></span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&quot;0&quot;</span> &amp;&amp; c &lt;= <span class="string">&quot;9&quot;</span>) num = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// Check sign.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="string">&quot;+&quot;</span> || c === <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// If sign duplicated or appears after number or decimal.</span></span><br><span class="line">      <span class="keyword">if</span> (sign || num || dec) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      sign = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// Check decimal.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="string">&quot;.&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// If duplicated or appears after exponent.</span></span><br><span class="line">      <span class="keyword">if</span> (dec || exp) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      dec = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// Check exponent.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="string">&quot;e&quot;</span> || c === <span class="string">&quot;E&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// If duplicated or no number before it.</span></span><br><span class="line">      <span class="keyword">if</span> (exp || !num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      (exp = <span class="literal">true</span>), (num = <span class="literal">false</span>), (sign = <span class="literal">false</span>), (dec = <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// Failed.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !!num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>665. Non-decreasing Array (Medium)</title>
    <url>/post/leetcode/665-Non-decreasing-Array-Medium/</url>
    <content><![CDATA[<p>数组问题。你有一个整数数组，你有一次机会修改其中的一个值，你需要检查这个数组是否能构成一个非递减数组。</p>
<p>非递减，换个思路就是递增数组。检查数组元素顺序是否为递增，并允许一次例外。</p>
<span id="more"></span>

<h2 id="思路-1，从后往前判断，允许一次失败"><a href="#思路-1，从后往前判断，允许一次失败" class="headerlink" title="思路 1，从后往前判断，允许一次失败"></a>思路 1，从后往前判断，允许一次失败</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        modified = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums))):</span><br><span class="line">            <span class="comment"># print(nums[i] , nums[i - 1])</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> modified:</span><br><span class="line">                    <span class="keyword">if</span> i != <span class="built_in">len</span>(nums) - <span class="number">1</span> <span class="keyword">and</span> nums[i + <span class="number">1</span>] &lt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                        nums[i - <span class="number">1</span>] = nums[i]</span><br><span class="line">                    modified = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="思路-2，颠倒符号从前往后，允许一次失败"><a href="#思路-2，颠倒符号从前往后，允许一次失败" class="headerlink" title="思路 2，颠倒符号从前往后，允许一次失败"></a>思路 2，颠倒符号从前往后，允许一次失败</h2><p>把题目转化为递增数组的思路，避免了颠倒数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        modified = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> modified:</span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">1</span> <span class="keyword">and</span> nums[i] &lt; nums[i - <span class="number">2</span>]:</span><br><span class="line">                        nums[i] = nums[i - <span class="number">1</span>]</span><br><span class="line">                    modified = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="思路-3，数学归纳"><a href="#思路-3，数学归纳" class="headerlink" title="思路 3，数学归纳"></a>思路 3，数学归纳</h2><p>评论区大神给的思路，只允许修改一次值的情况下，只有 YABY 这种情况是直接丢出 <code>false</code>，其余情况可以通过修改一次值通过。这个算法可以在不进行任何值的修改的前提下，进行正确的判断。</p>
<p><img src="/images/leetcode/665.idea.png" alt="665.idea.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        modified = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># Return False if modified before, or if these conditions are satisfied.</span></span><br><span class="line">                <span class="keyword">if</span> modified <span class="keyword">or</span> (</span><br><span class="line">                    <span class="comment"># Ensure `i - 2` and  `i + 1` exist,</span></span><br><span class="line">                    i &gt; <span class="number">1</span></span><br><span class="line">                    <span class="keyword">and</span> i &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">                    <span class="comment"># if `i - 2` &gt; `i`, it&#x27;s a YAB of YABY,</span></span><br><span class="line">                    <span class="keyword">and</span> nums[i - <span class="number">2</span>] &gt; nums[i]</span><br><span class="line">                    <span class="comment"># if `i - 1` &gt; `i + 1`, it&#x27;s a ABY of YABY.</span></span><br><span class="line">                    <span class="keyword">and</span> nums[i - <span class="number">1</span>] &gt; nums[i + <span class="number">1</span>]</span><br><span class="line">                ):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># If it&#x27;s not the cases above, set modified to True,</span></span><br><span class="line">                <span class="comment"># no more chance for the next violation.</span></span><br><span class="line">                modified = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>667. Beautiful Arrangement II （Medium）</title>
    <url>/post/leetcode/667-Beautiful-Arrangement-II-Medium/</url>
    <content><![CDATA[<p>给定两个数 <code>n</code> 和 <code>k</code>，你需要构建一个数组包含从 <code>1</code> 到 <code>n</code> 的正整数，并且相邻两个数的差组成的数组必须要有 <code>k</code> 个不重复的元素。</p>
<span id="more"></span>

<h2 id="Understanding-the-Problem"><a href="#Understanding-the-Problem" class="headerlink" title="Understanding the Problem"></a>Understanding the Problem</h2><p>With solutions both in Python and Java.</p>
<p>先读题：</p>
<blockquote>
<p>Given two integers <code>n</code> and <code>k</code>, you need to construct a list which contains <code>n</code> different positive integers ranging from 1 to <code>n</code> and obeys the following requirement:</p>
<p>Suppose this list is <code>[a1, a2, a3, ... , an]</code>, then the list <code>[|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|]</code> has exactly <code>k</code> distinct integers.</p>
<p>If there are multiple answers, print any of them.</p>
</blockquote>
<p>简而言之，我们要根据两个整数参数 <code>n</code> 和 <code>k</code>，来输出一个从 1 开始到 <code>n</code> 的整数数组，并且这个数组中，所有相邻的两个整数之间的差，其绝对值要凑齐 <code>k</code> 个不同的整数。</p>
<p>来看看例子。</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3, k = 1</span><br><span class="line">Output: [1, 2, 3]</span><br><span class="line">Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.</span><br></pre></td></tr></table></figure>

<p>输出结果为整数 1 ～ 3，相邻整数的差为 [1, 1]，去重后长度为 1，满足 <code>k = 1</code> 的需求。</p>
<p>Example 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3, k = 2</span><br><span class="line">Output: [1, 3, 2]</span><br><span class="line">Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.</span><br></pre></td></tr></table></figure>

<p>输出结果为整数 1 ～ 3，相邻整数的差为 [2, 1]，满足 <code>k = 2</code> 的需求。</p>
<h2 id="Submission"><a href="#Submission" class="headerlink" title="Submission"></a>Submission</h2><p>先贴一下我自己独立完成的结果，防止剧透，具体代码会贴在最后。</p>
<p>我的代码中，空间复杂度还需要研究一下，目前还没找到提升的思路。</p>
<p><strong>Python</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>40 ms</td>
<td>96.55%</td>
</tr>
<tr>
<td>Memory</td>
<td>15.1 MB</td>
<td>50.34%</td>
</tr>
</tbody></table>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题偏重考验观察。我们要做的是观察并找到数组排列的规律，用算法实现出来。</p>
<p>已知条件：</p>
<ul>
<li>输出数组包含 1 ～ n 的整数</li>
<li>需要做的是调整数组中数字出现的顺序，致使相邻的两个数之间的差不同</li>
<li>相邻两个数的差只考虑绝对值</li>
<li>相邻两个数的差的绝对值构成的数组长度为 k</li>
<li>由于不关注具体的差的值，所以有不同解法，只需要找出一种</li>
</ul>
<p>先硬算几个例子来找找规律。</p>
<p>(因为懒，这里我直接贴讨论帖中的例子，UAADs 指的是唯一绝对相邻数差，贴主原文全称是 Unique Absolute Adjacent Difference，为了方便理解，后面我们就称之为“相邻数差”。)</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">For eg.</span><br><span class="line">1. let n = 10, k = 4</span><br><span class="line">permutation =&gt; [1, 5, 2, 4, 3, 6, 7, 8, 9, 10]</span><br><span class="line">UAADs       =&gt; [X, 4, 3, 2, 1, 3, 1, 1, 1, 1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. n = 10, k = 5</span><br><span class="line">permutation =&gt; [1, 6, 2, 5, 3, 4, 7, 8, 9, 10]</span><br><span class="line">UAADs       =&gt; [X, 5, 4, 3, 2, 1, 3, 1, 1, 1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. n = 9, k = 8</span><br><span class="line">permutation =&gt; [1, 9, 2, 8, 3, 7, 4, 6, 5]</span><br><span class="line">UAADs       =&gt; [X, 8, 7, 6, 5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>

<p>题目不关注相邻数差的具体数值，所以正确的排列方式不止一种，这里我们只讨论可以相对直观理解的一种。</p>
<p>观察上面例子可以了解到：</p>
<ul>
<li>输出的数组从 1 开始</li>
<li>第二个数是 k + 1</li>
<li>要求 k 个不同相邻数差会影响 k 个元素</li>
<li>不受 k 影响的数按自然顺序排序</li>
</ul>
<blockquote>
<p>可能 <code>要求 k 个不同相邻数差会影响 k 个元素</code> 不是很直观，我们通过分解上面的例子来理解。</p>
<p>下面结论中，1 一直处于固定位置，高亮出来的部分是排序受到 k 影响的数，而剩余的数（如果有的话）将按照递增排序。</p>
<p>n = 10, k = 4 =&gt; [1, <code>5, 2, 4, 3,</code> 6, 7, 8, 9, 10]</p>
<p>n = 10, k = 5 =&gt; [1, <code>6, 2, 5, 3, 4,</code> 7, 8, 9, 10]</p>
<p>n = 9, k = 8 =&gt; [1, <code>9, 2, 8, 3, 7, 4, 6, 5</code>]</p>
</blockquote>
<p>设定好了前提，接下来我们需要关注的问题变成了观察并理解“受到 k 影响的元素应该如何排序”。</p>
<p>多看几眼上面的例子，我们可以直观的意识到规律：为了满足 k 个不同的相邻数差，我们将排序靠后的数依次插入到 <code>1, 2, 3, ..., n</code> 之间，来制造不同的绝对差。</p>
<p>了解规律之后，可以开始实现算法了，这是一些对于时间复杂度和空间复杂度的考虑。</p>
<ul>
<li>避免使用尾递归</li>
<li>控制循环次数</li>
<li>不使用非必要的变量</li>
</ul>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArray</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># 初始化一个数组，由于前两个值是已知的，所以直接写入字面量</span></span><br><span class="line">        ans = [<span class="number">1</span>, k + <span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 以 k 为基准进行循环</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k):</span><br><span class="line">            <span class="comment"># 取倒数第二个值为计算基数，根据当前 index 决定做递增或递减</span></span><br><span class="line">            ans.append(ans[-<span class="number">2</span>] + (<span class="number">1</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span>))</span><br><span class="line">        <span class="comment"># 按自然顺序填充剩下的元素</span></span><br><span class="line">        ans += <span class="built_in">range</span>(k + <span class="number">2</span>, n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>结果如下。</p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>40 ms</td>
<td>96.55%</td>
</tr>
<tr>
<td>Memory</td>
<td>15.1 MB</td>
<td>50.34%</td>
</tr>
</tbody></table>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>由于先做出了 Python 版本，相同思路转换成 Java 代码结果很糟糕。</p>
<p>这里根据讨论帖的提示完成了一个较优的方案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArray(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// l 为递增初始值，r 为递减初始值，用 i 来保存 index</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = k + <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 执行一个步长为 2 的循环来填充数组直到满足 k 个相邻数差</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; k) &#123;</span><br><span class="line">            ans[i++] = l++;</span><br><span class="line">            ans[i++] = r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于数组以1起始，故当 k 为偶数时做 2 步长的循环将漏掉一个数</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) ans[i++] = r;</span><br><span class="line">        <span class="comment">// 依序填充自然递增的数直到填至 n 为止</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) ans[i++] = i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下。</p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>0 ms</td>
<td>100.00%</td>
</tr>
<tr>
<td>Memory</td>
<td>39.1 MB</td>
<td>73.71%</td>
</tr>
</tbody></table>
<blockquote>
<p>受 Java 版本思路启发，我修改了一下 Python 的算法，在空间复杂度上得到一些提升。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">constructArray</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">       ans = [<span class="number">1</span>, k + <span class="number">1</span>]</span><br><span class="line">       <span class="comment"># 执行一个步长为 2 的循环来制造不同的相邻数差</span></span><br><span class="line">       <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, k, <span class="number">2</span>):</span><br><span class="line">           ans.append(ans[x-<span class="number">2</span>] + <span class="number">1</span>)</span><br><span class="line">           ans.append(ans[x-<span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">       <span class="comment"># 补充 k 为偶数时漏掉的数</span></span><br><span class="line">       <span class="keyword">if</span> ans[-<span class="number">1</span>] -<span class="number">2</span> == ans[-<span class="number">2</span>]: ans.append(ans[-<span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">       ans += <span class="built_in">range</span>(<span class="built_in">len</span>(ans) + <span class="number">1</span>, n + <span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>结果如下。</p>
<table>
<thead>
<tr>
<th></th>
<th>Result</th>
<th>Beats</th>
</tr>
</thead>
<tbody><tr>
<td>Runtime</td>
<td>40 ms</td>
<td>96.55%</td>
</tr>
<tr>
<td>Memory</td>
<td>15.1 MB</td>
<td>82.76%</td>
</tr>
</tbody></table>
</blockquote>
<h2 id="官方-Solution"><a href="#官方-Solution" class="headerlink" title="官方 Solution"></a>官方 Solution</h2><p>来学习一下官方答案的思路。这个问题官方给出了 2 个方案。</p>
<h3 id="Approach-1-Brute-Force-Time-Limit-Exceeded"><a href="#Approach-1-Brute-Force-Time-Limit-Exceeded" class="headerlink" title="Approach #1: Brute Force [Time Limit Exceeded]"></a>Approach #1: Brute Force [Time Limit Exceeded]</h3><p>顾名思义，这个方法是暴力枚举所有排列，直到找到合适的排列。具体做法是准备一个检查唯一相邻数差数量的函数，然后对 1 ～ n 的数组排列进行枚举，直到找到该函数返回的唯一相邻数差的数量匹配 k 的值…</p>
<p>这个方法就不细说了，下面的代码看看就好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArray</span>(<span class="params">self, n, k</span>):</span></span><br><span class="line">        seen = [<span class="literal">False</span>] * n</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">num_uniq_diffs</span>(<span class="params">arr</span>):</span></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                seen[i] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>):</span><br><span class="line">                delta = <span class="built_in">abs</span>(arr[i] - arr[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> seen[delta]:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    seen[delta] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cand <span class="keyword">in</span> itertools.permutations(<span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> num_uniq_diffs(cand) == k:</span><br><span class="line">                <span class="keyword">return</span> cand</span><br></pre></td></tr></table></figure>

<h3 id="Approach-2-Construction-Accepted"><a href="#Approach-2-Construction-Accepted" class="headerlink" title="Approach #2: Construction [Accepted]"></a>Approach #2: Construction [Accepted]</h3><p>先看看官方原文，不过有些 LaTex 表达式不一定能正常显示，可以去 <a href="https://leetcode.com/problems/beautiful-arrangement-ii/solution/">原地址</a> 查看。看完原文我们来分析和理解一下官方的思路。</p>
<blockquote>
<p><strong>Intuition</strong></p>
<p>When \text{k = n-1}k = n-1, a valid construction is \text{[1, n, 2, n-1, 3, n-2, ….]}[1, n, 2, n-1, 3, &gt; n-2, ….]. One way to see this is, we need to have a difference of \text{n-1}n-1, which means we need &gt; \text{1}1 and \text{n}n adjacent; then, we need a difference of \text{n-2}n-2, etc.</p>
<p>Also, when \text{k = 1}k = 1, a valid construction is \text{[1, 2, 3, …, n]}[1, 2, 3, …, n]. So we &gt; have a construction when \text{n-k}n-k is tiny, and when it is large. This leads to the idea that we can &gt; stitch together these two constructions: we can put \text{[1, 2, …, n-k-1]}[1, 2, …, n-k-1] first so &gt; that \text{n}n is effectively \text{k+1}k+1, and then finish the construction with the first \text{“k = &gt; n-1”}”k = n-1” method.</p>
<p>For example, when \text{n = 6}n = 6 and \text{k = 3}k = 3, we will construct the array as \text{[1, 2, 3, &gt; 6, 4, 5]}[1, 2, 3, 6, 4, 5]. This consists of two parts: a construction of \text{[1, 2]}[1, 2] and a &gt; construction of \text{[1, 4, 2, 3]}[1, 4, 2, 3] where every element had \text{2}2 added to it (i.e. \text{&gt; [3, 6, 4, 5]}[3, 6, 4, 5]).</p>
<p><strong>Algorithm</strong></p>
<p>As before, write \text{[1, 2, …, n-k-1]}[1, 2, …, n-k-1] first. The remaining \text{k+1}k+1 elements &gt; to be written are \text{[n-k, n-k+1, …, n]}[n-k, n-k+1, …, n], and we’ll write them in alternating &gt; head and tail order.</p>
<p>When we are writing the i^{th}i<br>th<br>element from the remaining \text{k+1}k+1, every even ii is going to be chosen from the head, and will &gt; have value \text{n-k + i//2}n-k + i//2. Every odd ii is going to be chosen from the tail, and will have &gt; value \text{n - i//2}n - i//2.</p>
</blockquote>
<p>按照这个方案的思路，首先我们观察俩个极端：k 为最大值 n-1 时的结果；以及 k 为最小值 1 时的结果。</p>
<p>当 k = n - 1 时，这个时候数组根据数组序列（index）的奇偶性，出现奇数取头部（[1, 2, 3, …]），偶数取尾部（[n, n-1, n-2, …]）的规律。其最终结果如下。</p>
<p><code>[1, n, 2, n-1, 3, n-2, ...]</code></p>
<p>而当 k = 1 时，数组按照自然顺序递增排列。</p>
<p><code>[1, 2, 3, ..., n]</code></p>
<p>了解到这两个规律之后，我们可以将其结合：</p>
<ul>
<li>将 n-k-1 的部分的数按照 k = 1 时的规律处理；</li>
<li>而剩下的 k + 1 个元素单独视作一个数组，采取 k = n - 1 时的处理。</li>
</ul>
<p>这样就可以将处理划分为两类，用最简单的方法来构建这个数组。</p>
<ul>
<li>首先构建 <code>[1, 2, ..., n-k-1]</code> 数组</li>
<li>从 n-k 开始的数根据 index 的奇偶性来取值<ul>
<li>当 index 为偶数时从头部取值，这时值为 n-k + i//2</li>
<li>当 index 为奇数时从尾部取值，这时值为 n - i//2</li>
</ul>
</li>
</ul>
<p>参考代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArray</span>(<span class="params">self, n, k</span>):</span></span><br><span class="line">        ans = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, n - k))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                ans.append(n-k + i//<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(n - i//<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>从代码上来看，先取 k = 1 的排序，再取 k = n - 1 的排序确实让代码逻辑更加简洁和易懂；</li>
<li>从结果上来看，这段代码在空间复杂度上有改善（beats 82.76%），但是时间复杂度上有上升（beats 86.21%）。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>695. Max Area of Island (Medium)</title>
    <url>/post/leetcode/695-Max-Area-of-Island-Medium/</url>
    <content><![CDATA[<p>给定一个尺寸为 <code>m x n</code> 的二进制值的矩阵。定义元素的值为 <code>1</code> 表示土地，元素值为 <code>0</code> 表示海水。</p>
<p>陆地由四边邻接的土地组合而成，陆地的面积是接邻的土地的数量。</p>
<p>求矩阵中的陆地的最大面积，如果不存在陆地则返回 0。</p>
<span id="more"></span>

<h2 id="思路-1，递归"><a href="#思路-1，递归" class="headerlink" title="思路 1，递归"></a>思路 1，递归</h2><p>使用 DFS 搜索所有陆地（1），将搜索过的元素标注为 1 以外的数，避免重复计算，每次搜索到一个目标，保持一个最大结果作为答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m, n, ans = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">x, y</span>):</span></span><br><span class="line">            <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x == m <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y == n <span class="keyword">or</span> grid[x][y] != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            grid[x][y]  = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + search(x, y - <span class="number">1</span>) + search(x, y + <span class="number">1</span>) + search(x + <span class="number">1</span>, y) + search(x - <span class="number">1</span>, y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, search(i, j))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，栈"><a href="#思路-2，栈" class="headerlink" title="思路 2，栈"></a>思路 2，栈</h2><p>用一个 set <code>seen</code> 储存遇到过的格子，避免重复计算。每当遇到陆地，新建一个栈，遍历这个栈，取出栈顶的格子，将其上下左右四个方向存在陆地的格子放到栈顶，重复这个过程直到栈清空，维持一个计数最大值作为答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m, n, ans, seen = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>]), <span class="number">0</span>, <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] != <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                count, stack = <span class="number">0</span>, [(i, j)]</span><br><span class="line">                <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># print(stack)</span></span><br><span class="line">                    x, y = stack.pop()</span><br><span class="line">                    seen.add((x, y))</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">for</span> _x, _y <span class="keyword">in</span> ((x-<span class="number">1</span>, y), (x+<span class="number">1</span>, y), (x, y-<span class="number">1</span>), (x, y+<span class="number">1</span>)):</span><br><span class="line">                        <span class="keyword">if</span> _x &gt;= <span class="number">0</span> <span class="keyword">and</span> _x &lt; m <span class="keyword">and</span> _y &gt;= <span class="number">0</span> <span class="keyword">and</span> _y &lt; n <span class="keyword">and</span> (_x, _y) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                            <span class="keyword">if</span> grid[_x][_y] == <span class="number">1</span>:</span><br><span class="line">                                stack.append((_x, _y))</span><br><span class="line">                                seen.add((_x, _y))</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, count)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Matrix</tag>
        <tag>Union Fold</tag>
      </tags>
  </entry>
  <entry>
    <title>709. To Lower Case (Easy)</title>
    <url>/post/leetcode/709-To-Lower-Case-Easy/</url>
    <content><![CDATA[<p>字符串问题。将给定的字符串中的大写字母转换为小写字母并返回。</p>
<p>很简单的一道题目，考察点在于实现的思路。通过 ASCII 码可以简单的解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>只要记得大写字母 <code>A-Z</code> 的 ASCII 码区间是 <code>65-90</code>，大写字母和小写字母的差值是 32，这道题就很好解决。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toLowerCase</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            _c = <span class="built_in">ord</span>(c)</span><br><span class="line">            <span class="keyword">if</span> _c &gt;= <span class="number">65</span> <span class="keyword">and</span> _c &lt;= <span class="number">90</span>:</span><br><span class="line">                ans += <span class="built_in">chr</span>(_c + <span class="number">32</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += c</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ans = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[i] &gt;= <span class="number">65</span> &amp;&amp; ans[i] &lt;= <span class="number">90</span>) &#123;</span><br><span class="line">                ans[i] += <span class="number">32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>739. Daily Temperatures (Medium)</title>
    <url>/post/leetcode/739-Daily-Temperatures-Medium/</url>
    <content><![CDATA[<p>你有一个数组 <code>temperatures</code> 表示每一天的气温，你需要返回一个相同长度的数组，每一个元素表示相同下标对应的日期之后需要多少天气温才会回暖，如果后续气温一直没有回暖则保持该位置的值为 <code>0</code>。</p>
<p>这道题用暴力法（每个元素往后搜索，时间复杂度 O(n^2)）会遇到超时报错，我们需要想办法优化时间复杂度。</p>
<span id="more"></span>

<h2 id="思路：单调栈-Monotonic-Stack"><a href="#思路：单调栈-Monotonic-Stack" class="headerlink" title="思路：单调栈 Monotonic Stack"></a>思路：单调栈 Monotonic Stack</h2><p>单调栈是普通的栈结构，但是里面的元素是单调递增或递减的。单调栈在数组的范围查询问题中可以有效优化时间复杂度，每个元素只会进入单调栈一次，时间复杂度为 O(n)。</p>
<p>在这道题中我们在遍历每日气温数组寻找气温回暖天数时维护一个递减的单调栈，在遍历气温的过程中检查当前气温的数值可以更新递减单调栈上多少个日期的答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans, stack = [<span class="number">0</span>] * <span class="built_in">len</span>(temperatures), []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temperatures)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temperatures[stack[-<span class="number">1</span>]] &lt; temperatures[i]:</span><br><span class="line">                prev = stack.pop()</span><br><span class="line">                ans[prev] = i - prev</span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路：从右往左，优化暴力法"><a href="#思路：从右往左，优化暴力法" class="headerlink" title="思路：从右往左，优化暴力法"></a>思路：从右往左，优化暴力法</h2><p>另一个思路是从右向左来计算气温回暖天数。我们保持一个当前遇到的最大值 <code>right_max</code> 来判断是否存在未来回暖的日子，然后仅在存在这样的日期时才进行搜索，以避免无意义的计算。其次，由于我们按照从右向左的顺序计算，未来的日期以及计算完毕，所以我们可以参考这些计算结果来跳跃式的搜索最近的回暖日期，这一步可以进一步避免重复的计算。</p>
<p>从时间复杂度上来看这个思路的计算量相比有减少（重复计算部分），空间复杂度是 O(1)，相比上一个思路 O(n) 理论上应该表现更好，但是实际上在 LeetCode 的测试数据集上表现不如上个思路。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        n, right_max = <span class="built_in">len</span>(temperatures), temperatures[-<span class="number">1</span>]</span><br><span class="line">        ans = [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># if the current value is equal to or greater than the max</span></span><br><span class="line">            <span class="comment"># it means no possible future day could get warmer</span></span><br><span class="line">            <span class="keyword">if</span> right_max &lt;= temperatures[i]:</span><br><span class="line">                right_max = temperatures[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                days = <span class="number">1</span></span><br><span class="line">                <span class="comment"># keep searching the nearest bigger value</span></span><br><span class="line">                <span class="keyword">while</span> temperatures[i + days] &lt;= temperatures[i]:</span><br><span class="line">                    days += ans[i + days]</span><br><span class="line">                ans[i] = days</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Stack</tag>
        <tag>Monotonic Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>745. Prefix and Suffix Search (Hard)</title>
    <url>/post/leetcode/745-Prefix-and-Suffix-Search-Hard/</url>
    <content><![CDATA[<p>字典树题目。实现一个字典根据指定的前缀和后缀来定位单词，如果存在多个单词则返回最大的下标位置，如果不存在单词则返回 -1。</p>
<p>测试 case 中单词最大数量为 15000，查询次数最大为 15000，查询性能不够的话会遇到超时问题。</p>
<p>字符串索引问题是字典树（Trie）的应用场景，我们用字典树来解决这道题。</p>
<span id="more"></span>

<h2 id="思路，然而并没有用-Trie"><a href="#思路，然而并没有用-Trie" class="headerlink" title="思路，然而并没有用 Trie"></a>思路，然而并没有用 Trie</h2><p>用 Hash Table + Memoization 方法。</p>
<p>根据后缀长度，将每个单词截取后缀长度的 substring，加上 <code>#</code> 拼上原字符作为一个索引列表。</p>
<p>比如后缀长度为 3 时，将 <code>abcdefg</code> 处理为 <code>efg#abcdefg</code> 储存到长度为 3 的索引。</p>
<p>这样我们可以将给定的后缀拼上 <code>#</code> 再拼上前缀，使用字符串的 <code>startsWith</code> 方法进行匹配。</p>
<p>出于效率考虑我们将每次计算的结果储存到 <code>memo</code> 中，方便遇到相同的查询直接返回结果。</p>
<blockquote>
<p>这一步是避免算法超时的关键，实际上换一个不存在重复数据的测试集就会超时。</p>
<p>这道题考察的是 Trie 的应用。应用字典树的情况下测试集不会对结果有太大影响。</p>
<p>字典树构建流程并不复杂，但是细节处理需要小心注意，TODO</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String[]&gt; index = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> String[] reversed;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordFilter</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.len = words.length;</span><br><span class="line">        Collections.reverse(Arrays.asList(words));</span><br><span class="line">        <span class="keyword">this</span>.reversed = words;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(String prefix, String suffix)</span> </span>&#123;</span><br><span class="line">        String query = suffix + <span class="string">&quot;#&quot;</span> + prefix;</span><br><span class="line">        Integer ans = memo.get(query);</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memo.put(query, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> l = suffix.length();</span><br><span class="line"></span><br><span class="line">        String[] arr = index.get(l);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            arr = <span class="keyword">new</span> String[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                String w = reversed[i];</span><br><span class="line">                arr[i] = w.substring(w.length() - l) + <span class="string">&quot;#&quot;</span> + w;</span><br><span class="line">                <span class="comment">// System.out.println(arr[i]);</span></span><br><span class="line">            &#125;</span><br><span class="line">            index.put(l, arr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i].startsWith(query)) &#123;</span><br><span class="line">                ans = len - <span class="number">1</span> - i;</span><br><span class="line">                memo.put(query, ans);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordFilter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordFilter obj = new WordFilter(words);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.f(prefix,suffix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>746. Min Cost Climbing Stairs (Easy)</title>
    <url>/post/leetcode/746-Min-Cost-Climbing-Stairs-Easy/</url>
    <content><![CDATA[<p>爬楼梯游戏。你在爬一段楼梯，你会得到一个 <code>cost</code> 数组记录爬到每一级台阶的消耗。</p>
<p>一旦你付出当前台阶的消耗，你可以选择往上爬一级或两级台阶。另外，你可以选择从第一级台阶或第二级台阶开始游戏。</p>
<p>求爬到顶部的最小消耗。这是一道 DP 应用的简单题目。</p>
<span id="more"></span>

<h2 id="思路-1，DP"><a href="#思路-1，DP" class="headerlink" title="思路 1，DP"></a>思路 1，DP</h2><p>仔细观察能发现每一步的 <code>cost</code> 都取前两步 <code>cost</code> 的最小值，那么我们可以准备一个数组来存计算过的最小 <code>cost</code>。</p>
<p>话虽如此，这道题叙述有些模糊，经过尝试可以明确以下信息：</p>
<ul>
<li>下标 0 和 1 的 <code>cost</code> 都为 0，因为第一步最大可以走到下标 1 的位置，而第一步是没有 <code>cost</code> 的；</li>
<li>最后一步要超过最后一个元素，下标要达到数组长度。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(cost)</span><br><span class="line">        mincost = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 0，1 的 cost 都为 0，我们直接从 2 开始遍历，到 n （包含）结束。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 每一步 i 的 cost 都为前一步的值加上到达前一步的最小值。</span></span><br><span class="line">            <span class="comment"># 其中前一步可以选择 i - 1 和 i - 2。</span></span><br><span class="line">            mincost[i] = <span class="built_in">min</span>(</span><br><span class="line">                mincost[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>],</span><br><span class="line">                mincost[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> mincost[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，优化-DP"><a href="#思路-2，优化-DP" class="headerlink" title="思路 2，优化 DP"></a>思路 2，优化 DP</h2><p>仔细一看发现我们每次只看 2 个值，那么可以优化 O(n) 空间复杂度到 O(1)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        st1 = st2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(cost) + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 按照从左到右的顺序依次是 st2、st1、st0，每一个迭代我们丢弃 st2 的值，</span></span><br><span class="line">            <span class="comment"># 将 st1、st0 作为下一次迭代的 st2、st1。</span></span><br><span class="line">            st0 = <span class="built_in">min</span>(st1 + cost[i - <span class="number">1</span>], st2 + cost[i - <span class="number">2</span>])</span><br><span class="line">            st1, st2 = st0, st1</span><br><span class="line">        <span class="keyword">return</span> st1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>752. Open the Lock (Medium)</title>
    <url>/post/leetcode/752-Open-the-Lock-Medium/</url>
    <content><![CDATA[<p>开锁游戏。你有一个圆盘锁，锁有 4 个转轮，每个转轮上有 0 ～ 9 共十个数字。</p>
<p>你可以自由转动每个转轮，每次转动一个转轮后它的值会 +1 或 -1，当你从 0 开始转动 -1 后为 9，反之亦然。</p>
<p>你会得到一个死锁列表 <code>deadends</code>，表示当你转动圆盘锁到这个值的时候游戏结束。你还会得到目标值 <code>target</code>，你需要在避免遇到死锁的情况下解开圆盘锁，返回操作圆盘锁的最少步骤数，或者返回 -1 表示在已知条件下无法解锁。</p>
<span id="more"></span>

<h2 id="思路-BFS"><a href="#思路-BFS" class="headerlink" title="思路 BFS"></a>思路 BFS</h2><p>换个角度我们需要求出一个 10000 个节点的图中从 <code>0000</code> 出发到目标节点的最短路径，并且要避开给定的死路。总结一下已知的情报。</p>
<ul>
<li>每个转轮每次操作可以 +1 or -1；</li>
<li>当前状态的下一步操作有 4 * 2 = 8 中选择；</li>
<li>要求最少步数，需要穷尽每一步的所有选择 -&gt; 确定 BFS 应用场景；</li>
<li>为避免重复搜索，准备一个 <code>seen</code> 数组进行剪枝；<ul>
<li>已知圆盘锁的值都为数字且不重复，<code>seen</code> 数组可以初始化为长度为 10000 的布尔值 or 0/1 数组；</li>
<li><code>deadends</code> 可以视作已经处理过的组合，可以将其对应的 <code>seen</code> 数组的元素设为 true；</li>
</ul>
</li>
<li>为了方面计算，先将不好处理的特殊场景排除在外，这题有 2 个特殊场景：<ul>
<li>当目标等于初始值时，直接返回 0；</li>
<li>当初始值被标记为死路时，直接返回 -1；</li>
</ul>
</li>
<li>开始实现算法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">openLock</span>(<span class="params">self, deadends: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="string">&#x27;0000&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        depth, queue, seen, target = <span class="number">0</span>, [<span class="number">0</span>], [<span class="number">0</span>] * <span class="number">10000</span>, <span class="built_in">int</span>(target)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> deadends:</span><br><span class="line">            seen[<span class="built_in">int</span>(d)] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> seen[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            n, depth = <span class="built_in">len</span>(queue), depth + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                first = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                    base = first // <span class="number">10</span> ** k % <span class="number">10</span></span><br><span class="line">                    <span class="keyword">for</span> d <span class="keyword">in</span> (-<span class="number">1</span>, <span class="number">1</span>):</span><br><span class="line">                        <span class="comment"># first - base * 10 ** k -&gt; get the base number with target digit reset to 0.</span></span><br><span class="line">                        <span class="comment"># ~ + (base + d) % 10 * 10 ** k -&gt; add back the caculated target digit.</span></span><br><span class="line">                        nxt = first - base * <span class="number">10</span> ** k + (base + d) % <span class="number">10</span> * <span class="number">10</span> ** k</span><br><span class="line">                        <span class="keyword">if</span> nxt == target:</span><br><span class="line">                            <span class="keyword">return</span> depth</span><br><span class="line">                        <span class="keyword">if</span> seen[<span class="built_in">int</span>(nxt)]:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        seen[<span class="built_in">int</span>(nxt)] = <span class="number">1</span></span><br><span class="line">                        queue.append(nxt)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>将字符串转成数值然后再做各个位置的加减处理总是有点费脑筋，下面是字符串处理版本的算法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">openLock</span>(<span class="params">self, deadends: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        visited = <span class="built_in">set</span>(deadends)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;0000&quot;</span> <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        q, step = deque([<span class="string">&quot;0000&quot;</span>]), -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                curr = q.popleft()</span><br><span class="line">                <span class="keyword">if</span> curr == target:</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line">                <span class="keyword">if</span> curr <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                visited.add(curr)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                    <span class="keyword">for</span> nxt <span class="keyword">in</span> [curr[:i] + <span class="built_in">str</span>((<span class="built_in">int</span>(curr[i]) + x) % <span class="number">10</span>) + curr[i + <span class="number">1</span>:] <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">1</span>, -<span class="number">1</span>)]:</span><br><span class="line">                        <span class="keyword">if</span> nxt <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                            q.append(nxt)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>BFS</tag>
        <tag>String</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>77. Combinations (Medium)</title>
    <url>/post/leetcode/77-Combinations-Medium/</url>
    <content><![CDATA[<p>组合问题。给定两个整数 <code>n</code> 和 <code>k</code>，返回从 <code>1 ~ n</code> 中选取 <code>k</code> 个数能构成的所有组合。</p>
<p>典型的回溯算法应用题，需要注意去重的思路。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>需要编辑的数组长度 <code>k</code> 是一个变量，看来这道题是一道典型的回溯算法题。</p>
<p>我们从 <code>1</code> 开始尝试往目标数组中放入包含 <code>1</code> 到包含 <code>n</code> 之间的值。</p>
<p>下一轮中我们尝试放入包含 <code>2</code> 到包含 <code>n</code> 之间的值。重复这个过程。</p>
<p>组合不在乎元素的排序，所以也许你会觉得算法会重复取值，这里的处理重点在于下一个值永远是大于上一个值的，所以我们没有必要考虑组合重复。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">pos, res</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) == k:</span><br><span class="line">                ans.append(res)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos, n + <span class="number">1</span>):</span><br><span class="line">                search(i + <span class="number">1</span>, res + [i])</span><br><span class="line">        search(<span class="number">1</span>, [])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>778. Swim in Rising Water (Hard)</title>
    <url>/post/leetcode/778-Swim-in-Rising-Water-Hard/</url>
    <content><![CDATA[<p>这是一道求最合适路径的题目，根据提示可以应用图论中的 Dijkstra 算法。</p>
<blockquote>
<p>Dijkstra‘s Algorithm 适用于求<strong>权重不为负数的加权图</strong>起点到终点的最优路径。</p>
</blockquote>
<p>这道题的 input 是一个 <code>n * n</code> 的矩阵，可以将其视作所有元素都与其上下左右相互连接的一张无向图，每个顶点的数值表示到达这个顶点的边的权重，我们需要求的是从起点 <code>(0, 0)</code> 到终点 <code>(n, n)</code> 的最优路径。这道题要求我们计算的是这条路径上权重最大值，所以我们用一个变量来保持每一次选择后的权重最大值。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>下面是算法：</p>
<ul>
<li>从 <code>(0, 0)</code> 开始，将四个方向能访问的顶点加权后放入小根堆：<ul>
<li>根据题目的限制，<code>n &lt;= 50</code>，所以我们留出 2 进制 6 位（<code>2^6=64</code>）便足够放下下标的长度来；</li>
<li>加权后的值 = <code>(grid[x][y] &lt;&lt; 12) + (x &lt;&lt; 6) + y</code>;</li>
</ul>
</li>
<li>选择小根堆中的最小值继续往下走：<ul>
<li>现在我们选了一个新的值，用其和全局最大值再取一次最大值，更新全局变量；</li>
<li>从加权后的值中恢复这个值的 <code>x, y</code> 下标；</li>
</ul>
</li>
<li>重复这个过程直到终点 <code>(n, n)</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">moves = ((-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">mask = (<span class="number">1</span> &lt;&lt; <span class="number">6</span>) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swimInWater</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n, ans, i, j, q = <span class="built_in">len</span>(grid) - <span class="number">1</span>, grid[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>, []</span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">or</span> j &lt; n:</span><br><span class="line">            <span class="keyword">for</span> a, b <span class="keyword">in</span> moves:</span><br><span class="line">                _i, _j = i + a, j + b</span><br><span class="line">                <span class="keyword">if</span> _i &lt; <span class="number">0</span> <span class="keyword">or</span> _i &gt; n <span class="keyword">or</span> _j &lt; <span class="number">0</span> <span class="keyword">or</span> _j &gt; n <span class="keyword">or</span> grid[_i][_j] == math.inf:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                heapq.heappush(q, (grid[_i][_j] &lt;&lt; <span class="number">12</span>) + (_i &lt;&lt; <span class="number">6</span>) + _j)</span><br><span class="line">                grid[_i][_j] = math.inf</span><br><span class="line">            nxt = heapq.heappop(q)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, nxt &gt;&gt; <span class="number">12</span>)</span><br><span class="line">            i, j = (nxt &gt;&gt; <span class="number">6</span>) &amp; mask, nxt &amp; mask</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>Java 版用 PriorityQueue 实现小根堆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] moves = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; <span class="number">6</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n = grid.length - <span class="number">1</span>;</span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i != n || j != n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] m : moves) &#123;</span><br><span class="line">                <span class="keyword">int</span> mi = i + m[<span class="number">0</span>], mj = j + m[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (mi &lt; <span class="number">0</span> || mi &gt; n || mj &lt; <span class="number">0</span> || mj &gt; n</span><br><span class="line">                    || grid[mi][mj] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pq.add((grid[mi][mj] &lt;&lt; <span class="number">12</span>) + (mi &lt;&lt; <span class="number">6</span>) + mj);</span><br><span class="line">                grid[mi][mj] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> next = pq.poll();</span><br><span class="line">            ans = Math.max(ans, next &gt;&gt; <span class="number">12</span>);</span><br><span class="line">            i = (next &gt;&gt; <span class="number">6</span>) &amp; mask;</span><br><span class="line">            j = next &amp; mask;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Binary Search</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Matrix</tag>
        <tag>Heap (Priority Queue)</tag>
        <tag>Union Fold</tag>
      </tags>
  </entry>
  <entry>
    <title>792. Number of Matching Subsequences (Medium)</title>
    <url>/post/leetcode/792-Number-of-Matching-Subsequences-Medium/</url>
    <content><![CDATA[<p>字符串问题。找出匹配子序列（Subsequences）的数量。</p>
<p>子序列（Subsequences）的定义：一个字符串中删除某些字符（也可以不删除字符）之后，字符出现的相对顺序没有被改变，则这个新的字符串称之为原字符串的子序列。</p>
<blockquote>
<p>For example, “ace” is a subsequence of “abcde”.</p>
</blockquote>
<p>我们用暴力法和桶来解决这道题。</p>
<span id="more"></span>

<h2 id="无脑思路…"><a href="#无脑思路…" class="headerlink" title="无脑思路…"></a>无脑思路…</h2><p>这道题定义的子序列不需要是连续的字符串，只需要字符按照原本的先后顺序排列即可，所以遗憾 <code>for in</code> 不能派上用场（废话）。</p>
<p>但这也难不倒无脑的我，定义在于先后顺序，那么我们每一次仅搜索从上一次找到的下标往后是不是存在下一个字符，如果找到下一个字符，这个下标保存继续循环，最后判断找到的字符数量是不是和愿字符串长度一致。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMatchingSubseq</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            curr, cnt = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> w:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    curr = curr + s[curr:].index(c) + <span class="number">1</span></span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="built_in">len</span>(w):</span><br><span class="line">                ans +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="正常思路，桶"><a href="#正常思路，桶" class="headerlink" title="正常思路，桶"></a>正常思路，桶</h2><p>评论区的一个思路，作者命名为 “Next Letter Pointer” 方法。</p>
<p>我们将每个检查对象按照首字母放到对应的桶中，通过下面的方法实现仅遍历一次目标字符串就检查完所有目标的算法。</p>
<p>作者还做了一张图来可视化这个过程。算法思路如下。</p>
<ul>
<li>准备好桶后，开始遍历目标字符串：<ul>
<li>用当前位置的字符取出对应的桶保留，就桶原本的位置重置为空桶；</li>
<li>遍历取出的桶：<ul>
<li>如果字符长度为 1：说明找到了一个答案，计数器+1；</li>
<li>否则：将字符串去头（第一个字符）后，按照首字母继续放入对应的桶中，等待后面有机会取出来；</li>
</ul>
</li>
<li>重复这个过程直到目标字符串遍历结束。</li>
</ul>
</li>
</ul>
<p><img src="/images/leetcode/792.bucket.png" alt="bucket"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMatchingSubseq</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, bucket = <span class="number">0</span>, defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            bucket[w[<span class="number">0</span>]].append(w)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            target, bucket[c] = bucket[c], []</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> target:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(w) == <span class="number">1</span>:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                bucket[w[<span class="number">1</span>]].append(w[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>Java 版本，好长长长…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String w;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> p;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String w, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">            <span class="keyword">this</span>.p = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numMatchingSubseq</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Node&gt;[] bucket = <span class="keyword">new</span> ArrayList[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            bucket[i] = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            bucket[word.charAt(<span class="number">0</span>) - <span class="number">97</span>].add(<span class="keyword">new</span> Node(word, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            List&lt;Node&gt; target = bucket[c - <span class="number">97</span>];</span><br><span class="line">            bucket[c - <span class="number">97</span>] = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Node n : target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n.p + <span class="number">1</span> == n.w.length()) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    n.p ++;</span><br><span class="line">                    bucket[n.w.charAt(n.p) - <span class="number">97</span>].add(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Hash Table</tag>
        <tag>Sorting</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>816. Ambiguous Coordinates (Medium)</title>
    <url>/post/leetcode/816-Ambiguous-Coordinates-Medium/</url>
    <content><![CDATA[<p>模棱两可的平面坐标。你需要从一个删除了逗号、空格和小数点的平面坐标中还原它的所有可能的坐标值。</p>
<blockquote>
<p>For example, “(1, 3)” becomes s = “(13)” and “(2, 0.5)” becomes s = “(205)”.</p>
</blockquote>
<p>结果坐标值不会有多余的前置 0，并且小数点后的数字不会以 0 结尾。还原后的坐标的两个值应该用逗号和一个空格隔开。</p>
<p>我们讨论用正则和回溯算法来解决这道题。</p>
<span id="more"></span>

<h2 id="思路-1，正则"><a href="#思路-1，正则" class="headerlink" title="思路 1，正则"></a>思路 1，正则</h2><p>偷懒用正则检查字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ambiguousCoordinates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isvalid</span>(<span class="params">s</span>):</span></span><br><span class="line">            ptn = <span class="string">r&quot;^(([1-9]+\d*|0)\.\d*[1-9]|([1-9]+\d*|0))$&quot;</span></span><br><span class="line">            <span class="keyword">return</span> re.match(ptn, s) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">makenumberstr</span>(<span class="params">s</span>):</span></span><br><span class="line">            ret = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                _s = s</span><br><span class="line">                <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                    _s = s[:i + <span class="number">1</span>] + <span class="string">&#x27;.&#x27;</span> + s[i + <span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> isvalid(_s):</span><br><span class="line">                    ret.append(_s)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        s = s[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line"></span><br><span class="line">            n = makenumberstr(s[:i])</span><br><span class="line">            m = makenumberstr(s[i:])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _n <span class="keyword">in</span> n:</span><br><span class="line">                <span class="keyword">for</span> _m <span class="keyword">in</span> m:</span><br><span class="line">                    ans.append(<span class="string">f&quot;(<span class="subst">&#123;_n&#125;</span>, <span class="subst">&#123;_m&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，回溯算法"><a href="#思路-2，回溯算法" class="headerlink" title="思路 2，回溯算法"></a>思路 2，回溯算法</h2><p>老老实实拼正确的字符串，跳过检查。其实正确字符串规则只有 2 个，无论对整数还是浮点数来说，整数部分只能是 0 或 0 以上，所以判断这部分只要判断是否有前缀 0，以及是否为 0。</p>
<ul>
<li>浮点数：<ul>
<li>左边只能是 0 或大于 0 的数；</li>
<li>右边末位不能是 0。</li>
</ul>
</li>
<li>整数：<ul>
<li>只能是 0 或大于 0 的数。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ambiguousCoordinates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">makenumberstr</span>(<span class="params">s</span>):</span></span><br><span class="line">            ret = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s) + <span class="number">1</span>):</span><br><span class="line">                left, right = s[:i], s[i:]</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">not</span> left.startswith(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> left == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">and</span> <span class="keyword">not</span> right.endswith(<span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">                    ret.append(left + (<span class="string">&#x27;.&#x27;</span> <span class="keyword">if</span> right != <span class="string">&#x27;&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>) + right)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        s, ans = s[<span class="number">1</span>:-<span class="number">1</span>], []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line"></span><br><span class="line">            n = makenumberstr(s[:i])</span><br><span class="line">            m = makenumberstr(s[i:])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _n <span class="keyword">in</span> n:</span><br><span class="line">                <span class="keyword">for</span> _m <span class="keyword">in</span> m:</span><br><span class="line">                    ans.append(<span class="string">f&quot;(<span class="subst">&#123;_n&#125;</span>, <span class="subst">&#123;_m&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>86. Partition List (Medium)</title>
    <url>/post/leetcode/86-Partition-List-Medium/</url>
    <content><![CDATA[<p>链表问题。链表分区，给你一个链表和整数 <code>x</code>，你需要在保证相对顺序的情况下，将小于 <code>x</code> 的值排在链表前面，大于等于 <code>x</code> 的值排在后面。</p>
<blockquote>
<p>Given the <code>head</code> of a linked list and a value <code>x</code>, partition it such that all nodes less than <code>x</code> come before nodes greater than or equal to <code>x</code>.</p>
<p>You should <strong>preserve</strong> the original relative order of the nodes in each of the two partitions.</p>
</blockquote>
<span id="more"></span>

<p>With solutions both in Python and Java.</p>
<p>已知参数为一个 linked list 和 x，需要将数组根据 x 的值分区，小于它的放在前面，大于等于它的放在后面，并且分区后要保证原有顺序不变。</p>
<p>从下面例子可以看出来，我们可以把数组拆成一个前一个后，保持元素相对顺序，然后拼接起来。</p>
<p>Example 1:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Input: head = [1,4,3,2,5,2], x = 3</span><br><span class="line">Output: [1,2,2,4,3,5]</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Input: head = [2,1], x = 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>

<h2 id="Submissions"><a href="#Submissions" class="headerlink" title="Submissions"></a>Submissions</h2><p>我的代码时间复杂度还能看，空间复杂度已经脱离排名，没法看了。</p>
<p>虽然解题思路和官方一样，但是处理上有些愚蠢，这题就不贴我的结果了。</p>
<h2 id="思路-amp-Solutions"><a href="#思路-amp-Solutions" class="headerlink" title="思路 &amp; Solutions"></a>思路 &amp; Solutions</h2><p>思路很简单，这道题主要考察的是对空间复杂度对处理。逻辑的流程如下。</p>
<ul>
<li>准备一个 before 列表存储值小于 x 的元素</li>
<li>准备一个 after 列表存储值不小于 x 的元素</li>
<li>将两个列表连接起来作为结果</li>
</ul>
<p>逻辑很简单，但是 linked list 的接口如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">         self.val = val</span><br><span class="line">         self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>程序拿到的参数是这个 linked list 的第一个元素，这是一个逻辑上的列表，我们只能向下遍历，无法从下节点反推出上一个节点的值。</p>
<p>要准备 before 和 after 列表我们首先要知道从哪里开始，以及如何开始。</p>
<ul>
<li>我们可以不初始化 before 和 after，等到遇到合适的值的时候再去给其赋值；</li>
<li>也可以初始化为当前的节点，再根据与 x 比较的结果来调整赋值；这两个思路我都尝试了。</li>
<li>官解的处理是，将 before 和 after 初始化为两个伪节点，规避了初始化问题（是我没想到的思路）。</li>
</ul>
<p>看一下 Python 代码理解一下这个处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, head: ListNode, x: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        bef = bf_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        aft = af_head = ListNode(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">                bef.<span class="built_in">next</span> = head</span><br><span class="line">                bef = head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                aft.<span class="built_in">next</span> = head</span><br><span class="line">                aft = head</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        aft.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        bef.<span class="built_in">next</span> = af_head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bf_head.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Java 代码逻辑一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode before = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode after = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode bfHead = before;</span><br><span class="line">        ListNode afHead = after;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &lt; x) &#123;</span><br><span class="line">                before.next = head;</span><br><span class="line">                before = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                after.next = head;</span><br><span class="line">                after = head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        after.next = <span class="keyword">null</span>;</span><br><span class="line">        before.next = afHead.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bfHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>进行伪初始化的处理很好的规避了初始化判断，对遍历的处理也只是改变了列表的排序，两者使得程序在时间和空间复杂度上有很好的表现。</p>
<ul>
<li>时间复杂度：O(n)，做了一次遍历；</li>
<li>空间复杂度：O(1)，只做了列表重组，没使用额外空间。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Two Pointers</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>890. Find and Replace Pattern (Medium)</title>
    <url>/post/leetcode/890-Find-and-Replace-Pattern-Medium/</url>
    <content><![CDATA[<p>给定一组字符串和一个模式（pattern），返回字符串中所有匹配这个模式的对象。</p>
<p>这里的模式（pattern）描述字母如何重复，即如果模式匹配，那么将模式中的字母替换成映射的字母，就可以还原成目标字符串。</p>
<p>使用字符串映射，或者码表来解决这道题。</p>
<span id="more"></span>

<h2 id="思路-1，先计算-pattern-的排列码表"><a href="#思路-1，先计算-pattern-的排列码表" class="headerlink" title="思路 1，先计算 pattern 的排列码表"></a>思路 1，先计算 <code>pattern</code> 的排列码表</h2><p>使用这个码表来过滤输入数据。简单来说，我们这样做。</p>
<ul>
<li>计算 <code>pattern</code> 的排列码表<ul>
<li>用一个计数器将 <code>pattern</code> 中的字符按出现顺序编码；</li>
<li>相同字符的编码保持不变，比如 <code>abba</code> 转化为排列码表为 <code>[0, 1, 1, 0]</code>。</li>
</ul>
</li>
<li>对输入数据中每一个字符串进行检查<ul>
<li>用一个计数器将目标中的字符按出现顺序编码；</li>
<li>相同字符的编码保持不变；</li>
<li>计算完每一个字符的编码后，与排列码表相同下标的元素进行比对，结果不一致时直接返回 <code>false</code>；</li>
<li>顺利匹配完成时，返回 <code>true</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAndReplacePattern</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], pattern: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        ptn, tbl, c = [], &#123;&#125;, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> pattern:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> tbl:</span><br><span class="line">                tbl[i] = c</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">            ptn.append(tbl[i])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">match</span>(<span class="params">w</span>):</span></span><br><span class="line">            tbl.clear()</span><br><span class="line">            c = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w)):</span><br><span class="line">                <span class="keyword">if</span> w[i] <span class="keyword">not</span> <span class="keyword">in</span> tbl:</span><br><span class="line">                    tbl[w[i]] = c</span><br><span class="line">                    c += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> tbl[w[i]] != ptn[i]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(ptn)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">filter</span>(match, words)</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，双射（bijection）"><a href="#思路-2，双射（bijection）" class="headerlink" title="思路 2，双射（bijection）"></a>思路 2，双射（bijection）</h2><p>用两个哈希表分别映射 <code>pattern</code> 字符和目标字符，检查映射结果是否一致。</p>
<ul>
<li>用 <code>m1</code> 储存目标字符到 <code>pattern</code> 字符的映射，比如字符 <code>x</code> -&gt; <code>a</code>;</li>
<li>用 <code>m2</code> 储存 <code>pattern</code> 字符到目标字符的映射，比如字符 <code>a</code> -&gt; <code>x</code>；</li>
<li>作为判断条件，当下面条件任意一个满足，则表示目标字符与 <code>pattern</code> 不匹配：<ul>
<li><code>m1</code> 中字符 <code>x</code> 对应的字符与当前 <code>pattern</code> 相对下标的字符不匹配；或，</li>
<li><code>m2</code> 中字符 <code>a</code> 对应的字符与当前目标字符串相对下标的字符不匹配。</li>
</ul>
</li>
<li>如果到最后一个字符依然匹配，则目标字符匹配 <code>pattern</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, Character&gt; m1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, Character&gt; m2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findAndReplacePattern</span><span class="params">(String[] words, String pattern)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String w : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (match(w, pattern)) ans.add(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String w, String ptn)</span> </span>&#123;</span><br><span class="line">        m1.clear(); m2.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = w.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> p = ptn.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!m1.containsKey(c)) m1.put(c, p);</span><br><span class="line">            <span class="keyword">if</span> (!m2.containsKey(p)) m2.put(p, c);</span><br><span class="line">            <span class="keyword">if</span> (m1.get(c) != p || m2.get(p) != c) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，单哈希表"><a href="#思路-3，单哈希表" class="headerlink" title="思路 3，单哈希表"></a>思路 3，单哈希表</h2><p>在双射的思路里我们用到了 2 个哈希表，这里还有优化的空间，我们考虑一下只使用一个哈希表时需要处理的问题。</p>
<ul>
<li>首先按照思路 2 准备好哈希表，这次我们仅作目标字符到 <code>pattern</code> 字符的映射；</li>
<li>第一个错误条件是目标字符在哈希表中对应的 <code>pattern</code> 字符和当前不匹配：<ul>
<li>如果目标字符重复之前出现过的字符，而 <code>pattern</code> 字符是未出现过的，则哈希表中对应字符和当前 <code>pattern</code> 字符必定不匹配。</li>
</ul>
</li>
<li>第二个错误条件是目标字符都不重复时，会将多个不同字符映射到 <code>pattern</code> 的同一个字符：<ul>
<li>这时哈希表会顺利完成，我们需要对哈希表的值集合进行进一步的检查，如果出现重复字符则返回 <code>false</code>。</li>
</ul>
</li>
<li>最终顺利完成检查的返回 <code>true</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, Character&gt; m1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findAndReplacePattern</span><span class="params">(String[] words, String pattern)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String w : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (match(w, pattern)) ans.add(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String w, String ptn)</span> </span>&#123;</span><br><span class="line">        m1.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = w.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> p = ptn.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!m1.containsKey(c)) m1.put(c, p);</span><br><span class="line">            <span class="keyword">if</span> (m1.get(c) != p) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] test = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> v : m1.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (test[v - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                test[v - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">words</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">pattern</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findAndReplacePattern = <span class="function"><span class="keyword">function</span> (<span class="params">words, pattern</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> words.filter(<span class="function">(<span class="params">w</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; w.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> c = w.charAt(i),</span><br><span class="line">        p = pattern.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (!map[c]) map[c] = p;</span><br><span class="line">      <span class="keyword">if</span> (p !== map[c]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> test = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="built_in">Object</span>.values(map)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (test.indexOf(v) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        test.push(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>906. Super Palindromes (Hard)</title>
    <url>/post/leetcode/906-Super-Palindromes-Hard/</url>
    <content><![CDATA[<p>嗯…暂且打表吧…</p>
<span id="more"></span>

<h2 id="思路，打表"><a href="#思路，打表" class="headerlink" title="思路，打表"></a>思路，打表</h2><p>Don’t know the reason but not interested in this problem, so let’s calculate a table to break it.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superpalindromesInRange</span>(<span class="params">self, left: <span class="built_in">str</span>, right: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        L, R = <span class="built_in">int</span>(left), <span class="built_in">int</span>(right)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.table:</span><br><span class="line">            <span class="keyword">if</span> i &lt; L:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> i &lt;= R:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    table = [</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">4</span>,</span><br><span class="line">        <span class="number">9</span>,</span><br><span class="line">        <span class="number">121</span>,</span><br><span class="line">        <span class="number">484</span>,</span><br><span class="line">        <span class="number">10201</span>,</span><br><span class="line">        <span class="number">12321</span>,</span><br><span class="line">        <span class="number">14641</span>,</span><br><span class="line">        <span class="number">40804</span>,</span><br><span class="line">        <span class="number">44944</span>,</span><br><span class="line">        <span class="number">1002001</span>,</span><br><span class="line">        <span class="number">1234321</span>,</span><br><span class="line">        <span class="number">4008004</span>,</span><br><span class="line">        <span class="number">100020001</span>,</span><br><span class="line">        <span class="number">102030201</span>,</span><br><span class="line">        <span class="number">104060401</span>,</span><br><span class="line">        <span class="number">121242121</span>,</span><br><span class="line">        <span class="number">123454321</span>,</span><br><span class="line">        <span class="number">125686521</span>,</span><br><span class="line">        <span class="number">400080004</span>,</span><br><span class="line">        <span class="number">404090404</span>,</span><br><span class="line">        <span class="number">10000200001</span>,</span><br><span class="line">        <span class="number">10221412201</span>,</span><br><span class="line">        <span class="number">12102420121</span>,</span><br><span class="line">        <span class="number">12345654321</span>,</span><br><span class="line">        <span class="number">40000800004</span>,</span><br><span class="line">        <span class="number">1000002000001</span>,</span><br><span class="line">        <span class="number">1002003002001</span>,</span><br><span class="line">        <span class="number">1004006004001</span>,</span><br><span class="line">        <span class="number">1020304030201</span>,</span><br><span class="line">        <span class="number">1022325232201</span>,</span><br><span class="line">        <span class="number">1024348434201</span>,</span><br><span class="line">        <span class="number">1210024200121</span>,</span><br><span class="line">        <span class="number">1212225222121</span>,</span><br><span class="line">        <span class="number">1214428244121</span>,</span><br><span class="line">        <span class="number">1232346432321</span>,</span><br><span class="line">        <span class="number">1234567654321</span>,</span><br><span class="line">        <span class="number">4000008000004</span>,</span><br><span class="line">        <span class="number">4004009004004</span>,</span><br><span class="line">        <span class="number">100000020000001</span>,</span><br><span class="line">        <span class="number">100220141022001</span>,</span><br><span class="line">        <span class="number">102012040210201</span>,</span><br><span class="line">        <span class="number">102234363432201</span>,</span><br><span class="line">        <span class="number">121000242000121</span>,</span><br><span class="line">        <span class="number">121242363242121</span>,</span><br><span class="line">        <span class="number">123212464212321</span>,</span><br><span class="line">        <span class="number">123456787654321</span>,</span><br><span class="line">        <span class="number">400000080000004</span>,</span><br><span class="line">        <span class="number">10000000200000001</span>,</span><br><span class="line">        <span class="number">10002000300020001</span>,</span><br><span class="line">        <span class="number">10004000600040001</span>,</span><br><span class="line">        <span class="number">10020210401202001</span>,</span><br><span class="line">        <span class="number">10022212521222001</span>,</span><br><span class="line">        <span class="number">10024214841242001</span>,</span><br><span class="line">        <span class="number">10201020402010201</span>,</span><br><span class="line">        <span class="number">10203040504030201</span>,</span><br><span class="line">        <span class="number">10205060806050201</span>,</span><br><span class="line">        <span class="number">10221432623412201</span>,</span><br><span class="line">        <span class="number">10223454745432201</span>,</span><br><span class="line">        <span class="number">12100002420000121</span>,</span><br><span class="line">        <span class="number">12102202520220121</span>,</span><br><span class="line">        <span class="number">12104402820440121</span>,</span><br><span class="line">        <span class="number">12122232623222121</span>,</span><br><span class="line">        <span class="number">12124434743442121</span>,</span><br><span class="line">        <span class="number">12321024642012321</span>,</span><br><span class="line">        <span class="number">12323244744232321</span>,</span><br><span class="line">        <span class="number">12343456865434321</span>,</span><br><span class="line">        <span class="number">12345678987654321</span>,</span><br><span class="line">        <span class="number">40000000800000004</span>,</span><br><span class="line">        <span class="number">40004000900040004</span></span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Enumeration</tag>
      </tags>
  </entry>
  <entry>
    <title>92. Reverse Linked List II (Medium)</title>
    <url>/post/leetcode/92-Reverse-Linked-List-II-Medium/</url>
    <content><![CDATA[<p>链表问题。实现一个程序根据 2 个下标位置对链表对于位置的元素进行翻转。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">Output: [1,4,3,2,5]</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>啥也不多说，看看算法。</p>
<ul>
<li>把 <code>LinkedList</code> 转换成 <code>List；</code></li>
<li>交换 <code>left</code> 和 <code>right</code> 的值；</li>
<li>更新 <code>left</code> 和 <code>right</code> 指针；</li>
<li>重复过程直到 <code>left</code> 不再小于 <code>right</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: ListNode, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        nodes = [head]</span><br><span class="line">        <span class="keyword">while</span> head.<span class="built_in">next</span>:</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            nodes.append(head)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            nodes[left - <span class="number">1</span>].val, nodes[right - <span class="number">1</span>].val = nodes[right - <span class="number">1</span>].val, nodes[left - <span class="number">1</span>].val</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nodes[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>94. Binary Tree Inorder Traversal (Easy)</title>
    <url>/post/leetcode/94-Binary-Tree-Inorder-Traversal-Easy/</url>
    <content><![CDATA[<p>遍历树的方法通常有三种，分别是前序遍历 pre-order traversal、中序遍历 in-order traversal 和后序遍历 post-order traversal。这道题是中序遍历。</p>
<p>难度上来说，前序最简单，中序和后序遍历会复杂一点。</p>
<span id="more"></span>

<h2 id="思路-1，递归"><a href="#思路-1，递归" class="headerlink" title="思路 1，递归"></a>思路 1，递归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            traverse(node.left)</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            traverse(node.right)</span><br><span class="line"></span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，遍历"><a href="#思路-2，遍历" class="headerlink" title="思路 2，遍历"></a>思路 2，遍历</h2><p>基于前序遍历的方案做的修改，可以解决问题，但是在空间复杂度上有优化余地，为了储存 stack 使用了额外的 2n 的空间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans, stack = [], [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">type</span>(node) == <span class="built_in">int</span>:</span><br><span class="line">                ans.append(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">                stack.append(node.val)</span><br><span class="line">                stack.append(node.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-3，遍历，优化版本"><a href="#思路-3，遍历，优化版本" class="headerlink" title="思路 3，遍历，优化版本"></a>思路 3，遍历，优化版本</h2><p>中序遍历要先遍历左节点，所以先抵达最左路径的最后一个节点，从这个节点开始回溯，重复检查左节点，本体和右节点的顺序。</p>
<p>这其实是思路 1 递归的扁平化处理，使用 stack 来替代递归过程。时间复杂度和空间复杂度均为 O(n)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans, stack, curr = [], [], root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">or</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># find the leftmost node</span></span><br><span class="line">            <span class="keyword">while</span> curr:</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr = curr.left</span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            <span class="comment"># record its value</span></span><br><span class="line">            ans.append(curr.val)</span><br><span class="line">            <span class="comment"># start the next turn with its right node</span></span><br><span class="line">            curr = curr.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-4，莫里斯遍历-Morris-Traversal"><a href="#思路-4，莫里斯遍历-Morris-Traversal" class="headerlink" title="思路 4，莫里斯遍历 Morris Traversal"></a>思路 4，莫里斯遍历 Morris Traversal</h2><p>也叫线索二叉树（Threaded Binary Tree），修改树的结构，让其“穿起来”成为一条线，整个遍历过程重复修改结构 -&gt; 遍历数据的过程。</p>
<p>具体做法如下：</p>
<ul>
<li>当前节点不存在左节点时<ul>
<li>记录当前节点值</li>
<li>将右节点标记为当前节点</li>
</ul>
</li>
<li>当前节点存在左节点时<ul>
<li>将当前节点挂在左节点的最后一个右节点上</li>
<li>将左节点标记为当前节点</li>
</ul>
</li>
<li>重复这个过程直到不存在当前节点</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans, curr = [], root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">if</span> curr.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                ans.append(curr.val)</span><br><span class="line">                curr = curr.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = curr.left</span><br><span class="line">                <span class="keyword">while</span> pre.right:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                pre.right = curr</span><br><span class="line">                curr.left, curr = <span class="literal">None</span>, curr.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>抄一个 Threaded Binary Tree 的解释方便理解。</p>
<blockquote>
<p>For example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   /</span><br><span class="line">4   5 6</span><br></pre></td></tr></table></figure>

<p>First, 1 is the root, so initialize 1 as current, 1 has left child which is 2, the current’s left subtree is</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>

<p>So in this subtree, the rightmost node is 5, then make the current(1) as the right child of 5. Set current = cuurent.left (current = 2). The tree now looks like:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br><span class="line">     \</span><br><span class="line">      1</span><br><span class="line">       \</span><br><span class="line">        3</span><br><span class="line">       /</span><br><span class="line">      6</span><br></pre></td></tr></table></figure>

<p>For current 2, which has left child 4, we can continue with thesame process as we did above</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    5</span><br><span class="line">     \</span><br><span class="line">      1</span><br><span class="line">       \</span><br><span class="line">        3</span><br><span class="line">       /</span><br><span class="line">      6</span><br></pre></td></tr></table></figure>

<p>then add 4 because it has no left child, then add 2, 5, 1, 3 one by one, for node 3 which has left child 6, do the same as above. Finally, the inorder traversal is [4,2,5,1,6,3].</p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>943. Find the Shortest Superstring (Hard)</title>
    <url>/post/leetcode/943-Find-the-Shortest-Superstring-Hard/</url>
    <content><![CDATA[<h2 id="NOT-SOLVED-YET"><a href="#NOT-SOLVED-YET" class="headerlink" title="NOT SOLVED YET!!"></a>NOT SOLVED YET!!</h2><p>计算完每个字符串的 overlap 之后，这个问题变成了有向加权图的最短路径问题，这是一个典型的 TSP 问题，NP-Hard 难度。</p>
<p>由于暂时还是我的只是盲区，先做记录，等学到图论和 TSP 解法的时候再来看看这道题。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
        <tag>DP</tag>
        <tag>Bit Manipulation</tag>
        <tag>Bitmask</tag>
        <tag>Not Solved</tag>
      </tags>
  </entry>
  <entry>
    <title>968. Binary Tree Cameras (Hard)</title>
    <url>/post/leetcode/968-Binary-Tree-Cameras-Hard/</url>
    <content><![CDATA[<p>在二叉树上安装摄像头，每个摄像头可以监控 +1 的距离，也就是它的父节点、子节点和自身。求最少需要安装多少摄像头才能监控整棵树。</p>
<p>这道题我们讨论贪心算法和 DP 的应用。</p>
<span id="more"></span>

<h2 id="思路-1，贪心从下而上"><a href="#思路-1，贪心从下而上" class="headerlink" title="思路 1，贪心从下而上"></a>思路 1，贪心从下而上</h2><p>这里能使用贪心算法是因为我们可以从叶子节点开始，给叶子节点的父节点安装摄像头，并一步步往上推出需要安装摄像头的最小数量。</p>
<p>解题思路的第一步是要推算一个节点能有多少种状态，这道题每个节点存在 3 种状态：</p>
<ul>
<li><code>0</code>: 无摄像头覆盖</li>
<li><code>1</code>: 有摄像头覆盖</li>
<li><code>2</code>: 节点安装了摄像头</li>
</ul>
<p>第二步是要处理父节点遇到子节点处于上面各种状态时应该如何应对，根据状态有三种应对，我们需要按照顺序处理，即在下面的判断已经排除了上面的判断条件：</p>
<ul>
<li>左右子节点有一个无摄像头覆盖（<code>0</code>）：此时父节点必须安装摄像头，即返回 <code>2</code></li>
<li>左右子节点有一个安装了摄像头（<code>2</code>）：由于已经判断子节点没有无覆盖的情况，此时父节点可以算有摄像头覆盖，返回 <code>1</code></li>
<li>除了上述情况以外（左右子节点均为 <code>1</code>）：由于没有子节点安装摄像头，此时父节点只能是无摄像头覆盖，返回 <code>0</code></li>
</ul>
<p>第二步程序的思路已经明确了，但是有些特殊情况需要处理，所以第三步我们要找出特殊 case。这里有 2 个特殊情况需要考虑：</p>
<ul>
<li>叶子节点的处理<ul>
<li>由于我们希望叶子节点的父节点安装摄像头，所以我们希望叶子节点返回无摄像头覆盖（<code>0</code>）</li>
<li>已知叶子节点的左右子节点均为空<ul>
<li>根据第二步总结的思路，当左右节点均为有摄像头覆盖（<code>1</code>）时，父节点才能返回无摄像头覆盖（<code>0</code>）</li>
<li>结论：对于空节点需要返回有摄像头覆盖（<code>1</code>）</li>
</ul>
</li>
</ul>
</li>
<li>对于 <code>root</code> 节点的处理<ul>
<li><code>root</code> 节点也存在左右子节点存在无摄像头覆盖（<code>0</code>）的情况，有可能需要安装摄像头，这里有 2 种处理方法：<ol>
<li>父节点需要安装摄像头时必须返回 <code>2</code>，所以判断递归最后一次返回值为 2 时主动增加一次计数</li>
<li>或者，用一个 <code>dummy</code> 节点包装 <code>root</code> 节点，将对其的处理包括在递归过程中，我们不关注 <code>dummy</code> 节点的返回值，这样可以省去手动判断</li>
</ol>
</li>
<li>这里我们选择第二种做法</li>
</ul>
</li>
</ul>
<p>思路整理到这里，可以开始实现算法了，下面是 Python 代码例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCameraCover</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 0: not covered</span></span><br><span class="line">        <span class="comment"># 1: covered</span></span><br><span class="line">        <span class="comment"># 2: has camera</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># Mark none as covered</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            left = dfs(node.left)</span><br><span class="line">            right = dfs(node.right)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">min</span>(left, right) == <span class="number">0</span>:</span><br><span class="line">                self.ans += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">max</span>(left, right) == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        <span class="comment"># Wrap root with a dummy node to avoid special case of 0 at root.</span></span><br><span class="line">        dfs(TreeNode(left=root))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，DP"><a href="#思路-2，DP" class="headerlink" title="思路 2，DP"></a>思路 2，DP</h2><p>忘掉思路 1，来看看 DP 的解决方案。</p>
<p>思路 1 总结的状态对 DP 方案不适用，忘掉它，我们重新总结一个节点<strong>允许的状态</strong>，这里不再包括无摄像头覆盖的场景。</p>
<p>第一步，总结节点可能的状态有三种：</p>
<ul>
<li><code>BY_CH</code>：by children，节点被子节点的摄像头覆盖</li>
<li><code>BY_PR</code>：by parent，节点被父节点的摄像头覆盖</li>
<li><code>HAS_C</code>：has camera，节点被自己的摄像头覆盖</li>
</ul>
<p>第二步，应用 DP。程序整体的做法是针对一个节点所有状态分别计算需要的摄像头数量，递交给上一层递归进行下一步判断，直到达到 <code>root</code> 节点时，由于不再存在父节点，取 <code>BY_CH</code> 和 <code>HAS_C</code> 的最小值作为答案。</p>
<p>对于每一次递归的逻辑，我们需要分别计算这三种状态下的摄像头安装数量，如果通过 flag 控制递归过程计算三次不同的值将造成大量重复计算（因为每个节点将执行 3 次递归逻辑），所以在每次递归逻辑中计算并返回这三个状态的值才是最优解。</p>
<p>在递归逻辑中我们执行下面的计算（已知当前节点（<code>node</code>）和左右子节点（<code>left</code>，<code>right</code>）及其三个状态值）：</p>
<ul>
<li><code>BY_CH</code>：当前节点不安装摄像头，需要考虑子节点 <code>BY_CH</code> 和 <code>HAS_C</code> 的情况，我们取下面情况的最小值：<ul>
<li><code>left.HAS_C</code> + <code>right.HAS_C</code> ：左右子节点都存在摄像头，不需要当前节点安装摄像头</li>
<li><code>left.HAS_C</code> + <code>right.BY_CH</code> ：左节点存在摄像头，右节点被其子节点覆盖，不需要当前节点安装摄像头</li>
<li><code>left.BY_CH</code> + <code>right.HAS_C</code> ：左节点被其子节点覆盖，右节点存在摄像头，不需要当前节点安装摄像头</li>
</ul>
</li>
<li><code>BY_PR</code>：当前节点不安装摄像头，也不依赖子节点安装摄像头，这个状态仅比上面多一种情况：<ul>
<li><code>node.BY_CH</code> ：当前节点依赖子节点安装摄像头的状态值，使用这个值避免重复计算</li>
<li><code>left.BY_CH</code> + <code>right.BY_CH</code> ：左右子节点被各自的子节点的摄像头覆盖，不需要当前节点安装摄像头</li>
</ul>
</li>
<li><code>HAS_C</code>：当前节点<strong>安装摄像头</strong>，需要考虑子节点 <code>BY_PR</code> 和 <code>HAS_C</code> 的情况，取下面状态的最小值，<strong>在此基础上+1</strong>：<ul>
<li><code>left.BY_PR</code> + <code>right.BY_PR</code> ：左右子节点都依赖当前节点安装摄像头</li>
<li><code>left.BY_PR</code> + <code>right.HAS_C</code> ：左节点依赖当前节点安装摄像头，右节点存在摄像头</li>
<li><code>left.HAS_C</code> + <code>right.BY_PR</code> ：左节点存在摄像头，右节点依赖当前节点安装摄像头</li>
</ul>
</li>
</ul>
<blockquote>
<p>在计算 <code>HAS_C</code> 时不应该考虑子节点被其子节点覆盖（<code>BY_CH</code>）的情况，从逻辑上来说，如果子节点被其子节点覆盖，也就不再依赖父节点安装摄像头；其次，考虑下面的 case，如果节点 A 考虑子节点 B 依赖其子节点覆盖的情况，那么为了覆盖节点 B 的两个子节点，B 的 <code>BY_CH</code> 状态值将等于 2，那么如果节点 A 安装摄像头，A 的 <code>HAS_C</code> 最终为 2 + 1 = 3，已经偏离最优解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   O</span><br><span class="line">   │</span><br><span class="line">┌──┴──┐</span><br><span class="line">│     │</span><br><span class="line">O     O(A)</span><br><span class="line">      │</span><br><span class="line">   ┌──┴──┐</span><br><span class="line">   │     │</span><br><span class="line">   O     O(B)</span><br><span class="line">         │</span><br><span class="line">      ┌──┴──┐</span><br><span class="line">      │     │</span><br><span class="line">      O     O</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个思路需要考虑的特殊情况同样是叶子节点和递归返回值。</p>
<ul>
<li>叶子节点<ul>
<li>叶子节点不存在被子节点覆盖（<code>BY_CH</code>）的情况<ul>
<li>所以将其子节点的 <code>HAS_C</code> 设为无限大，这个值将在下一次计算中被舍弃</li>
<li>其子节点的另外两个状态初始化为 0 即可</li>
</ul>
</li>
</ul>
</li>
<li><code>root</code> 节点的递归返回值<ul>
<li>之前已经解释过了，对于 <code>root</code> 来说已经不存在父节点了，所以我们在其返回值中取 <code>BY_CH</code> 和 <code>HAS_C</code> 的最小值作为答案</li>
</ul>
</li>
</ul>
<p>思路整理结束，信息量足够开始实现算法了。下面是 Python 代码例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BY_PR = <span class="number">0</span> <span class="comment"># covered by parent</span></span><br><span class="line">BY_CH = <span class="number">1</span> <span class="comment"># covered by children</span></span><br><span class="line">HAS_C = <span class="number">2</span> <span class="comment"># has camera</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCameraCover</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">df</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            l = df(node.left)</span><br><span class="line">            r = df(node.right)</span><br><span class="line">            bych = <span class="built_in">min</span>(l[HAS_C] + r[HAS_C], l[HAS_C] + r[BY_CH], l[BY_CH] + r[HAS_C])</span><br><span class="line">            bypr = <span class="built_in">min</span>(l[BY_CH] + r[BY_CH], bych)</span><br><span class="line">            hasc = <span class="built_in">min</span>(l[BY_PR] + r[BY_PR], l[BY_PR] + r[HAS_C], l[HAS_C] + r[BY_PR]) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> bypr, bych, hasc</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(df(root)[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>贪心和 DP 思路差异比较明显。</p>
<ul>
<li>贪心思路默认处于最优情况，只讨论最坏 case</li>
<li>DP 思路计算所有情况，仅舍弃不合理的 case</li>
</ul>
<p>但是两者都需要清晰的有目的性的思考才能理清思路，相对来说，DP 方案比贪心方案要容易一些，因为贪心方案需要更加细致的观察。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>DFS</tag>
        <tag>Binary Tree</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>97. Interleaving String (Medium)</title>
    <url>/post/leetcode/97-Interleaving-String-Medium/</url>
    <content><![CDATA[<p>字符串问题。定义字符串交错指的是俩个字符串的字符交错出现构成一个新的字符串。比如对字符串 <code>s</code> 和 <code>t</code> 来说：</p>
<ul>
<li><code>s = s1 + s2 + ... + sn</code></li>
<li><code>t = t1 + t2 + ... + tm</code></li>
<li><code>|n - m| &lt;= 1</code></li>
<li>The <strong>interleaving</strong> is <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> or <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li>
</ul>
<p>现在你需要实现一个程序接受三个字符串 <code>s1</code>、 <code>s2</code>、 <code>s3</code>，判断 <code>s3</code> 是否是 <code>s1</code> 和 <code>s2</code> 字符串交错组成。</p>
<span id="more"></span>

<h2 id="思路-1，2D-数组动态规划"><a href="#思路-1，2D-数组动态规划" class="headerlink" title="思路 1，2D 数组动态规划"></a>思路 1，2D 数组动态规划</h2><p>这题乍一看用快慢指针可以解出来，但是这是个陷阱，设想如果下一个字符可以同时从 <code>s1</code> 和 <code>s2</code> 中取得，如果使用快慢指针这里如何处理？可以考虑回溯算法，但是这变成了暴力破解，无法在时限内通过测试 case。</p>
<p>DP 相关的题目对思路和直觉有要求，为了方便后面的计算，我们先把一个特殊 case 排除在外：</p>
<ul>
<li>如果 <code>s1.length</code> + <code>s2.length</code> != <code>s3.length</code>，那就没有必要计算了，直接返回 <code>false</code>。</li>
</ul>
<p>接下来分析 DP 的思路。</p>
<ul>
<li>准备一个 <code>(m + 1)</code> * <code>(n + 1)</code> 的 2D 数组；<ul>
<li><code>m</code>：<code>s1.length</code>；<code>n</code>：<code>s2.length</code>；</li>
<li>+ 1 的原因是要留出第一个字符不选 <code>s1</code> 或 <code>s2</code> 的空间；</li>
</ul>
</li>
<li>初始化 <code>dp[0][0]</code> 为 <code>true</code> or 1，这个坐标意味长度为 0 的场景；</li>
<li>接下来要做的事情就是遍历 <code>dp</code> 的所有元素，计算对应下标的元素的值；</li>
<li>如果最后一个元素 <code>dp[-1][-1]</code> 的值为 <code>true</code> or 1，则 <code>s1</code> 和 <code>s2</code> 可以交替构成 <code>s3</code>。</li>
</ul>
<p>我们可以用示例画出对应的表格来帮助理解。</p>
<p>s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbcbcac”</p>
<table>
<thead>
<tr>
<th align="center">n \ m</th>
<th align="center">0</th>
<th align="center">1(a)</th>
<th align="center">2(a)</th>
<th align="center">3(b)</th>
<th align="center">4(c)</th>
<th align="center">5(c)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1(d)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">2(b)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">3(b)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">4(c)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">5(a)</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>可以观察到，从 （0， 0） 开始，我们行走的方向只有向右和向下。</p>
<ul>
<li>向右：选择使用 <code>s1</code> 的字符，如果下一个字符匹配 <code>s3[row + col - 1]</code> 则设其值为 1；</li>
<li>向下：选择使用 <code>s2</code> 的字符，如果下一个字符匹配 <code>s3[row + col - 1]</code> 则设其值为 1。</li>
</ul>
<p>换言之，要计算当前位置的值时，需要先检查上面一个和左边一个值是否被选用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span>, s3: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s1) + <span class="built_in">len</span>(s2) != <span class="built_in">len</span>(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        m, n = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(m + <span class="number">1</span>), <span class="built_in">range</span>(n + <span class="number">1</span>)):</span><br><span class="line">            k, top, left = i + j - <span class="number">1</span>, <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                top = s3[k] == s1[i - <span class="number">1</span>] <span class="keyword">and</span> dp[i - <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j != <span class="number">0</span>:</span><br><span class="line">                left = s3[k] == s2[j - <span class="number">1</span>] <span class="keyword">and</span> dp[i][j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> i + j &gt; <span class="number">0</span>:</span><br><span class="line">                dp[i][j] = top <span class="keyword">or</span> left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="思路-2，1D-数组动态规划"><a href="#思路-2，1D-数组动态规划" class="headerlink" title="思路 2，1D 数组动态规划"></a>思路 2，1D 数组动态规划</h2><p>通过观察可以知道上面方法每次最多只看到上一行，那么实际上我们没必要准备一个全量的 2D 数组，一个 1D 数组足够处理这些数据了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span>, s3: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s1) + <span class="built_in">len</span>(s2) != <span class="built_in">len</span>(s3):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        m, n = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line"></span><br><span class="line">        dp = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(m + <span class="number">1</span>), <span class="built_in">range</span>(n + <span class="number">1</span>)):</span><br><span class="line">            k, top, left = i + j - <span class="number">1</span>, <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                top = s3[k] == s1[i - <span class="number">1</span>] <span class="keyword">and</span> dp[j]</span><br><span class="line">            <span class="keyword">if</span> j != <span class="number">0</span>:</span><br><span class="line">                left = s3[k] == s2[j - <span class="number">1</span>] <span class="keyword">and</span> dp[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> i + j &gt; <span class="number">0</span>:</span><br><span class="line">                dp[j] = top <span class="keyword">or</span> left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>970. Powerful Integers (Medium)</title>
    <url>/post/leetcode/970-Powerful-Integers-Medium/</url>
    <content><![CDATA[<p>给定 3 个整数 <code>x</code>， <code>y</code>， <code>bound</code>，求所有小于等于 <code>bound</code> 的强整数（Powerful Integers）。</p>
<p>强整数（Powerful Integers）指一个数可以用 <code>x^i + y^j</code> 的形式表现，其中 <code>i</code> 和 <code>j</code> 均大于等于 0。</p>
<p>答案无所谓排序，但是不能有重复的值。需要用到一些数学方法来解决这道题。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先找到指数的边界，然后枚举所有可能的结果。</p>
<p>使用一个 <code>set</code> 来进行去重。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">powerfulIntegers</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span>, bound: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        a = <span class="number">0</span> <span class="keyword">if</span> x == <span class="number">1</span> <span class="keyword">else</span> <span class="built_in">int</span>(log(bound, x))</span><br><span class="line">        b = <span class="number">0</span> <span class="keyword">if</span> y == <span class="number">1</span> <span class="keyword">else</span> <span class="built_in">int</span>(log(bound, y))</span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a + <span class="number">1</span>):</span><br><span class="line">            left = x ** i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(b + <span class="number">1</span>):</span><br><span class="line">                r = left + y ** j</span><br><span class="line">                <span class="keyword">if</span> r &lt;= bound:</span><br><span class="line">                    ans.add(r)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(ans)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Homelab Step 0 - Install CentOS</title>
    <url>/post/notes/homelab/Step0-Install-Centos/</url>
    <content><![CDATA[<p>最近准备搭建一个 Homelab，用来方便生活&amp;方便学习。在考虑购入合适硬件的同时，不妨用手头更新换代闲置的旧 PC 来先做一下尝试。我的旧 PC 当年配置尚可，相信现在还是可以胜任一个入门 Homelab 来耍耍。</p>
<p>首先在闲置 PC 上安装 CentOS 系统，同时移除不再使用的 Windows 系统。</p>
<span id="more"></span>

<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作</a></li>
<li><a href="#%E4%B8%8B%E8%BD%BD-centos-%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F">下载 CentOS 系统镜像</a></li>
<li><a href="#%E5%B0%86%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%E5%86%99%E5%85%A5-u-%E7%9B%98">将系统镜像写入 U 盘</a></li>
<li><a href="#%E5%AE%89%E8%A3%85-centos-%E7%B3%BB%E7%BB%9F">安装 CentOS 系统</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5-wifi">链接 WIFI</a></li>
<li><a href="#%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4">同步时间</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE-ssh-key">配置 SSH key</a></li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始安装 CentOS 到旧 PC 之前，先确保下面这些准备工作已经完成。</p>
<ul>
<li>确定旧 PC 可以正常工作</li>
<li>准备一个 U 盘用来刻录系统镜像</li>
<li>事先备份好 PC 上到重要数据</li>
<li>准备一根网线连接你的路由器</li>
</ul>
<p>装机的介质我选择了 U 盘，这是为了进行 clean 安装（全盘格式化，删除旧系统）而准备的。除了 U 盘之外，如果你有一个 DVD 光驱，你也可以用光盘来替代。</p>
<p>同样的，我们将进行全盘格式化清洁安装系统，所以先确保 PC 上的重要数据全都做好了备份。避免数据丢失造成不必要的损失。</p>
<p>同时我们还需要一根网线用来确保网络。CentOS 8 在装机之后 WIFI 并不能开箱即用，需要联网安装 <code>NetworkManager-wifi</code> 工具启动。</p>
<h2 id="下载-CentOS-系统镜像"><a href="#下载-CentOS-系统镜像" class="headerlink" title="下载 CentOS 系统镜像"></a>下载 CentOS 系统镜像</h2><p>从 CentOS 官网下载最新的系统镜像文件。</p>
<p><a href="https://www.centos.org/download/">https://www.centos.org/download/</a></p>
<p>选择想安装的系统版本，选择合适的 mirror 链接下载，阿里云的就不错。在下载 ISO 文件时注意选择 DVD1 ISO，这个版本还包括一些方便的 packages 可以顺便安装，建议大部分用户选择。（<a href="https://docs.centos.org/en-US/8-docs/standard-install/assembly_preparing-for-your-installation/#downloading-beta-installation-images_preparing-for-your-installation">为什么？点我查看</a>）</p>
<p>这里我选择的是 CentOS-8.2.2004。文件大小 8G，不过 mirror 站网速不错，下载只用了几分钟时间。</p>
<h2 id="将系统镜像写入-U-盘"><a href="#将系统镜像写入-U-盘" class="headerlink" title="将系统镜像写入 U 盘"></a>将系统镜像写入 U 盘</h2><p>准备一个至少 16G 的 U 盘，将 CentOS 系统 ISO 文件写入其中，制作成一个装机盘。这需要一个刻录工具，如果你没有合适的刻录工具，在 Windows 平台，官方推荐 <a href="https://github.com/FedoraQt/MediaWriter/releases">Fedora Media Writer</a> 来完成装机 U 盘的制作。</p>
<p>刚好我没有一个合适的刻录工具 😂，而且 U 盘只能在 Windows 下被识别，所以尝试了一下 Fedora Media Writer。步骤属于傻瓜操作。</p>
<ul>
<li>下载 Win 平台 Fedora Media Writer 安装程序并进行安装</li>
</ul>
<blockquote>
<p><a href="https://github.com/FedoraQt/MediaWriter/releases">https://github.com/FedoraQt/MediaWriter/releases</a></p>
</blockquote>
<ul>
<li>启动 Fedora Media Writer 选择 [自定义镜像]</li>
</ul>
<p><img src="/images/notes/homelab/fedora_media_writer.jpg" alt="fedora_media_writer"></p>
<ul>
<li>在弹出框中找到上面下载的 CentOS 系统镜像，我这里是 <code>CentOS-8.2.2004-x86_64-dvd1.iso</code></li>
<li>在接下来的菜单中选择插入的 U 盘，点击 [写入磁盘] 开始刻录</li>
</ul>
<p><img src="/images/notes/homelab/write_to_flash_driver.jpg" alt="write_to_flash_driver"></p>
<p>等待一会，刻录完成即可开始安装系统。</p>
<h2 id="安装-CentOS-系统"><a href="#安装-CentOS-系统" class="headerlink" title="安装 CentOS 系统"></a>安装 CentOS 系统</h2><p>将 U 盘插入闲置 PC，开机进入 BIOS，选择 USB Storage Device 启动。不出意外的话，将正常进行 CentOS 系统的安装。</p>
<p>安装界面是一个 GUI，可以根据需求定制一下安装过程。</p>
<p><strong>移除旧 Windows 系统</strong></p>
<p>操作前请先做好数据备份（如果有关键数据的话）。CentOS 选择挂载硬盘时，选择对硬盘进行 reclaim，清除所有数据。这样，旧 Windows 系统将直接被删除。</p>
<p>由于只是一次尝试，安装过程就基本按照默认设置来了，在 GUI 界面可以设置一下 WIFI 链接，方便后面操作。当然掠过也无所谓，可以使用 <code>nmuti</code> 进行配置。</p>
<p>Homelab 不需要一个 GUI，所以在安装选项上我选择了不带 GUI 的 server。</p>
<p>总结一下，主要配置完下面的内容，就可以进入安装阶段了。</p>
<ul>
<li>安装内容（server without GUI）</li>
<li>挂载硬盘（reclaim 所有空间进行 clean 安装）</li>
<li>语言和时间设置</li>
</ul>
<p>安装阶段可以对 root 用户设置密码。然后，稍等片刻，安装很快就会结束。</p>
<h2 id="链接-WIFI"><a href="#链接-WIFI" class="headerlink" title="链接 WIFI"></a>链接 WIFI</h2><p>先准备一根网线，连接机器和路由器，保证网络。</p>
<p>对我来说始终连接网线不太方便，我的机器存在无线网卡，所以决定出于方便这台实验性质的 Homelab 就使用 WIFI 联网。</p>
<p>CentOS 的 WIFI 并非开箱即用，所以我们需要先保证网络。网络畅通的情况下输入下面的命令安装 WIFI 组件。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install NetworkManager-wifi</span></span><br></pre></td></tr></table></figure>

<p>安装完成后 <code>reboot</code> 一次，拔掉网线，WIFI 将会自动连接。</p>
<blockquote>
<p>如果 WIFI 不稳定，可以换成有线连接，此时需要手动关闭 WIFI 连接。可以输入下面命令。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nmcli radio wifi off</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="同步时间"><a href="#同步时间" class="headerlink" title="同步时间"></a>同步时间</h2><p>本地时间与互联网时间不同步会造成部分在线服务无法访问。在 CentOS 8 中与互联网同步时间需要手动设置。</p>
<p>首先保证时间同步工具 <code>chrony</code> 已经安装。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dnf install -y chrony</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>CentOS 8 中 dnf 代替 yum 成为默认包管理工具。不过 yum 依旧可以使用。</p>
</blockquote>
<p>确保工具安装之后，编辑一下配置文件，将时间同步服务器修改为国内地区服务器来加快访问速度。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi /etc/chrony.conf</span></span><br></pre></td></tr></table></figure>

<p>将第一行替换为 <code>pool ntp.ntsc.ac.cn iburst</code>。</p>
<p>启动自动同步时间。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> chronyd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl start chronyd</span></span><br></pre></td></tr></table></figure>

<p>稍等片刻，时间将会自动与服务器进行同步。</p>
<h2 id="配置-SSH-key"><a href="#配置-SSH-key" class="headerlink" title="配置 SSH key"></a>配置 SSH key</h2><p>为了方便常用机连接 Homelab 进行操作，可以将常用机的 SSH key 添加到 Homelab 对应用户的 authorized_keys 中以方便登陆。设置完成之后登陆不再需要密码。</p>
<blockquote>
<p>不需要密码就可以登陆 Homelab，意味着任何人使用你的账号都可以访问到你的服务器，请谨慎考虑其中的风险，不建议在公共机器进行这个设定。</p>
</blockquote>
<p>首先需要准备一个 SSH key。如果你使用 Github 或者类似的 git 仓库，那么应该存在一个 SSH key 在你的用户文件夹中。所以先检查 SSH key 是否存在。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l ~/.ssh</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> or <span class="keyword">in</span> windows</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls c:\users\&lt;username&gt;\.ssh</span></span><br></pre></td></tr></table></figure>

<p>如果你看到一个 <code>id_rsa.pub</code> 或者其他以 <code>.pub</code> 结尾的文件存在，这就是你的 SSH key 了，你可以选择复用它，也可以用下面命令重新生成一个。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -b 2048</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>生成新的 SSH key 时会提示你选择 key 储存的位置和密码，可以根据需求设置。密码可以留空，表示不需要使用密码。</p>
</blockquote>
<p>先看看 SSH key 的内容。等下需要使用到，可以考虑临时保存一下。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat ~/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure>

<p>SSH key 内容应该是以 <code>ssh-rsa</code> 开始，以你设定到邮箱结尾的一串文本。接下俩我们将其添加到 Homelab 上。</p>
<p>先使用开发机用密码远程登陆 Homelab。注意 <code>@</code> 后面的主机地址，我这里用 <code>homelab</code> 指代，实际上这里应该填写主机的局域网地址。以后我们也会将 Homelab 绑定到固定到域名上方便我们访问，目前我们还是局域网内访问。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh root@homelab</span></span><br></pre></td></tr></table></figure>

<p>在输入密码完成登陆后，我们在希望免密码登陆的用户的目录下面添加 <code>authorized_keys</code> 文件。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch ~/.ssh/authorized_keys</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> copy your ssh key and paste it into this file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim ~/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure>

<p>将开发机的 SSH key 添加到这个文件并保存。</p>
<p>退出当前登陆，重新尝试一次 SSH 登陆。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">exit</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh root@homelab</span></span><br></pre></td></tr></table></figure>

<p>如果这里不再提示密码，则表示配置成功。</p>
<blockquote>
<p>配置 SSH key 还可以方便 VS Code 远程访问 Homelab，以方便编辑配置文件。</p>
</blockquote>
<p>到此 CentOS 的安装和配置就完成了。</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>homelab</category>
      </categories>
      <tags>
        <tag>Homelab</tag>
      </tags>
  </entry>
  <entry>
    <title>Homelab Step 1 - Install Docker</title>
    <url>/post/notes/homelab/Step1-Install-Docker/</url>
    <content><![CDATA[<p>在 CentOS 8 上安装 Docker。参考官网文档。</p>
<p><a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
<p>这里使用官方推荐的方法进行安装并记录一下步骤。</p>
<span id="more"></span>

<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E4%BB%93%E5%BA%93">设置仓库</a></li>
<li><a href="#%E5%AE%89%E8%A3%85-docker-engine">安装 Docker Engine</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8-docker-engine">启动 Docker Engine</a></li>
<li><a href="#%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE">防火墙设置</a></li>
<li><a href="#optional-%E5%AE%89%E8%A3%85-docker-compose">(Optional) 安装 docker-compose</a></li>
</ul>
<h2 id="设置仓库"><a href="#设置仓库" class="headerlink" title="设置仓库"></a>设置仓库</h2><p>安装 <code>yum-utils</code>，使用其中的 <code>yum-config-manage</code> 工具将 docker 的 repo 添加到仓库。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y yum-utils</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager \</span></span><br><span class="line"><span class="bash">    --add-repo \</span></span><br><span class="line"><span class="bash">    https://download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure>

<h2 id="安装-Docker-Engine"><a href="#安装-Docker-Engine" class="headerlink" title="安装 Docker Engine"></a>安装 Docker Engine</h2><p>接着直接安装必要的组件。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install docker-ce docker-ce-cli containerd.io</span></span><br></pre></td></tr></table></figure>

<p>安装过程中可能提示接受 GPG key，出于风险考虑先确认提示的指纹是否和下面匹配。</p>
<p><code>060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35</code></p>
<blockquote>
<p>指纹也许会变，到 <a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a> 确认最新信息。</p>
</blockquote>
<blockquote>
<p>安装过程可能会出现下面的失败信息。</p>
</blockquote>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install docker-ce docker-ce-cli containerd.io</span></span><br><span class="line">Docker CE Stable - x86_64                        11 kB/s |  25 kB     00:02</span><br><span class="line"> Last metadata expiration check: 0:00:01 ago on Wed 08 Jul 2020 11:46:44 AM CST.</span><br><span class="line"> Error:</span><br><span class="line"> Problem: package docker-ce-3:19.03.12-3.el7.x86_64 requires containerd.io &gt;= 1.2.2-3, but none of the providers can be installed</span><br><span class="line">  - cannot install the best candidate for the job</span><br><span class="line">  - package containerd.io-1.2.10-3.2.el7.x86_64 is filtered out by modular filtering</span><br><span class="line">  - package containerd.io-1.2.13-3.1.el7.x86_64 is filtered out by modular filtering</span><br><span class="line">  - package containerd.io-1.2.13-3.2.el7.x86_64 is filtered out by modular filtering</span><br><span class="line">  - package containerd.io-1.2.2-3.3.el7.x86_64 is filtered out by modular filtering</span><br><span class="line">  - package containerd.io-1.2.2-3.el7.x86_64 is filtered out by modular filtering</span><br><span class="line">  - package containerd.io-1.2.4-3.1.el7.x86_64 is filtered out by modular filtering</span><br><span class="line">  - package containerd.io-1.2.5-3.1.el7.x86_64 is filtered out by modular filtering</span><br><span class="line">  - package containerd.io-1.2.6-3.3.el7.x86_64 is filtered out by modular filtering</span><br><span class="line">(try to add &#x27;--skip-broken&#x27; to skip uninstallable packages or &#x27;--nobest&#x27; to use not only best candidate packages)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这时可能是 <code>container-tools</code> 依赖了低版本的 <code>containerd.io</code> 导致的，可以通过下面的命令禁用 <code>container-tools</code> 解决。</p>
</blockquote>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum module <span class="built_in">disable</span> container-tools</span></span><br></pre></td></tr></table></figure>

<h2 id="启动-Docker-Engine"><a href="#启动-Docker-Engine" class="headerlink" title="启动 Docker Engine"></a>启动 Docker Engine</h2><p>使用下面命令启动 Docker。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果希望使用其他非 root 用户运行 Docker，将其添加到 <code>docker</code> 用户组。</p>
</blockquote>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo usermod -aG docker richard</span></span><br></pre></td></tr></table></figure>

<h2 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h2><p>CentOS 8 不再对 Docker 进行官方支持，而是扶持了 buildah 和 podman 提供类似的功能。但是显然目前 Docker 的地位依然无法被取代。</p>
<p>Docker 安装完成后还需要对防火墙进行设置，允许容器访问外部网络。</p>
<blockquote>
<p>默认情况下在 CentOS 8 上运行的容器从内部无法访问外部网络，具体表现为 DNS 解析出错 or ‘no route to host’。</p>
</blockquote>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --permanent --zone=trusted --add-interface=docker0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> firewall-cmd --reload</span></span><br></pre></td></tr></table></figure>

<p>设置完成应该即时生效。（建议 reboot）</p>
<h2 id="Optional-安装-docker-compose"><a href="#Optional-安装-docker-compose" class="headerlink" title="(Optional) 安装 docker-compose"></a>(Optional) 安装 docker-compose</h2><p>按需安装。使用下面命令安装 docker-compose。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.26.2/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose -v</span></span><br></pre></td></tr></table></figure>

<p>参考。</p>
<p><a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></p>
<p>结束。</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>homelab</category>
      </categories>
      <tags>
        <tag>Homelab</tag>
      </tags>
  </entry>
  <entry>
    <title>Homelab Step 2 - Enable DDNS</title>
    <url>/post/notes/homelab/Step2-Enable-DDNS/</url>
    <content><![CDATA[<p>国内宽带环境个人用户很难拿到固定公网 IP。不过如果你没有公网 IP，通过联系电信运营商的客服，还是可以拿到公网动态 IP 的。</p>
<blockquote>
<p>具体也要看运营商的情况。</p>
</blockquote>
<p>确保公网 IP 是 DDNS 的前提。使用 DDNS，可以将 IP 动态绑定到对应的域名上，可以保证域名随时都能访问到我们的 Homelab 机器。</p>
<p>所以，你也知道了，要域名的。（散了散了！）</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>保证这些东西都准备好就可以开始进行配置了，让我们的域名随时都处于可访问的状态。</p>
<ul>
<li>准备好域名</li>
<li>确保 WAN 口能拿到公网 IP</li>
<li>设置路由器端口映射暴露 Homelab 必要的端口</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p>待整理。</p>
</blockquote>
<p>DDNS script repo。</p>
<p><a href="https://github.com/zfanli/ddns-aliyun">https://github.com/zfanli/ddns-aliyun</a></p>
<p>crontab</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> crontab -u username /etc/crontab</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> crontab -l -u username</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>notes</category>
        <category>homelab</category>
      </categories>
      <tags>
        <tag>Homelab</tag>
      </tags>
  </entry>
  <entry>
    <title>Homelab Step 3 - Install Nginx</title>
    <url>/post/notes/homelab/Step3-Instrall-Nginx/</url>
    <content><![CDATA[<p>安装 nginx 进行反向代理和端口转发。在进行之前确保 Docker 已经安装。</p>
<span id="more"></span>

<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作</a><ul>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</li>
<li><a href="#for-blogexamplecom-subdomain">For blog.example.com subdomain</a></li>
<li><a href="#for-fakecom-domain">For fake.com domain</a></li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>先找个目录放 nginx 的配置文件。我在用户目录下面准备了一块地方来专门放这些文件。你也可以找个你熟悉的位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p /etc/homelab/nginx</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p /etc/homelab/nginx/conf.d</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /etc/homelab/nginx</span></span><br></pre></td></tr></table></figure>

<p>接着准备一份配置文件模版。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --name tmp-nginx-container -d nginx</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker cp tmp-nginx-container:/etc/nginx/nginx.conf nginx.conf</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker cp tmp-nginx-container:/etc/nginx/conf.d/example.conf conf.d/homelab.conf</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker rm -f tmp-nginx-container</span></span><br></pre></td></tr></table></figure>

<p>来看看这个模版的内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat nginx.conf</span></span><br><span class="line"></span><br><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p>待整理。 TODO</p>
</blockquote>
<p>nginx config</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server;</span><br><span class="line">    root /var/www/example.com;</span><br><span class="line">    index index.html;</span><br><span class="line">    server_name example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="For-blog-example-com-subdomain"><a href="#For-blog-example-com-subdomain" class="headerlink" title="For blog.example.com subdomain"></a>For blog.example.com subdomain</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line">    root /var/www/blog.example.com;</span><br><span class="line">    index index.html;</span><br><span class="line">    server_name blog.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="For-fake-com-domain"><a href="#For-fake-com-domain" class="headerlink" title="For fake.com domain"></a>For fake.com domain</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line">    root /var/www/fake.com;</span><br><span class="line">    index index.html;</span><br><span class="line">    server_name fake.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    ## other configuration as above</span><br><span class="line">    # ...</span><br><span class="line"></span><br><span class="line">    location &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:2368;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header HOST $http_host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 3009 ssl;</span><br><span class="line">    listen [::]:3009 ssl;</span><br><span class="line">    server_name bizcat.xyz;</span><br><span class="line">    location &#123;</span><br><span class="line">        proxy_pass https://10.0.0.11:9090;</span><br><span class="line">        proxy_redirect     off;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header HOST $http_host;</span><br><span class="line">        root html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 3009;</span><br><span class="line">    listen [::]:3009;</span><br><span class="line">    server_name router.bizcat.xyz;</span><br><span class="line">    location &#123;</span><br><span class="line">        proxy_pass http://10.0.0.1;</span><br><span class="line">        proxy_redirect     off;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header HOST $http_host;</span><br><span class="line">        root html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 80:80 -p 443:443 -p 3009:3009 --name tmp-nginx-container -d -v /etc/homelab/nginx/nginx.conf:/etc/nginx/nginx.conf -v /etc/homelab/nginx/conf.d/homelab.conf:/etc/nginx/conf.d/homelab.conf nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run \</span></span><br><span class="line"><span class="bash">    -p 80:80 -p 443:443 -p 3009:3009 \</span></span><br><span class="line"><span class="bash">    --restart=always --name nginx -dit \</span></span><br><span class="line"><span class="bash">    -v /etc/homelab/nginx/nginx.conf:/etc/nginx/nginx.conf \</span></span><br><span class="line"><span class="bash">    -v /etc/homelab/nginx/conf.d/homelab.conf:/etc/nginx/conf.d/homelab.conf \</span></span><br><span class="line"><span class="bash">    -v /etc/letsencrypt/:/etc/letsencrypt/ \</span></span><br><span class="line"><span class="bash">    nginx</span></span><br></pre></td></tr></table></figure>

<p>启动防火墙：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld.service</span><br></pre></td></tr></table></figure>

<p>关闭防火墙：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>

<p>重启防火墙：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure>

<p>开机启用防火墙：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable firewalld.service</span><br></pre></td></tr></table></figure>

<p>开机禁用防火墙：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<p>查看防火墙状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld.service</span><br></pre></td></tr></table></figure>

<p>查看端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>

<p>添加端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=8080/tcp</span><br></pre></td></tr></table></figure>

<p>删除端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --remove-port=8080/tcp</span><br></pre></td></tr></table></figure>

<p>重新加载防火墙规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>Get local ip</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig wlp2s0 | grep inet | grep -v inet6 | awk &#x27;&#123;print $2&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>Set up ssl</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo certbot certonly -d *.bizcat.xyz,bizcat.xyz --manual --preferred-challenges dns --server https://acme-v02.api.letsencrypt.org/directory</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>notes</category>
        <category>homelab</category>
      </categories>
      <tags>
        <tag>Homelab</tag>
      </tags>
  </entry>
  <entry>
    <title>Homelab Step 4 - Change SSH Default Port</title>
    <url>/post/notes/homelab/Step4-Change-SSH-Default-Port/</url>
    <content><![CDATA[<p>Homelab 使用一段时间，有时 ssh 登陆上去会提示这样一段信息。</p>
<blockquote>
<p>There were xxxxx failed login attempts since the last successful login.</p>
</blockquote>
<p>这说明有不明身份的人正在尝试暴力破解我们的 root 用户密码。通常是黑客的 robot 程序在寻找容易入侵的机器。</p>
<p>出于安全考虑，也想避开这些烦人的警告，可以采取一些措施。</p>
<span id="more"></span>

<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%8E%AA%E6%96%BD">基础措施</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9-sshd-%E9%85%8D%E7%BD%AE">修改 sshd 配置</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9-selinux-%E9%85%8D%E7%BD%AE">修改 SELinux 配置</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE-firewalld">配置 Firewalld</a></li>
<li><a href="#%E9%87%8D%E5%90%AF-sshd-%E4%BD%BF%E9%85%8D%E7%BD%AE%E7%94%9F%E6%95%88">重启 sshd 使配置生效</a></li>
</ul>
<h2 id="基础措施"><a href="#基础措施" class="headerlink" title="基础措施"></a>基础措施</h2><ul>
<li>使用 ssh key 认证，避免使用密码认证</li>
</ul>
<p>如果确定从固定的机器访问我们的 Homelab 的话，可以在常用机器上配置 ssh key，关闭密码认证通道。这样可以有效保障服务器安全。</p>
<ul>
<li>使用强密码，修改默认端口</li>
</ul>
<p>不过如果希望从任何机器都能访问，ssh key 显然不够方便。这时可以更换默认的端口，并且避免使用弱密码，应该设置强密码。</p>
<blockquote>
<p>这种方法并没有提高安全性，所以强密码是必须的。修改默认端口号只是降低了被 robot 暴力破解的风险，毕竟大部分暴力破解脚本是针对默认的 22 端口尝试破解的。</p>
</blockquote>
<p>这里我选择第二种方式。</p>
<blockquote>
<p>配置 ssh key 过程比较简单，麻烦之处在于要将 key 复制到各个机器上。出于安全考虑建议此方法。</p>
</blockquote>
<h2 id="修改-sshd-配置"><a href="#修改-sshd-配置" class="headerlink" title="修改 sshd 配置"></a>修改 sshd 配置</h2><p>首先修改 sshd 端口。</p>
<p>Homelab 上编辑配置文件。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi /etc/ssh/sshd_config</span></span><br></pre></td></tr></table></figure>

<p>打开配置文件后，找到这一行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Port 22</span><br></pre></td></tr></table></figure>

<p>取消注释，将端口号改成想要的端口，比如这里将其改为 <code>2222</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Port 2222</span><br></pre></td></tr></table></figure>

<p>退出保存配置。</p>
<h2 id="修改-SELinux-配置"><a href="#修改-SELinux-配置" class="headerlink" title="修改 SELinux 配置"></a>修改 SELinux 配置</h2><p>SELinux 会阻止未经配置的程序绑定对应端口。所以需要配置告诉 SELinux 我们已经修改 ssh 的端口，让其允许 sshd 绑定到对应的端口上。</p>
<blockquote>
<p>是不是很绕？</p>
</blockquote>
<p>来看看 ssh 默认的端口。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> semanage port -l | grep ssh</span></span><br><span class="line">ssh_port_t                     tcp      22</span><br></pre></td></tr></table></figure>

<p>看到是默认 22 端口。将新定义的 2222 端口配置给它。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo semanage port -a -t ssh_port_t -p tcp 2222</span></span><br></pre></td></tr></table></figure>

<p>简单 check 一下。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> semanage port -l | grep ssh</span></span><br><span class="line">ssh_port_t                     tcp      2222, 22</span><br></pre></td></tr></table></figure>

<p>可以看到配置完成了。</p>
<blockquote>
<p>还没完。</p>
</blockquote>
<h2 id="配置-Firewalld"><a href="#配置-Firewalld" class="headerlink" title="配置 Firewalld"></a>配置 Firewalld</h2><p>修改完 ssh 默认端口，配置完 SELinux 允许其绑定端口。最后，还要允许这个端口通过防火墙，这样才能正常从外部进行访问。</p>
<p>直接添加端口允许流量通过。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo firewall-cmd --add-port=2222/tcp --permanent</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo firewall-cmd --reload</span></span><br></pre></td></tr></table></figure>

<h2 id="重启-sshd-使配置生效"><a href="#重启-sshd-使配置生效" class="headerlink" title="重启 sshd 使配置生效"></a>重启 sshd 使配置生效</h2><p>最后重启 sshd 即可生效。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl restart sshd</span></span><br></pre></td></tr></table></figure>

<p>这时从外部使用 2222 端口已经可以访问到 Homelab。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -p 2222 root@homelab</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>路由器可能需要相关配置，将 2222 端口流量转发到 Homelab 上。</p>
</blockquote>
<p>Finished。</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>homelab</category>
      </categories>
      <tags>
        <tag>Homelab</tag>
      </tags>
  </entry>
  <entry>
    <title>[Dictation] How to stop being unconfident?</title>
    <url>/post/notes/just%20notes/-Dictation-How-to-stop-being-unconfident/</url>
    <content><![CDATA[<blockquote>
<p>💡 英语听读练习<a href="https://www.youtube.com/watch?v=oynKj-1m6Hg">《如何停止不自信？ - by Better Ideas》</a>。</p>
</blockquote>
<blockquote>
<p>推书《The Comfort Crisis》by Michael Easter。If you ever feel like you’re super lazy, and you’re just like complacent in life, you’re too comfortable, you’re stuck in a rut, read this book. It’ll kick you out of that rut.</p>
</blockquote>
<p>It’s no secret that we spend a lot of time and effort trying to appear confident on the surface when we’re around other people. Because we kind of have no choice. People are extremely judgemental whether they’re aware of it or not. Sizing people up is an evolutionary mechanism.</p>
<p>当我们与其他人相处时会花大量时间和努力来试图让我们表现的自信。因为我们似乎别无选择。不管人们是否意识到，他们都是非常擅长评头论足。对他人进行估量是一个进化机制。</p>
<p>When we appear confident and self-assured, people subconsciously place us higher on their social hierarchy. This is why it matters how you dress, the strength behind your voice, and your posture when you enter a room. All of these things contribute tremendously to how people end up treating you. But the weird thing is so many of us feel a huge disconnect between the person that we’re trying to appear in the world as and who we actually are as a person. Because no matter how meticulously we groom ourselves, or how obsessively we keep up with the latest trends, or how quip-y and clever our manner of speech is, the whole thing ends up feeling like a giant facade. Like we’re just putting this show on, we’re not actually confident, we’re slapping makeup on a pig.</p>
<p>当我们表现出自发的自信时，人们会在潜意识中将我们放在更高的社交阶层上。这就是为何你的着装、你的声音都力量和你进入一个房间的姿态的重要所在。所有这些事情都极大地影响了人们如何对待你的方式。但奇怪的是，我们中的大部分人都觉得，我们想要表现出来的人格和我们实际的人格之间存在巨大的脱节。因为无论我们如何精心包装自己，无论我们如何痴迷于紧跟最新的潮流，无论我们的谈吐多么风趣聪明，最终这一切都像是一个巨大的假象。就好像我们一直在演戏，实际上没有自信，也只能打肿脸充胖子。</p>
<span id="more"></span>

<blockquote>
<p>📒 <strong>tremendously</strong>: B2, to a very great amount or level, or extremely well; extremely, very much; 非常地，可怕地，惊人地。</p>
<p>📒 <strong>meticulously</strong>: if you describe someone as meticulous, you mean that they do things carefully and with a great attention to detail; in a way that shows great care and attention to detail; 细致地，一丝不苟地。</p>
<p>📒 <strong>groom</strong>: to prepare someone for a special job or activity; 使准备。</p>
<p>📒 <strong>facade</strong>: a facade is an outward appearance which is deliberately false and gives you a wrong impression about someone or something; 假象。</p>
</blockquote>
<p>And this is the problem because the more you strain to act like a confident person in the real world, people don’t really buy it, they can tell that it’s forced. Fake smiles are really easy to spot. I think the reason why so many of us don’t feel confident and rock solid is because we’re forgetting a concept that is fundamental the way our psychology works, and that is that while we all indeed very efficient at judging other people and sizing them up, our brain uses the exact same mechanism to judge ourselves.</p>
<p>这是问题所在，当你越努力让自己在现实世界表现的像一个自信的人，人们就越不买账，他们能发现你是装的。假笑是非常容易被看穿的。我觉得我们中大部分人感到不自信或不踏实，是因为我们忘记了一个概念，这个概念就是我们心理学运作的基础，就是我们所有人确实都非常擅长于指责和评估他人，所以我们的大脑也会用相同的机制来指责我们自己。</p>
<p>We are a fly on a wall of our own lives, constantly judging the things we say, the thoughts we entertain, and the habits we indulge in, and this constant observation happen without our conscious knowledge, because it’s the subconscious knowledge. And the subconscious of ours is always watching us, taking notes, comparing our lifestyle to our value system, and the longer time goes on, the more evidences our subconscious gathers to form a opinion about ourselves, just like it would with other people. So the more and more time we live in contradiction to our value system, the lower our opinion will be of ourselves. So if we happen to have a very low opinion of ourselves, we have very low self-esteem, low self-confidence, low self-efficacy. Then there’s a very good chance that your subconscious has observed you live your life in a way that is contradictory to your fundamental value system.</p>
<p>我们就像是自己生活的观察者，持续的评判我们说出口的话、评判我们的想法、评判我们的习惯，这种持续的观察不被我们的意识所知晓，因为其发生在潜意识之中。我们的潜意识一直在看着我们，记着笔记，将我们的生活方式和我们的价值观做对比，这个过程越久，我们的潜意识就会收集到越多的证据来形成一个关于我们自己的评价，就像我们对其他人的评价一样。所以我们在一个与我们价值观系统相矛盾的状态下越久，我们的自我评价就会越低。一旦我们的自我评价变得很差，我们的自尊会变低，我们的自信会变差，我们的自我效能会缺失。然后，你的潜意识就有了一个好机会观察到你的生活状态和你的价值观系统存在冲突。</p>
<blockquote>
<p>📒 <strong>a fly on the wall</strong>: if you say that you would like to be a fly on a wall in a situation that does not involve you, you mean that you would like to see or hear what happens in that situation; an unnoticed observer of a particular situation; 墙上的一只苍蝇，隐喻隐蔽的观察者。</p>
<p>📒 <strong>indulge</strong>: if you indulge in something or if you indulge yourself, you allow yourself to have or do something that you know you will enjoy; 沉溺，使沉溺.</p>
</blockquote>
<p>And this is kind of what affirmation culture gets wrong, you know, it sounds all well and good, and helpful to look yourself in the mirror, and say you are powerful, and you are strong, you are good looking, you attract wealth, you attract women, you attract men, you attract everyone.</p>
<p>这也是肯定文化出问题的地方，它听上去非常美好，帮助你看着镜子中的自己说，你很强大，你很强壮，你很好看，你吸引财富，你吸引女人，你吸引男人，你吸引所有人。</p>
<p>But the truth is your subconscious is harder to fool. If you look yourself in the mirror, and say one thing, and behave the opposite way, your subconscious isn’t fooled. It watched you do that, it’ll say, wow, this guy never does what he says he’s gonna do, I’m gonna use this information to develop self-doubt complex, that will leak in every area of his life, and his interactions with others, especially women. And that’s the insidious thing about our subconscious.</p>
<p>但是真相是，你的潜意识很难被愚弄。如果你看着镜子中的自己说一件事，实际上却做另一件事，你的潜意识不会被愚弄。它会看着你的行为，然后说，哇这个人真是从来不会做他声明要做的，我要用这个信息来造成自我怀疑的情结，让自我怀疑渗入他生活的方方面面，渗入到他和其他人的互动里面，特别是和女人的。这就是潜意识的阴险狡诈之处。</p>
<blockquote>
<p>📒 <strong>insidious</strong>: something that is insidious is unpleasant or dangerous and develops gradually without being noticed; 潜伏，狡猾，阴险。</p>
</blockquote>
<p>It influences our mood, our mindset, and our overall mental state far more than we probably realize. And that because our subconscious accounts for over 90% of our overall mental function. So how we conduct ourselves in its presence is everything.</p>
<p>潜意识对我们的情绪，我们的思想以及我们的整体的精神状态的影响远比我们意识到的要大。这是因为我们的潜意识占据了我们整个大脑功能的 90% 以上。所以我们在潜意识前面如何表现自己才是最重要的。</p>
<blockquote>
<p>📒 <strong>account for</strong>: if a particular thing accounts for a part or proportion of something, that part or proportion consists of that thing, or is used or produced by it; 占据。</p>
</blockquote>
<p>So needless to say, the key to confidence in life, the key to feeling self-assured is not to double down and care more about other people think of you, is to take more seriously this relationship that you have with your own subconscious, and to realize that you can form a partnership and a friendship with your subconscious.</p>
<p>无须多言，在生活中自发自信的关键在于不要去过分的关注其他人如何看你，而是更加严肃的的对待你与潜意识之间的关系，意识到你可以与潜意识形成一个伙伴关系或友谊。</p>
<p>And I know that sounds super woo-woo, and spiritual and you like what the fuck this guy talking about, but if you like this idea of forming a better relationship with your own subconscious, then the great way to do that is to develop that relationship like you would any other relationship: by spending time to get to know the other person, you need to spend time to get to know yourself, to uncover what your fundamental value system is, so that you can better live in accordance to that, so take some time to ask yourself some key questions, you know, take out a pen and paper, and ask yourself,</p>
<ul>
<li>“What kind of person do I want to be in this world?”</li>
<li>“How can I live my life in a way that I would be proud of?”</li>
<li>“What kind of habits does my ideal self have?”</li>
<li>“And if I was my ideal self, how would I interact with the people around me?”</li>
<li>“How would I spend my time when nobody is around?”</li>
<li>“Does my ideal self make mistakes sometimes?”</li>
<li>“If so…how would my ideal self respond to the mistakes I made?”</li>
<li>“Would I learn from them and encourage myself to do better?”</li>
</ul>
<p>我知道这听上去不太科学，有点神经质，你或许在想这家伙在说什么鬼，但如果你喜欢与自己的潜意识形成良好关系的想法，最好的方法就是和你想跟其他人发展这种关系一样：你和对方一起度过更多的时间来让你们相互了解，你也需要花更多的时间来了解你自己，来揭露你的基本价值观是怎样的，这样你就可以更加与其一致了，花点时间来问问你自己一些关键的问题，拿出纸和笔，开始问你自己：</p>
<ul>
<li>“我想在这个世界上成为怎么样的一个人？”</li>
<li>“我如何才能活的自豪？”</li>
<li>“我的理想状态下应该有怎么样的习惯？”</li>
<li>“如果我现在就是理想的状态，我该如何与我身边的人互动？”</li>
<li>“我身边没有其他人时该怎么样度过？”</li>
<li>“我的理想状态下也会偶尔犯错吗？”</li>
<li>“如果是的，我的理想状态会如何面对我犯的错误？”</li>
<li>“我会从中学到什么，鼓励自己做的更好吗？”</li>
</ul>
<p>Your answers to these types of questions will help you uncover truths that you hold about yourself, and the standards that you’re trying to uphold yourself to. Because wether you’re aware of these ideals consciously or not, they’re there in your subconscious, and your subconscious is constantly comparing your behavior to these ideals. So it’s super important to take some time, to try to figure out what constitutes a good and honorable person according to you.</p>
<p>你对这些问题的回答可以帮助你揭露你对自己的真实期望，你希望认可自己的标准。因为无论你是否意识到，这些理想在你的潜意识中持续的对比你的行为是否符合他们。所以花点时间，来弄清楚在你看来，什么样的人是好人，是光荣的人是非常重要的。</p>
<p>And chances are there’s a lot truth to these underlying beliefs, and sometimes these beliefs are a litter skewed and they need correcting, and you need to form healthier values and healthier expectations of yourself.</p>
<p>然后机会来了，你会发现大量的潜在的信念，有时这些信念是有些扭曲的，你需要矫正它们，来形成一个对自己的健康的价值观和健康的期待。</p>
<p>So a great way to do this, is to go through the whole process of writing this stuff down, and diving deep by yourself, and then taking that information to a friend or a 3rd party preferably a therapist or a mental health professional and try to figure out wether or not this value system is actually useful for you. You know, are you holding yourself to unrealistic expectations? or are these healthy and good ideals to have? Because either way, there is no getting around the fact that if you want to develop a better opinion about yourself, your behaviors and your values need to match, and in order for that to happen, either your behaviors need to change, or your values need to change.</p>
<p>最好的方法就是通过写下这些问题并且深入的与自己探讨，然后拿着这些信息给一个朋友，或者第三方，最好是一个治疗师或者心理健康专家，来尝试弄清楚这个价值观系统是否对你有用。你是否对自己有不现实的期待？或者你的理想是否是健康的、是否是好的？因为无论怎样，如果你想对自己有一个好评价，你就无法绕开这些，你的行为和价值观需要匹配，为此要不你需要改变你的行为，要不就改变你的价值观。</p>
<p>As you go through this process, you’re probably realize that you’re on your own side more than you probably realize. And when you conscious mind and your subconscious mind is on the same page, you’ll find that there’s certain uniformity to a character. You don’t say one thing and do another, you don’t act one way in public and then act another way in private. You’ll be a more consistent human being, with a more authentic identity you’ll feel like yourself. You’ll feel like you’re more you, and that’s a really intangible thing to try to relay to you, but it is a very real feeling, and that feeling is what confidence feels like. It’s to be unapologetically you in the presence of others, while you’re alone, it just doesn’t really matter, you’re you no matter the circumstances.</p>
<p>在你完成的过程中，你会意识到你远比想象的更加偏袒自己。当你的表意识和潜意识达成共识，你会发现你的人格统一了。你不再心口不一，你不再表面一套背后一套。你会成为一个稳定的人，拥有一个更加真实的身份，你会变的更像自己。你会感觉自己在做自己，这是一种是土传递给你的无限之物，但是一种非常真实的感受，这就是自信的感受。在别人的面前正大光明的做你自己，就算你孤身一人，你就是你，无论环境如何。</p>
<blockquote>
<p>📒 <strong>unapologetically</strong>: without being sorry about having caused someone problems or unhappiness, even though people might expect you to be sorry; 正大光明的，无辩解的，无歉意的。</p>
</blockquote>
<p>And I really hope that this video gives you some ideas as to how you can get there in your life.</p>
<p>希望这个视频能带给你一些想法让你在生活中停止不自信。</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>just notes</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Python 实现一个简单的 RESTful API 服务器</title>
    <url>/post/notes/just%20notes/Create-a-RESTful-Server-with-Python/</url>
    <content><![CDATA[<p>REST 是表现层状态转移的缩写，虽然名称不好理解，但这是一个简单并且实用的概念。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REST : REpresentational State Transfer</span><br></pre></td></tr></table></figure>

<p>RESTful API 关注下面三点：</p>
<ol>
<li>URL 定义资源位置</li>
<li>HTML 动词定义对资源的操作</li>
<li>返回状态码定义操作的结果</li>
</ol>
<span id="more"></span>

<p>REST 的概念翻译成通俗易懂的人类语言大概是这样的：</p>
<ul>
<li>第一步，告诉你我要的资源（URL），</li>
<li>第二步，告诉你我要对这个资源做什么（GET、POST、UPDATE、DELETE），</li>
<li>最后，你告诉我结果（状态码和响应内容）。</li>
</ul>
<p>是不是感觉对要做的事情描述得很清晰？这就是 REST 要达到的效果。接下来我们来实现一个 RESTful API 的服务器，我给它命名为 <code>MaruCat</code>，这是我家猫的名字。</p>
<p>这个服务器将基于 Python 的 <code>Flask</code> 框架来实现，我们将一步一步详细的记录每一个步骤，同时记录遇到的所有问题和这些问题的解决方法。让我们开始吧。</p>
<h2 id="Hello"><a href="#Hello" class="headerlink" title="Hello?"></a>Hello?</h2><p>我们先尝试一下 Flask 框架的威力。</p>
<p>我们先创建如下的目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line">├── marucat_app</span><br><span class="line">│   └── __init__.py</span><br><span class="line">└── run.py</span><br></pre></td></tr></table></figure>

<p>可以看到项目中有一个 <code>marucat_app</code> 包，主要的代码都放在这里。这个包之外还有一个 <code>run.py</code> 文件，我们将其定义其为程序的入口，启动的位置。并且为了方便调试，<code>run.py</code> 文件将以 DEBUG 模式启动开发服务器。</p>
<p>这是这个文件的所有内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> marucat_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line">app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>我们从 <code>marucat_app</code> 包导入 app 实例（这个实例将在稍后说明），以 DEBUG 模式运行它。</p>
<p>先不急着运行，为了尝试 Flask 的威力，我们先准备一个 Hello 场景。</p>
<p>假设一个场景，我们要实现这个需求：</p>
<p><strong>访问（GET）根目录（’/‘）时，得到一个问候信息，这个信息需要是 JSON 格式的，并且指定返回类型为 JSON。</strong></p>
<p>这其实是一个最简单的 REST API，我们可以想象 request 头第一行会是这样的：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure>

<p>解释一下：我们将对位于 <code>/</code> 的资源进行 HTML 动词的 <code>GET</code> 操作，即我们想获得根目录所代表的资源。</p>
<p>所以在服务器这边，我们其实要做这些事：</p>
<ul>
<li>给根路径（’/‘）绑定一个路由</li>
<li>这个路由需要返回一个 JSON 对象</li>
<li>并且 Response 对象需要声明自己是 JSON 类型的（即 <code>Content-Type</code> 声明）</li>
</ul>
<blockquote>
<p>Response 对象声明 <code>Content-Type</code> 是为了向请求资源的人描述 Response Body 的格式。</p>
</blockquote>
<p>在 Flask 中要做这些事情是很简单的。回到我们的文件结构，在 <code>marucat_app</code> 包中有一个 <code>__init__.py</code> 文件，我们就把这个 Hello 场景放在这里吧。</p>
<p>使用 Flask 框架，首先需要一个实例化的 Flask 对象，其后的所有操作都将通过这个对象来进行。我们要对这个对象绑定路由，来决定什么情况下返回什么，而除此之外的细节都由框架帮我们处理了。</p>
<p>这是一个最简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(<span class="string">&#x27;marucat_app&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;Hello&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们从 flask 包中导入 <code>Flask</code> 类和 <code>jsonify</code> 函数。先创建一个 Flask 对象，因为之后的操作都将围绕这个对象进行。实例化 Flask 对象时需要提供一个参数作为识别符，通常情况下我们把 <code>__name__</code> 作为识别符。</p>
<p>不过，官方文档提示第一个参数的设置分两种情况：</p>
<blockquote>
<p>1）使用单独 module 时通常将 <code>__name__</code> 作为第一个参数；2）使用 package 时通常将 package 名硬编码作为第一个参数。究其原因，一部分 Flask 扩展将根据这个识别符来追踪 DEBUG 信息，设置不当的话会造成丢失 DEBUG 信息。</p>
</blockquote>
<p>我们的文件结构 app 存在于 <code>marucat_app</code> 包里，我们直接将 ‘marucat_app’ 作为第一个参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app = Flask(<span class="string">&#x27;marucat_app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>接下来创建一个 <code>Hello</code> 函数，直接返回问候信息。问候信息是一个字典对象，使用 <code>jsonify</code> 函数将其转成 JSON 字符串再返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;Hello&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>最后，将 <code>Hello</code> 函数绑定在根路径（’/‘）上，Flask 让我们可以使用装饰器的方式简单的绑定路由。在 <code>Hello</code> 函数上插入装饰器 <code>@app.route(&#39;/&#39;)</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;Hello&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>现在，这个简单的例子已经可以运行了，来试试看！</p>
<p>我们可以在 IDE 中配置执行脚本，直接执行 <code>run.py</code> 就可以把这个 app 跑起来。或者使用命令行，输入下面的命令，效果是一样的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python run.py</span></span><br></pre></td></tr></table></figure>

<p>键入上面的命令后，我们会看到类似下面的输出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br><span class="line">* Restarting with stat</span><br><span class="line">* Debugger is active!</span><br><span class="line">* Debugger PIN: 274-620-182</span><br></pre></td></tr></table></figure>

<p>现在 app 已经在 DEBUG 模式下运行了，可以通过 <code>http://127.0.0.1:5000/</code> 访问，我们来试试看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:5000/</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;message&quot;: &quot;Hello&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们打开一个新的命令行界面，使用 curl 访问服务器跟路径，接着我们就得到了预设的问候信息。同时在运行服务器的命令行界面上我们看到如下反馈。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1 - - [31/May/2018 16:12:03] &quot;GET / HTTP/1.1&quot; 200 -</span><br></pre></td></tr></table></figure>

<p>同样我们也可以直接打开浏览器访问。在浏览器中访问根路径，JSON 格式的问候信息将直接显示在页面上。</p>
<p>我们在浏览器中打开开发者工具，切换到 Network 标签（Chrome 浏览器下），在这里可以看到我们访问根路径时得到的 Response 信息（如果你没看到，那就在打开开发者工具的情况下再访问一次根路径）。</p>
<p>这是我得到的一个 Response 头信息。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>20</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Werkzeug/0.14.1 Python/3.6.4</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Thu, 31 May 2018 08:24:04 GMT</span><br></pre></td></tr></table></figure>

<p>可以看到我们简单的达到了目标。需要注意的是 <code>jsonify</code> 自动帮我们把 <code>Content-Type</code> 设定成了 JSON。</p>
<p>我们也可以手动做这一步，下面是一个例子，在没有使用 flask 的 <code>jsonify</code> 函数的情况下我们怎么设置 response 的头信息。</p>
<p>在这里我设置了 <code>Content-Type</code>，这只是一个例子，用这个方法我们可以设置任何想要的头信息。Flask 为我们提供了一个定制 Response 对象的方法，<code>make_response</code>。</p>
<p>先看看修改后的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response</span><br><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> dumps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CONTENT_TYPE = <span class="string">&#x27;Content-Type&#x27;</span></span><br><span class="line">JSON_TYPE = <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(<span class="string">&#x27;marucat_app&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    resp = make_response(dumps(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;Hello&#x27;</span>&#125;), <span class="number">201</span>)</span><br><span class="line">    resp.headers[CONTENT_TYPE] = JSON_TYPE</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与之前不同，这次我们返回一个定制过的 response 对象。从 flask 包中导入 <code>make_response</code> 函数，这个函数可以生成一个 response 对象。它接受几个参数，一般我们传递两个参数给它，第一个是 response 的数据，第二个是返回状态码。</p>
<p>之前我们并没有显式的设置过状态码，因为默认将发送 <code>200</code> 状态码。这次我们将状态码设置成 <code>201</code>，等会看看效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp = make_response(dumps(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;Hello&#x27;</span>&#125;), <span class="number">201</span>)</span><br></pre></td></tr></table></figure>

<p>我们拿到 <code>resp</code> 这个对象后，就可以给它设置 header 了。</p>
<p>为了方便使用，我们先将 <code>Content-Type</code> 设置为常量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CONTENT_TYPE = <span class="string">&#x27;Content-Type&#x27;</span></span><br><span class="line">JSON_TYPE = <span class="string">&#x27;application/json&#x27;</span></span><br></pre></td></tr></table></figure>

<p>接着，给 <code>resp</code> 设置 header。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp.headers[CONTENT_TYPE] = JSON_TYPE</span><br></pre></td></tr></table></figure>

<p>到此基本搞定，我们再来跑跑看。重新打开服务器，如果你没有关闭的话，等服务器 reload 完成。在浏览器中打开开发者工具，访问 app 的地址根路径。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Hello&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>页面上显示了我们设定的结果，再看看 Response 头信息。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">201</span> CREATED</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>20</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Werkzeug/0.14.1 Python/3.6.4</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Thu, 31 May 2018 09:02:34 GMT</span><br></pre></td></tr></table></figure>

<p>注意我们通过自定义 response 的头信息实现了下面两点：</p>
<ol>
<li>状态码返回了 201</li>
<li><code>Content-Type</code> 声明了 JSON 类型</li>
</ol>
<p>我们完成了 Hello 的需求。虽然上面碎碎念了这么多，但其实我们仅使用了 10 行代码就完成了一个 app 的构建。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>到目前为止，我们先做一个小结。</p>
<p>我们实现了一个 Hello 场景，创建了一个最简单的问候语 API。依此来了解了 Flask 框架的基本用法，以及 REST API 的概念。</p>
<p>这些内容可以总结如下：</p>
<ul>
<li>Flask 框架的使用从实例化 <code>Flask</code> 对象开始</li>
<li>使用装饰器 <code>@app.route(path)</code> 来绑定路由</li>
<li>路由可以是一个函数，返回一个字符串或者 response 对象</li>
<li>如果路由函数返回一个字符串，response 头信息的 <code>Content-Type</code> 默认为 <code>text/html</code></li>
<li>如果不设定返回的状态码，路由函数默认返回 <code>200</code> 状态码</li>
<li>Flask 提供 <code>make_response</code> 函数来定制 response 对象</li>
<li>response 对象定制可以设定响应内容、状态码和响应头信息</li>
</ul>
<h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><p>插播几个番外。</p>
<h3 id="设计模式问题"><a href="#设计模式问题" class="headerlink" title="设计模式问题"></a>设计模式问题</h3><p>数据库目前选择的是 MongoDB，但是也要确保以后更换数据库的情况不产生影响，所以数据库相关的部分单独提出来，放在一个子 package 里。对外部来说仅导入这个包，使用里面的 <code>factory</code> 方法获得需要的数据库访问 <code>Helper</code> 就足够了。</p>
<p>假定 <code>Helper</code> 一定会返回正确的数据，外部不需要关注 <code>Helper</code> 的实现。这样就能不产生负面影响的情况下更换数据库。这个模式有很多种实现，在 Java 中这叫面向接口编程。</p>
<p>大致概念如下：</p>
<ul>
<li>定义接口</li>
<li>外部和内部并行开发</li>
<li>外部只需调用接口不关注具体实例对象</li>
<li>内部只需实现接口不限制技术细节</li>
</ul>
<p>不过在 Python 中没有类似的设计模式。</p>
<p>我在一番搜索之下找到一个很棒的库，介绍 Python 的各种设计模式。</p>
<p><a href="https://github.com/faif/python-patterns">https://github.com/faif/python-patterns</a></p>
<p>在其中我找到了一个合适的设计模式，<code>Bridge Pattern</code>。</p>
<p>概念总结一下，对外和对内的处理基本稍有些差异。大致如下：</p>
<ul>
<li>用一个类 A 作为桥梁</li>
<li>实例化 A 时将具体的实现类对象 B 作为参数传进去</li>
<li>A 的内部定义类所有接口方法，在这些方法中调用 B 相对应的方法并返回结果</li>
<li>指定一个实现类对象 B 来实例化一个 A 的对象，这个 A 的对象作为 Helper 暴露出去</li>
<li>A 不关注 B 的细节，只要 B 拥有 A 所定义的所有对应的方法</li>
</ul>
<p>没有大差，但是 Python 下稍有点麻烦。不过路算是疏通路。</p>
<h3 id="logging-问题"><a href="#logging-问题" class="headerlink" title="logging 问题"></a>logging 问题</h3><p>路由的绑定根据路径分成几个文件定义。在分割文件的过程中，每个文件都需要实例化一个 <code>blueprint</code> 对象，由此来完成路由绑定操作。</p>
<p>这些 <code>blueprint</code> 对象最终会注册在应用实例化的 Flask 对象上。由此就有一个问题，logger 对象只能从 Flask 的实例对象上访问。</p>
<p>这玩意传递都不好搞，flask 有一个 <code>current_app</code> 功能对象可以获得当前的实例化 app 对象。但是 <code>current_app</code> 使用的前提是 Flask 实例化的 app 对象调用了 <code>app_context</code> 方法创建了上下文，并且把 logger 传到上下文里去。</p>
<p>目前的几次尝试都没有成功，对 flask 的 logging 理解还不深入。但是失败几次转换思路后，我开始重新思考需求。</p>
<ul>
<li><code>blueprint</code> 中记录跟踪信息和错误信息，并且为了保持 log 的连贯性，要将其和 flask 内部 logger 输出到同一个地方。</li>
</ul>
<p>一开始的思路是拿同一个 logger 输出就能把 log 打到同一个地方。仔细想想，并非如此，flask 内部 logger 默认情况下会把所有 log 输出到 console。所以我的目的应该是将 <code>blueprint</code> 的 log 信息同样输出到 console 就可以了。</p>
<p>结论：普通的 logger 就足够了。</p>
<p>所以最后还是直接从 logging 包拿到一个 logger 直接输出 log 信息了。</p>
<p>中途疏通花了挺长时间，或许再坚持一下一开始的思路说不定也是可以走通的，但是方向却是一开始就走偏了。不过这个过程也更深入的了解到了 flask 的 logging 机制，其实默认的 logger 就是普通的 logging 包拿到的 logger 对象。</p>
<p>我们在实例化之前对 logging 包设定 <code>baseConfig</code> 或者 <code>dictConfig</code>，这也会对 log 产生影响。到此这条路也是被疏通了。</p>
<h3 id="处理异常-Code"><a href="#处理异常-Code" class="headerlink" title="处理异常 Code"></a>处理异常 Code</h3><p>客户端请求的一个路径可能不存在，或者请求一个路径使用的 method 可能是不被允许的。总有各种各种错误会在服务的中间出现，我们要处理这些错误。</p>
<p>flask 使用 Werkzeug 发布应用，这个库默认帮我们处理了这些错误。但是如果你尝试一下就会发现，当错误发生时 response 会得到一个描述错误信息的页面。</p>
<p>通常这没什么问题，用户看到这些信息后就知道发生什么了。但是 MaruCat 只是一个 REST API 提供者，用户不是人类而是消费这些 API 的前端服务器。仅需要一个 code 就足以让服务器明白发生了什么，我们需要自定义这些错误处理。而在 flask 中做到这一切非常容易。</p>
<p>下面是一个处理 404 的例子，我们仅需要返回一个 code 就足够了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.exceptions <span class="keyword">import</span> NotFound</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(<span class="params">NotFound</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_found</span>(<span class="params">error</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>, <span class="number">404</span></span><br></pre></td></tr></table></figure>

<p>也没什么好解释的，注意这个方法需要接受一个 <code>exception</code> 的参数，如果不接受参数在运行时会抛错误的。这个 <code>exception</code> 有几个可访问的属性，在特定时候需要用到。以上面函数接受的参数名 <code>error</code> 为例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误状态码 e.g. 400</span></span><br><span class="line">error.code</span><br><span class="line"><span class="comment"># 错误名 e.g. NOT FOUND</span></span><br><span class="line">error.name</span><br><span class="line"><span class="comment"># 错误信息</span></span><br><span class="line">error.description</span><br></pre></td></tr></table></figure>

<p>处理其他 code 的套路是一样的。这条路被疏通了。</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>just notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>REST</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 Python 的初体验感受</title>
    <url>/post/notes/just%20notes/First-time-using-Python/</url>
    <content><![CDATA[<blockquote>
<p>人生苦短，我用 Python。</p>
</blockquote>
<p>搜集资料的时候，经常会在各个地方看到上面这句打趣的话，可见有一大批 Python 的拥趸是因为其非常完善的可用库而吹爆 Python 的。</p>
<p>这是让我对 Python 产生了兴趣的原因之一，当然还有其他原因，无非就是这个排行那个排行 Python 又上榜啦、这个网站那个网站又在刊登 Python 培训的广告啦，等等之类的。</p>
<p>这次对爬虫 🕷️ 有了需求，也是让我有了动机耐下心来研究了一番 Python，好好体会了一把 Python 语法的高明之处，和万能的可用库的方便之处。总体的印象是，果然盛名之下无虚士，除去性能这个高级语言很难避免的点不谈，剩下的就是——“Python 牛 X！”</p>
<span id="more"></span>

<p>由于个人经历，之前接触过静态语言 Java 和动态语言 JavaScript，在此基础上，Python 中用到的很多概念已经算是驾轻就熟，相互印证。</p>
<p>但在那些老生常谈的特性之外，Python 还有很多让人惊叹的特性。就比如方便实用为王道的列表生成式，这是我在以往接触过的语言中不曾有的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成 [1x1, 2x2, 3x3...10x10] 的 list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) ]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p>以同为动态语言的 JS 为例，要实现同样的效果可能会写成这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>).fill(<span class="number">1</span>).map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> (i + <span class="number">1</span>) ** <span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p>从可读性上来看我认为还是 Python 看起来更舒服。</p>
<p>另一个例子 🌰 是懒惰的生成器（generator）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>li = [<span class="string">&#x27; Abc&#x27;</span>, <span class="string">&#x27;blue &#x27;</span>, <span class="string">&#x27; red &#x27;</span>]</span><br><span class="line"><span class="comment"># 生成器，去除 li 中各项的首尾空格</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = (x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> li)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x0000028AAD415BA0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(gen)  <span class="comment"># 生成下一个元素</span></span><br><span class="line"><span class="string">&#x27;Abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(gen)  <span class="comment"># 生成下一个元素</span></span><br><span class="line"><span class="string">&#x27;blue&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(gen)  <span class="comment"># 生成下一个元素</span></span><br><span class="line"><span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(gen)  <span class="comment"># 结束</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;...interactiveshell.py&quot;</span>, line <span class="number">2862</span>, <span class="keyword">in</span> run_code</span><br><span class="line">    <span class="built_in">exec</span>(code_obj, self.user_global_ns, self.user_ns)</span><br><span class="line">  File <span class="string">&quot;&lt;ipython-input-360-8a6233884a6c&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">next</span>(gen)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>JS 甚至借鉴了 Python 的生成器的概念，在 ES6 中实现了 JS 版的生成器，上面这个逻辑在 JS 中实现如下，虽然在 JS 中没有列表生成器这种快速便捷的写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> li = [<span class="string">&#x27; Abc&#x27;</span>, <span class="string">&#x27;blue &#x27;</span>, <span class="string">&#x27; red &#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">of</span> li) &#123;</span><br><span class="line">        <span class="keyword">yield</span> i.trim()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">const</span> g = gen()</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt;&gt;&gt; g.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="string">&quot;Abc&quot;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">&gt;&gt;&gt; g.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="string">&quot;blue&quot;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">&gt;&gt;&gt; g.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">&gt;&gt;&gt; g.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Python 中一个稍微复杂一些的生成器写法如下，这是一个斐波那契数列的生成器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span>  <span class="comment"># 创建一个斐波那契数列的生成器</span></span><br><span class="line"><span class="meta">... </span>    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> b  <span class="comment"># yield 关键字创建生成器</span></span><br><span class="line"><span class="meta">... </span>        a, b = b, a + b</span><br><span class="line"><span class="meta">... </span>        n = n + <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = fib(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;generator <span class="built_in">object</span> fib at <span class="number">0x0000028AAD415410</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> <span class="keyword">for</span> i <span class="keyword">in</span> f:  <span class="comment"># 对生成器直接使用 for 迭代</span></span><br><span class="line"><span class="meta">... </span>     <span class="built_in">print</span>(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>此外还有装饰器（decorator），协程（coroutine）等非常优秀的语言特性，已经被一些语言借（chao）鉴（xi）。</p>
<p>除了语言特性本身之外，Python 的真正强大之处在于功能强大的各种第三方类库。例如要生成下面这个可交互的 SVG 图表的话，使用第三方库 <code>pygal</code> 仅需要几行代码就可实现。</p>
<embed src="/img/python-svg/dot_chart.svg" type="image/svg+xml" />

<p>代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_data</span>(<span class="params">s=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Random data generator.&quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s):</span><br><span class="line">        result.append(randint(<span class="number">10</span>, <span class="number">200</span>))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dot_chart</span>():</span></span><br><span class="line">    dot = pygal.Dot(x_label_rotation=<span class="number">30</span>)</span><br><span class="line">    dot.title = <span class="string">&#x27;DOT CHART TEST&#x27;</span></span><br><span class="line">    dot.x_labels = [<span class="string">&#x27;DOT TARGET &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        dot.add(<span class="string">&#x27;Item &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i), get_random_data(size))</span><br><span class="line">    dot.add(<span class="string">&#x27;Neg exists&#x27;</span>, [x - <span class="number">100</span> <span class="keyword">for</span> x <span class="keyword">in</span> get_random_data()])</span><br><span class="line">    dot.render_to_file(<span class="string">&#x27;DOT_CHART_TEST.svg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dot_chart()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除去假数据的生成之外，真正生成图表的代码只有从 14 行到 20 行几句。</p>
<p>这些就完全不能用 JS 来改写了吧？因为据我所知，啊不对我还没接触过类似的 JS 库，emmm，不行我得去搜索一番…（搜索 ing）…啊，有了，下面这个库可以生成差不多的图表 📈，风格有些不一样，用法差不多简洁…好像，貌似，Python 也不能算唯一的选择吧 XD。</p>
<p><a href="https://github.com/gionkunz/chartist-js">https://github.com/gionkunz/chartist-js</a></p>
<p>上面只是一个例子 🌰，在 Python 的生态环境中，还有大量的实用类库可以免去我们造车轮的烦恼，生成上面这个分析图表我们不必从创造生成工具 pygal 开始，我们只需要知道 pygal 暴露给我们的接口，藉此我们可以只关注我们想做的事情。</p>
<p>下面再贴一张图表。</p>
<embed src="/img/python-svg/half_solid_gauge_chart.svg" />

<p>酷炫吧？</p>
<p>还有很多有趣的图表，这是我看官方文档时做的笔记，可以生成一批各种样式的图表。</p>
<p><a href="https://github.com/CRitsu/python.test/tree/master/rick/pygal_test/first_pygal_test.py">first_pygal_test.py</a></p>
<h3 id="关于爬虫"><a href="#关于爬虫" class="headerlink" title="关于爬虫"></a>关于爬虫</h3><p>花费了一周左右基本了解了 Python，又花费了一周的业余时间我写出了第一个爬虫。</p>
<p>其实时间主要都花在了查找资料，翻阅教程上了，等到原理和思路捋顺之后，放下资料对着电脑就撸出来了。爬的是豆瓣电影排名 Top 250，页面结构简单，总体难度不大。为了练习，我爬取了几乎所有信息（每个电影的介绍部分所有的文字），然后分门别类存入了 MySQL 中。</p>
<p>全程几乎没有难点，但是遇到一个问题，爬取外文名称之后没有给内容转义，由于外文名中偶尔出现的单引号让最后拼出来的 SQL 执行报错了。这个问题在对爬取的内容转义之后得到了解决。</p>
<p>还是很顺利的实现。但这仅仅是初级简单的页面。下面是这个爬虫的代码实现。</p>
<p>爬虫本体：</p>
<p><a href="https://github.com/zfanli/practice-archived/tree/master/python/crawler/crawler_douban/crawler_douban.py">crawler_douban.py</a></p>
<p>数据库链接工具：</p>
<p><a href="https://github.com/zfanli/practice-archived/tree/master/python/crawler/crawler_douban/db_connector.py">db_connector.py</a></p>
<p>用装饰器做的简单 log 工具：</p>
<p><a href="https://github.com/zfanli/practice-archived/tree/master/python/crawler/crawler_douban/simple_logger.py">simple_logger.py</a></p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>Python 拥有很有特色的语言特性，拥有丰富的生态系统，目前在人工智能领域比较受到推崇。但是目前我接触不到 AI 领域的东西，就一个 Web 应用开发者的角度来看，Python 吸引我的主要还是语法特点。</p>
<p>就这篇文章提出的几个例子来说，生成 SVG 的可交互图表，Python 使用第三方库确实能很快的制作出一张精美的图表 📈，但是限制也是很大的，比如生成的结果可定制可格式化的选项看上去不是很多，但是在处理 SVG 方面，基于浏览器出生的 JS 几乎是有着天然的优势——SVG 就是发明来给浏览器用的！</p>
<p>而在爬虫方面，Python 和 Node.js 相比个人感觉旗鼓相当，而 Node.js 除了对占用内存的限制之外，对于轻量级的爬虫来说，天生和网页打交道的 JS 岂不是天选之子？而 Python 可能在并发等方面才能击败 JS 吧…</p>
<p>不过毕竟我接触 Python 的时间不是很长，目前的了解可能也只是一己之偏见，至少我认同 Python 的价值，并且会继续使用下去，来看看将来我会对 Python 有哪些改观吧！</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>just notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>1.Official Documentation - Introducing Swift 5</title>
    <url>/post/notes/swift/1-SwiftIntroduction/</url>
    <content><![CDATA[<p>阅读官方对于 Swift 5 的介绍，了解它的特性和优势。多数都是摘抄原文或者翻译。</p>
<p><a href="https://developer.apple.com/swift/">https://developer.apple.com/swift/</a></p>
<span id="more"></span>

<h2 id="R：写在前面的小结"><a href="#R：写在前面的小结" class="headerlink" title="R：写在前面的小结"></a>R：写在前面的小结</h2><p>Swift 虽然是一个开源项目，但是更多还是用来构建 Apple 自己的平台的应用。但是随着 Swift 的标准库现在在新版本的系统中内置，相信选择使用 Swift 的项目会越来越多。</p>
<p>从设计上来看 Swift 充分参考了其他流行的语言的优劣，并且针对共通性的问题进行了主观的改善。看上去 Swift 从设计上就避免了很多可能出现的问题，但是安全性和便利性存在着不可调和的矛盾，着重安全性的 Swift 或许在便利性上相较其他语言稍逊一筹。不过我觉得这只是一个习惯问题，牺牲一点便利性来换取更少、更不容易犯错或许是合算的。</p>
<p>更多细节只能在后续的学习中体会摸索。如果你想在 Apple 平台开发应用，选择 Swift 就没错。</p>
<h2 id="扉页-Swift-5"><a href="#扉页-Swift-5" class="headerlink" title="扉页 Swift 5"></a>扉页 Swift 5</h2><p>一门功能强大的语言，同时也易于学习。</p>
<p>Swift 是一门功能强大（powerful）且直观（intuitive）的编程语言，用于 macOS、iOS、watchOS、tvOS 甚至是其他平台。用 Swift 编程是交互式且有趣的，它的语法简洁并且表达力强，它还包含了众多开发者喜爱的特性。Swift 代码从设计上考虑安全性，使用它制作的软件运行起来依旧快如闪电。</p>
<blockquote>
<p>R：扉页的牛吹得不错。</p>
</blockquote>
<h2 id="Swift-5-简介"><a href="#Swift-5-简介" class="headerlink" title="Swift 5 简介"></a>Swift 5 简介</h2><p>Swift 5 使你发布自己的 App 变得异常简单。因为 Swift 5 的运行环境如今已经内置于 macOS、iOS、watchOS、tvOS 的系统中，你的 App 在这些平台的最新系统上不再需要绑定它的运行环境包了。从 Apple Store 中下载 Swift 的 App 将会比以往体积更小、下载速度更快。</p>
<p>下面是它的附加特性。</p>
<ul>
<li>字符串使用 UTF-8 编码</li>
<li>Debug 和 release builds 下默认强制对内存独占访问</li>
<li>SIMD Vector and Result types in Standard Library</li>
<li>Dictionary 和 Set 的性能改善</li>
<li>支持动态可调用类型（dynamically callable types）以改善与动态语言（Python、JavaScript、Ruby 等）的交互性</li>
</ul>
<blockquote>
<p>R：不明觉厉。</p>
</blockquote>
<h2 id="现代化"><a href="#现代化" class="headerlink" title="现代化"></a>现代化</h2><p>Swift 是结合几十年构建 Apple 平台的经验，对编程语言研究的最新成果。以清晰的语法表达命名参数（Named parameters），可以使 Swift 的 API 更加容易阅读和维护。你甚至不需要输入分号。类型推测让代码更加清晰、更不易出错，而 modules 的存在摆脱了 headers 并且提供命名空间。字符串 Unicode-correct，基于 UTF-8 编码并对各种使用场景进行性能优化以更好的支持国际化语言和 emoji。自动内存管理基于严格确定性的变量引用计算，保持最低内存使用率的同时，没有垃圾回收的开销。</p>
<p>下面的例子展示现代化直观的语法声明一个类型。为实例属性添加默认值，并且自定义初始化器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> highScore: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> history: [<span class="type">Int</span>] <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> player <span class="operator">=</span> <span class="type">Player</span>(<span class="string">&quot;Tomas&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用 <code>extension</code> 对现有的类型进行功能扩展，使用字符串插值模版减少重复代码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">updateScore</span>(<span class="keyword">_</span> <span class="params">newScore</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        history.append(newScore)</span><br><span class="line">        <span class="keyword">if</span> highScore <span class="operator">&lt;</span> newScore &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(newScore)</span>! A new high score for <span class="subst">\(name)</span>! 🎉&quot;</span>)</span><br><span class="line">            highScore <span class="operator">=</span> newScore</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">player.updateScore(<span class="number">50</span>)</span><br><span class="line"><span class="comment">// Prints &quot;50! A new high score for Tomas! 🎉&quot;</span></span><br><span class="line"><span class="comment">// player.highScore == 50</span></span><br></pre></td></tr></table></figure>

<p>利用功能强大的语言特性快速扩展你的自定义类型，比如自动编码·解码 JSON 格式数据。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Player</span>: <span class="title">Codable</span>, <span class="title">Equatable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">let</span> encoder <span class="operator">=</span> <span class="type">JSONEncoder</span>()</span><br><span class="line"><span class="keyword">try</span> encoder.encode(player)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(player)</span><br><span class="line"><span class="comment">// Prints &quot;Tomas, games played: 1, high score: 50”</span></span><br></pre></td></tr></table></figure>

<p>使用最新简化的闭包函数执行功能强大的自定义变换。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> players <span class="operator">=</span> getPlayers()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort players, with best high scores first</span></span><br><span class="line"><span class="keyword">let</span> ranked <span class="operator">=</span> players.sorted(by: &#123; player1, player2 <span class="keyword">in</span></span><br><span class="line">    player1.highScore <span class="operator">&gt;</span> player2.highScore</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an array with only the players’ names</span></span><br><span class="line"><span class="keyword">let</span> rankedNames <span class="operator">=</span> ranked.map &#123; <span class="variable">$0</span>.name &#125;</span><br><span class="line"><span class="comment">// [&quot;Erin&quot;, &quot;Rosana&quot;, &quot;Tomas&quot;]</span></span><br></pre></td></tr></table></figure>

<p>这些前瞻的概念反映到编程语言中是十分有趣的，还容易使用。</p>
<p>Swift 还有很多其他的特性可以使你的代码更有表达力。</p>
<ul>
<li>功能强大、简单易用的泛型（Generics）</li>
<li>协议扩展（Protocol extensions）让同样代码编写更加容易</li>
<li>第一类函数（First class functions）和轻量级的闭包（closure）语法</li>
<li>对范围（range）和集合（collection）的迭代快速而简洁</li>
<li>元组（Tuple）和多返回值</li>
<li>支持方法、扩展、协议的结构（Structs）</li>
<li>枚举（Enums）可以有负载（payloads）且支持模式匹配</li>
<li>函数化编程，比如 map 和 filter</li>
<li>使用 <code>try</code>、<code>catch</code>、<code>throw</code> 处理原生错误（Native error）</li>
</ul>
<blockquote>
<p>R：偏向函数化的，集大成的语法。</p>
</blockquote>
<h2 id="为安全而设计"><a href="#为安全而设计" class="headerlink" title="为安全而设计"></a>为安全而设计</h2><p>Swift 移除了全部类型的不安全代码（entire classes of unsafe code）。变量在使用之前必须初始化，数组和整型会检查益处，内存自动管理，并且强制的独占内存访问可以防止很多编程错误。语法经过调整，可以轻松定义你的意图，比如简单的 3 字符关键字定义一个变量（<code>var</code>）或者常量（<code>let</code>）。并且 Swift 大量利用了值类型（value types），尤其是经常使用的数据类型，比如数组和字典。这意味着当你对这些数据类型的数据进行一次复制，你知道这些值不会在其他任何地方被修改。</p>
<blockquote>
<p>R：Value Types，对数据复制的时候复制其值，所以每个复制都是完全独立的实例，修改不会相互影响。与之相对的是 Reference Types，每次复制都仅复制引用，每个复制都共享同一份数据，数据的修改将影响所有复制的实例。</p>
</blockquote>
<p>另一个安全方面的特性是，Swift 对象永远不会是 <code>nil</code>。Swift 的编译器会在编译时报错来阻止你创建或使用一个 <code>nil</code> 对象。这会让代码更加清晰和安全，而且可以一下子避免好几个目录的足以让 App 崩溃的问题。当然，在某些情况下 <code>nil</code> 是有效且被允许的。Swift 有一个被称作可选值（optional）的创新特性针对这些场景。一个可选值允许 <code>nil</code>，但是 Swift 的语法会强制你使用 <code>?</code> 语法来告诉编译器你明白你在做什么并会安全处理它。</p>
<blockquote>
<p>R: 类似 TypeScript 里面关于类型定义的 <code>?</code> 语法，表示允许 <code>null</code> 或者 <code>undefined</code>。另外在 Swift 中，其他语言中熟知的 <code>null</code> 被称为 <code>nil</code>。</p>
</blockquote>
<p>当一个函数可能返回一个实例，也可能什么都不返回的时候，使用可选值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span> == <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Returns the highest score of all the players,</span></span><br><span class="line">    <span class="comment">// or `nil` if the collection is empty.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">highestScoringPlayer</span>()</span> -&gt; <span class="type">Player</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.max(by: &#123; <span class="variable">$0</span>.highScore <span class="operator">&lt;</span> <span class="variable">$1</span>.highScore &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可选值绑定（optional binding），可选值链（optional chaining）和 Nil 联合运算符（nil coalescing）等特性可以让你安全并有效率的处理可选值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> bestPlayer <span class="operator">=</span> players.highestScoringPlayer() &#123;</span><br><span class="line">    recordHolder <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The record holder is <span class="subst">\(bestPlayer.name)</span>,<span class="subst">\</span></span></span><br><span class="line"><span class="subst"><span class="string"></span>        with a high score of <span class="subst">\(bestPlayer.highScore)</span>!</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    recordHolder <span class="operator">=</span> <span class="string">&quot;No games have been played yet.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(recordHolder)</span><br><span class="line"><span class="comment">// The record holder is Erin, with a high score of 271!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> highestScore <span class="operator">=</span> players.highestScoringPlayer()<span class="operator">?</span>.highScore <span class="operator">??</span> <span class="number">0</span></span><br><span class="line"><span class="comment">// highestScore == 271</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：Nil Coalescing 类似三元表达式，简化版的。</p>
</blockquote>
<h2 id="快速的、功能强大的"><a href="#快速的、功能强大的" class="headerlink" title="快速的、功能强大的"></a>快速的、功能强大的</h2><p>Swift 从最初的设计上就是为了“快速”而生的。Swift 代码使用性能牛批的 LLVM 编译器技术，编译成优化过的原生代码，充分利用现代硬件的性能。它的语法和标准库同样经过调整，可以让你以最一目了然的方式写出来的代码同样可以获得最好的性能，无论其是运行在你的手表上或者是一组服务器中。</p>
<p>Swift 是 C 和 Objective-C 两者的继承者。它包含底层的原型，比如基本类型、流程控制和操作符。它也提供面向对象的特性，比如 class、协议和泛型，给 Cocoa 和 Cocoa Touch 开发者们要求的性能和功能。</p>
<h2 id="适合作为第一门语言"><a href="#适合作为第一门语言" class="headerlink" title="适合作为第一门语言"></a>适合作为第一门语言</h2><p>Swift 可以帮你打开编程世界的大门。它被设计成人们的第一门编程语言，无论你还是学生或是准备探索新的职业生涯。对教育工作者来说，Apple 制作了免费的课程以方便课堂内外的 Swift 教学。初次接触的人可以下载 Swift Playgrounds，一个 iPad 应用，让你在有趣的互动中熟悉 Swift 编程。</p>
<p>感兴趣的开发者可以访问免费的课程来学习如何使用 Xcode 构建他们的第一个 app。全球各地的 Apple Store 会主办 Today at Apple Coding &amp; Apps 活动，让你可以动手体验 Swift 编程。</p>
<blockquote>
<p>R：看了看资源大部分都是青少年教育内容…</p>
</blockquote>
<h2 id="源码与二进制码的兼容性"><a href="#源码与二进制码的兼容性" class="headerlink" title="源码与二进制码的兼容性"></a>源码与二进制码的兼容性</h2><p>在 Swift 5 中，你可以使用新的编译器编译 Swift 4 的代码，不需要任何修改。相反，你可以使用新的编译器来充分利用 Swift 5 的新特性，并且根据自己的节奏一个模块一个模块的进行迁移。</p>
<p>或者你可以仅使用新的编译器，按照你自己的节奏迁移到 Swift 5。现在 Swift 5 为应用引进了二进制兼容。这意味着针对当前的 OS 和未来发布的 OS，你不需要在你的应用中引入 Swift 库了，因为新的 OS 中将会内置 Swift 库。你的应用将会使用 OS 上最新的库，你的代码可以持续运行而不需要重新编译。这不仅可以让开发 App 变得更加简单，还可以减少 App 的体积和启动时间。</p>
<blockquote>
<p>R：当然仅限 Apple 生态。下面还有些碎碎念（？）。</p>
</blockquote>
<h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><p>Swift 是开源的，Apple 和外部数以百计的贡献者共同努力让 Swift 更好。</p>
<h3 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h3><p>Swift 已经在所有 Apple 平台和 Linux 上得到支持，并且社区在努力让更多平台支持 Swift。SourceKit-LSP 社区同时在致力于将 Swift 支持整合到各种开发工具中。</p>
<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><p>Swift 可以加强 Apple 平台的各种应用，同时它也可以用来制作新型现代服务器应用。Swift 可以完美支持追求运行时安全性、编译性能和小内存占用率的服务器端应用。</p>
<h2 id="Playgrounds-和交互解释器"><a href="#Playgrounds-和交互解释器" class="headerlink" title="Playgrounds 和交互解释器"></a>Playgrounds 和交互解释器</h2><p>诸如 iPad 的 Swift Playgrounds 和 Xcode 的 playgrounds 可以让写 Swift 代码轻松有趣。输入一行代码，立马就能得到结果。你可以从侧边栏快速查看结果，也可以固定在代码下面显示。结果可以以图片、结果集或随时更新的图表形式显示。你可以打开 Timeline Assistant 观察复杂的演算和动画，可以很方便的试验新的 UI 代码，或者调试你的 SpriteKit 代码。当你完成了代码的调整，只需要将 playground 中的代码移到你的项目中即可。Swift 在你使用命令行或者 Xcode 的 LLDB Debug 控制台时可以进行交互解释。使用 Swift 和正在运行的应用进行交互和计算，或者写一段新的代码来看看它是如何像脚本语言一样工作。</p>
<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>Swift Package Manager 是一个独立的跨平台工具，提供构建、运行、测试和打包功能。Swift 包是发布你的库和代码的最好方式。包的配置用 Swift 编写，可以简单的配置对象，声明产品和管理依赖。在 Swift 5 中，run 命令可以在 REPL 导入库，而不需要构建一个可执行文件。Swift Package Manager 本身作为 Swift 开源项目的一个包，使用 Swift 编写。</p>
<h2 id="Objective-C-互通性"><a href="#Objective-C-互通性" class="headerlink" title="Objective-C 互通性"></a>Objective-C 互通性</h2><p>如今你可以使用 Swift 构建一个完整的应用，或者使用 Swift 为你的应用开发新的功能。Swift 可以和你现有的 Objective-C 文件共存，并且可以完整的访问 Objective-C 的 API，适配更加简单。</p>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>2.<a href="https://github.com/zfanli/notes/blob/master/swift/2.SyntaxBasics(Strings&Variables).md">Swift Syntax Basics (字符串和变量)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>10.Swift Syntax Supplements</title>
    <url>/post/notes/swift/10-SyntaxSupplements/</url>
    <content><![CDATA[<p>这部分和后面几个 chapters 是对官方文档的笔记。</p>
<p>前面的内容其实是一个单独的快速入门教程，内容颗粒度较大，在很短的篇幅里介绍了大部分 Swfit 的特性，但是对细节几乎都是只字未提或者一带而过。而这些被掠过的细节，全部在这篇文档中进行了较为详尽的解释。这两篇分别为独立的文章，所以内容有很多重合。在这里我挑选前面教程没有提过的内容进行记录。</p>
<p>看到目前，这方便内容属于进阶知识，不影响你的生产能力，但是可以加深你的理解和生产的体验。</p>
<p>这章是对基础的补充。主要是对数字进制的各自表达方式，不常使用的别名关键字，以及改善开发流程的断言和先决条件进行了说明。</p>
<span id="more"></span>

<ul>
<li>数字进制</li>
</ul>
<p>二进制、八进制、十六进制的数字表现。</p>
<ul>
<li>typealias</li>
</ul>
<p>给类型命名别名。</p>
<ul>
<li>Assertions 和 Preconditions</li>
</ul>
<p>断言只对开发环境有效，先决条件在生产环境也有效。</p>
<h2 id="基础语法补充"><a href="#基础语法补充" class="headerlink" title="基础语法补充"></a>基础语法补充</h2><h3 id="先啰嗦几句"><a href="#先啰嗦几句" class="headerlink" title="先啰嗦几句"></a>先啰嗦几句</h3><p>前面 1 个介绍和 8 个 part 是官网的 Get Started 内容。此后官方的文档转向面对超级初心者的超啰嗦模式的详细解说。</p>
<p>看过官方的 A Tour 之后我们已经对 Swift 对样子有了个大概的印象了，不过显然一门编程语言是不可能如此容易的就被我们摸清的，很显然这个 Tour 为了简单起见隐去了大部分的细节。这里就是我速读这些细节之后记录的觉得比较重要的地方。</p>
<p>之所以是速读，只是我深知在毫无使用经验的前提下的精读是没有太大意义的，只有了解大概之后积累相应的开发经验，在此基础上进行精读才可能会有醍醐灌顶之感。这就是所谓的厚积薄发吧。</p>
<h3 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h3><p>看到这里你已经知道了，Swift 是主要用于苹果平台各个系统的开发语言。它脱胎于 C 和 Objective-C，如果你熟悉这两门语言或者其中一门，你会更轻松的掌握 Swift。</p>
<p>Swift 的类型很常见，毕竟脱胎于 C 和 Objective-C，它有整型 <code>Int</code>，双精度浮点数 <code>Double</code>，单精度浮点数 <code>Fload</code>，布尔值 <code>Bool</code>，文本数据类型 <code>String</code>。还有功能强大的三种集合类型，分别是数组 <code>Array</code>，集合 <code>Set</code> 和字典类型 <code>Dictionary</code>。后面会提到集合类型。</p>
<p>在声明变量时，Swift 会根据初始化值的类型推测变量的类型，根据官方提示，需要标注变量类型的场景不多，除非是声明时不进行初始化的变量，需要手动声明类型。</p>
<p>Swift 还引入了一些 Objective-C 中不存在的高级类型，比如元组，让你可以将一组值组合成一个组合值作为函数的返回值，来让函数可以返回多个值。还有可选型类型，用来处理变量值缺失的场景，这在 Swift 的众多特性中被广泛使用。</p>
<p>Swift 还是类型安全的，编译期间会检测传参类型不符等问题，帮助你在开发早期发现和解决问题。</p>
<p>Swift 不要求写分号，但是如果单行有多条语句则需要分号区分。</p>
<h3 id="一些类型"><a href="#一些类型" class="headerlink" title="一些类型"></a>一些类型</h3><ul>
<li>Int / UInt</li>
</ul>
<p>整型，无符号整型。</p>
<ul>
<li>Double / Float</li>
</ul>
<p>双精度浮点数，单精度浮点数。</p>
<ul>
<li>Bool</li>
</ul>
<p><code>true</code> 和 <code>false</code>。布尔值</p>
<ul>
<li>Tuples</li>
</ul>
<p>括号包围的数组，元素不限类型，一般用于将多个值打包。</p>
<h3 id="数字字面量"><a href="#数字字面量" class="headerlink" title="数字字面量"></a>数字字面量</h3><ul>
<li>10 进制无需前缀</li>
<li>2 进制 <code>0b</code> 前缀</li>
<li>8 进制 <code>0o</code> 前缀</li>
<li>16 进制 <code>0x</code> 前缀</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decimalInteger <span class="operator">=</span> <span class="number">17</span></span><br><span class="line"><span class="keyword">let</span> binaryInteger <span class="operator">=</span> <span class="number">0b10001</span>       <span class="comment">// 17 in binary notation</span></span><br><span class="line"><span class="keyword">let</span> octalInteger <span class="operator">=</span> <span class="number">0o21</span>           <span class="comment">// 17 in octal notation</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalInteger <span class="operator">=</span> <span class="number">0x11</span>     <span class="comment">// 17 in hexadecimal notation</span></span><br></pre></td></tr></table></figure>

<p>浮点数可以用十进制表示，同样可以用十六进制表示。浮点数的点两边都必须有数字。十进制的浮点数可以有一个可选的指数 e，不分大小写；而十六进制必须有指数 p，同样不分大小写。</p>
<ul>
<li>1.25e2 means 1.25 x 102, or 125.0.</li>
<li>1.25e-2 means 1.25 x 10-2, or 0.0125.</li>
<li>0xFp2 means 15 x 22, or 60.0.</li>
<li>0xFp-2 means 15 x 2-2, or 3.75.</li>
</ul>
<p>下面的数值字面量的值都是 12.1875。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decimalDouble <span class="operator">=</span> <span class="number">12.1875</span></span><br><span class="line"><span class="keyword">let</span> exponentDouble <span class="operator">=</span> <span class="number">1.21875e1</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalDouble <span class="operator">=</span> <span class="number">0xC.3p0</span></span><br></pre></td></tr></table></figure>

<p>数值字面量可以包含格式字符辅助阅读，可以补零，或用下划线分隔。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> paddedDouble <span class="operator">=</span> <span class="number">000123.456</span></span><br><span class="line"><span class="keyword">let</span> oneMillion <span class="operator">=</span> <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">let</span> justOverOneMillion <span class="operator">=</span> <span class="number">1_000_000.000_000_1</span></span><br></pre></td></tr></table></figure>

<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p><code>typealias</code> 关键字可以定义类型别名。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">AudioSample</span> <span class="operator">=</span> <span class="type">UInt16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxAmplitudeFound <span class="operator">=</span> <span class="type">AudioSample</span>.min</span><br><span class="line"><span class="comment">// maxAmplitudeFound is now 0</span></span><br></pre></td></tr></table></figure>

<h3 id="断言和先决条件"><a href="#断言和先决条件" class="headerlink" title="断言和先决条件"></a>断言和先决条件</h3><p>断言和先决条件的检查发生在运行时，用来检查在执行某段代码前是否满足一定基础条件。如果断言和先决条件的布尔值表达式返回 <code>true</code> 则程序继续执行，如果为 <code>false</code>，表示当前状态无效，程序停止执行，你的 App 也会停止运行。</p>
<p>断言和先决条件用来在编程过程中检查程序的运行是否如你的预期，因此你可以将其包括在你的代码中。断言可以帮助你在开发期间排错和纠错，先决条件可以帮助你在生产模式下侦测问题。</p>
<p>为了在运行时验证你的预期，断言和先决条件也将构成你代码中的非常有用的文档。和错误处理不同，断言和先决条件不是用来恢复或者预期一个错误的，因为一个失败了的断言或者先决条件表示无效的程序状态，失败了的断言或者先决条件无法像 Error 那样被捕获。</p>
<p>断言和先决条件不适合用于无效条件可能不作处理的情况。相反，使用它们来保证你的数据和状态的有效性，可以让你的程序在无效状态出现的时候可预料的结束运行，可以帮你更轻松的进行 debug。在检测到无效状态时即刻停止执行也将能有效的限制由其造成的伤害。</p>
<p>断言和先决条件的不同之处在于检查的时机：</p>
<ul>
<li>断言仅在 debug 构建中进行检查；而</li>
<li>先决条件在 debug 和生产构建中都将进行检查。</li>
</ul>
<p>生产环境下断言的判断不会进行计算。这意味着你可以在开发时不用考虑断言对生产环境下的执行性能的影响，根据你的需要设置断言。</p>
<h3 id="使用断言进行-Debug"><a href="#使用断言进行-Debug" class="headerlink" title="使用断言进行 Debug"></a>使用断言进行 Debug</h3><p>断言函数位于 Swift 标准库，它的 API 是 <code>assert(_:_:file:line:)</code>。你需要传递一个布尔表达式和在错误时显示的信息。不过错误信息是可选的，你可以省略它。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age <span class="operator">=</span> <span class="operator">-</span><span class="number">3</span></span><br><span class="line"><span class="built_in">assert</span>(age <span class="operator">&gt;=</span> <span class="number">0</span>, <span class="string">&quot;A person&#x27;s age can&#x27;t be less than zero.&quot;</span>)</span><br><span class="line"><span class="comment">// This assertion fails because -3 is not &gt;= 0.</span></span><br></pre></td></tr></table></figure>

<p>如果你的代码中已经进行了条件判断，可以使用 <code>assertionFailure(_:file:line:)</code> 直接抛出断言失败。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age <span class="operator">&gt;</span> <span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You can ride the roller-coaster or the ferris wheel.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> age <span class="operator">&gt;=</span> <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You can ride the ferris wheel.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">assertionFailure</span>(<span class="string">&quot;A person&#x27;s age can&#x27;t be less than zero.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="强制先决条件"><a href="#强制先决条件" class="headerlink" title="强制先决条件"></a>强制先决条件</h3><p>在你的代码需要保证一个布尔表达式一定返回 <code>true</code> 才能继续执行，但该表达式有潜在风险可能返回 <code>false</code> 时使用先决条件。比如在检查下标越界和函数是否传递了有效值时。</p>
<p>先决条件的 API 是 <code>precondition(_:_:file:line:)</code>，和断言一样，你需要提供一个布尔表达式进行计算，一个错误信息在失败时显示，这个信息可以被省略。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In the implementation of a subscript...</span></span><br><span class="line"><span class="built_in">precondition</span>(index <span class="operator">&gt;</span> <span class="number">0</span>, <span class="string">&quot;Index must be greater than zero.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>preconditionFailure(_:file:line:)</code> 可以用来在已经进行条件判断的情况下直接抛出先决条件失败。比如在 if 判断的 else 中，或者 switch 的 default 中。</p>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>9.<a href="https://github.com/zfanli/notes/blob/master/swift/9.SyntaxBasics(Generics).md">Swift Syntax Basics (泛型)</a></p>
<p>11.<a href="https://github.com/zfanli/notes/blob/master/swift/11.BasicOperators.md">Swift Basic Operators</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>11.Swift Basic Operators</title>
    <url>/post/notes/swift/11-BasicOperators/</url>
    <content><![CDATA[<p>操作符的定义：一个特殊符号或者语句用来检查、改变或者组合值。</p>
<p>Swift 支持大部分 C 的操作符，并且做了一些改善以避免一些共通的问题。</p>
<span id="more"></span>

<h2 id="基本操作符"><a href="#基本操作符" class="headerlink" title="基本操作符"></a>基本操作符</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>操作符分为一元、二元和三元操作符：</p>
<ul>
<li>一元操作符只操作一个对象，例如 <code>-a</code>，<code>b!</code>。</li>
<li>二元操作符操作两个对象，位于中间的位置，例如 <code>2 + 3</code>。</li>
<li>三元操作符操作三个对象，Swift 只有一个三元操作符，即三元表达式 <code>a ? b : c</code>。</li>
</ul>
<h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><p>赋值操作，不需要额外解释了。要注意的是不同于 C 和 Objective-C，Swift 的赋值操作不会有返回值。</p>
<p>另外，如果右边是元组类型的数据，赋值操作可以进行解构赋值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y) <span class="operator">=</span> (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// x is equal to 1, and y is equal to 2</span></span><br></pre></td></tr></table></figure>

<h3 id="运算操作符"><a href="#运算操作符" class="headerlink" title="运算操作符"></a>运算操作符</h3><p>加减乘除。这部分有用的信息可能就是加减乘除的英文说法了把…</p>
<ul>
<li>Addition (+)</li>
<li>Subtraction (-)</li>
<li>Multiplication (*)</li>
<li>Division (/)</li>
</ul>
<p>外加一个取余数操作符 <code>%</code>。</p>
<h3 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h3><p>并无两样。学学英文把。</p>
<ul>
<li>Equal to (a == b)</li>
<li>Not equal to (a != b)</li>
<li>Greater than (a &gt; b)</li>
<li>Less than (a &lt; b)</li>
<li>Greater than or equal to (a &gt;= b)</li>
<li>Less than or equal to (a &lt;= b)</li>
</ul>
<p>特殊一点的是 Swift 还提供 <code>===</code> 和 <code>!==</code> 用来检查两个对象是否引用同一个对象实例。这个和 JavaScript 比较像。</p>
<p>比较操作符都将返回布尔值。比较操作符可以对元组进行比较，但是要求数据类型和元素数量相同，比较时遵从从左到右的顺序，一次比较一对值，直到比较出不符合条件的值为止，或者到最后都满足条件则返回 <code>true</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="string">&quot;zebra&quot;</span>) <span class="operator">&lt;</span> (<span class="number">2</span>, <span class="string">&quot;apple&quot;</span>)   <span class="comment">// true because 1 is less than 2; &quot;zebra&quot; and &quot;apple&quot; are not compared</span></span><br><span class="line">(<span class="number">3</span>, <span class="string">&quot;apple&quot;</span>) <span class="operator">&lt;</span> (<span class="number">3</span>, <span class="string">&quot;bird&quot;</span>)    <span class="comment">// true because 3 is equal to 3, and &quot;apple&quot; is less than &quot;bird&quot;</span></span><br><span class="line">(<span class="number">4</span>, <span class="string">&quot;dog&quot;</span>) <span class="operator">==</span> (<span class="number">4</span>, <span class="string">&quot;dog&quot;</span>)      <span class="comment">// true because 4 is equal to 4, and &quot;dog&quot; is equal to &quot;dog&quot;</span></span><br></pre></td></tr></table></figure>

<p>三元表达式就没啥好说的了，用法都一样。</p>
<h3 id="Nil-Coalescing-运算符"><a href="#Nil-Coalescing-运算符" class="headerlink" title="Nil-Coalescing 运算符"></a>Nil-Coalescing 运算符</h3><p>不好确定怎么翻译，字面意思是 Nil 联合运算符。看上去这个是三元运算符针对 Nil 的场合演化的简化版本，语法糖。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColorName <span class="operator">=</span> <span class="string">&quot;red&quot;</span></span><br><span class="line"><span class="keyword">var</span> userDefinedColorName: <span class="type">String</span>?   <span class="comment">// defaults to nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colorNameToUse <span class="operator">=</span> userDefinedColorName <span class="operator">??</span> defaultColorName</span><br><span class="line"><span class="comment">// userDefinedColorName is nil, so colorNameToUse is set to the default of &quot;red&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="范围操作符"><a href="#范围操作符" class="headerlink" title="范围操作符"></a>范围操作符</h3><p>范围操作符是 Swift 的特殊，至少我在 Java 和 JavaScript 中没有见过。Python 中好像是有的？</p>
<h3 id="闭合范围操作符"><a href="#闭合范围操作符" class="headerlink" title="闭合范围操作符"></a>闭合范围操作符</h3><p>指定一个范围，包括左右的值。<code>a...b</code>， a 的值需要小于 b。在 for-in 循环中非常有用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(index)</span> times 5 is <span class="subst">\(index <span class="operator">*</span> <span class="number">5</span>)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 times 5 is 5</span></span><br><span class="line"><span class="comment">// 2 times 5 is 10</span></span><br><span class="line"><span class="comment">// 3 times 5 is 15</span></span><br><span class="line"><span class="comment">// 4 times 5 is 20</span></span><br><span class="line"><span class="comment">// 5 times 5 is 25</span></span><br></pre></td></tr></table></figure>

<h3 id="半开放范围操作符"><a href="#半开放范围操作符" class="headerlink" title="半开放范围操作符"></a>半开放范围操作符</h3><p>指定一个范围但是不包括右边的值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Brian&quot;</span>, <span class="string">&quot;Jack&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> count <span class="operator">=</span> names.count</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>count &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Person <span class="subst">\(i <span class="operator">+</span> <span class="number">1</span>)</span> is called <span class="subst">\(names[i])</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Person 1 is called Anna</span></span><br><span class="line"><span class="comment">// Person 2 is called Alex</span></span><br><span class="line"><span class="comment">// Person 3 is called Brian</span></span><br><span class="line"><span class="comment">// Person 4 is called Jack</span></span><br></pre></td></tr></table></figure>

<h3 id="单边范围操作符"><a href="#单边范围操作符" class="headerlink" title="单边范围操作符"></a>单边范围操作符</h3><p>闭合范围操作符的另一个形式。用来指定从某个值到最后，或者从开始到某个值的范围。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="number">2</span><span class="operator">...</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Brian</span></span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="operator">...</span><span class="number">2</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Anna</span></span><br><span class="line"><span class="comment">// Alex</span></span><br><span class="line"><span class="comment">// Brian</span></span><br></pre></td></tr></table></figure>

<p>半开放范围操作符也可以写成单边范围形式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="operator">..&lt;</span><span class="number">2</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Anna</span></span><br><span class="line"><span class="comment">// Alex</span></span><br></pre></td></tr></table></figure>

<h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><ul>
<li>Logical NOT (!a)</li>
<li>Logical AND (a &amp;&amp; b)</li>
<li>Logical OR (a || b)</li>
</ul>
<p>可以添加括号增强逻辑判断表达式的可读性，这些括号实际上是不需要的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (enteredDoorCode <span class="operator">&amp;&amp;</span> passedRetinaScan) <span class="operator">||</span> hasDoorKey <span class="operator">||</span> knowsOverridePassword &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ACCESS DENIED&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Welcome!&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>10.<a href="https://github.com/zfanli/notes/blob/master/swift/10.SyntaxSupplements.md">Swift Syntax Supplements</a></p>
<p>12.<a href="https://github.com/zfanli/notes/blob/master/swift/12.StringsAndCharacters.md">Swift Strings and Characters</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>12.Swift Strings and Characters</title>
    <url>/post/notes/swift/12-StringsAndCharacters/</url>
    <content><![CDATA[<p>字符串相较其他语言没有太多不同点。Swift 有类似 Python 的三引号字符串允许换行。Swift 的字符串是基于 Unicode 驱动，所以虽然字符串可以用索引提取字符，但是由于每个字符字节数不同不能使用整数作为索引，编辑索引的方式稍有特殊。其他的比如拼接、截取、非空判断、前缀后缀等都没有太大区别。看下面的代码示例足够了。</p>
<span id="more"></span>

<h2 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h2><h3 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h3><p>多行字符串使用三引号 <code>&quot;&quot;&quot;</code>。如果只是为了方便阅读换行，实际上字符串不需要换行符时，使用反斜杠换行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> softWrappedQuotation <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">The White Rabbit put on his spectacles.  &quot;Where shall I begin, <span class="subst">\</span></span></span><br><span class="line"><span class="subst"><span class="string"></span>please your Majesty?&quot; he asked.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on <span class="subst">\</span></span></span><br><span class="line"><span class="subst"><span class="string"></span>till you come to the end; then stop.&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将储存两行字符串。最后的三引号可以缩进，字符串内容可以根据三引号缩进的长度加入缩进，而不会将多余的空格包含在字符串里。如果行前行后需要换行，则在行前行后加空行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lineBreaks <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This string starts with a line break.</span></span><br><span class="line"><span class="string">It also ends with a line break.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>缩进的时候。下面这样写不会有多余的空格。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lineBreaks <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This string starts with a line break.</span></span><br><span class="line"><span class="string">    It also ends with a line break.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>字符串中有下面这些特殊字符。</p>
<ul>
<li>转意特殊字符，<code>\0</code> 空字符串，<code>\\</code> 反斜杠，<code>\t</code> tab，<code>\n</code> line feed，<code>\r</code> 回车，<code>\&quot;</code> 双引号，<code>\&#39;</code> 单引号。</li>
<li>Unicode 字符 <code>\u&#123;n&#125;</code>。n 是 1-8 位的十六进制数字。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wiseWords <span class="operator">=</span> <span class="string">&quot;<span class="subst">\&quot;</span>Imagination is more important than knowledge<span class="subst">\&quot;</span> - Einstein&quot;</span></span><br><span class="line"><span class="comment">// &quot;Imagination is more important than knowledge&quot; - Einstein</span></span><br><span class="line"><span class="keyword">let</span> dollarSign <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;24&#125;</span>&quot;</span>        <span class="comment">// $,  Unicode scalar U+0024</span></span><br><span class="line"><span class="keyword">let</span> blackHeart <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;2665&#125;</span>&quot;</span>      <span class="comment">// ♥,  Unicode scalar U+2665</span></span><br><span class="line"><span class="keyword">let</span> sparklingHeart <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;1F496&#125;</span>&quot;</span> <span class="comment">// 💖, Unicode scalar U+1F496</span></span><br></pre></td></tr></table></figure>

<p>声明一个空字符串。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyString <span class="operator">=</span> <span class="string">&quot;&quot;</span>               <span class="comment">// empty string literal</span></span><br><span class="line"><span class="keyword">var</span> anotherEmptyString <span class="operator">=</span> <span class="type">String</span>()  <span class="comment">// initializer syntax</span></span><br><span class="line"><span class="comment">// these two strings are both empty, and are equivalent to each other</span></span><br></pre></td></tr></table></figure>

<p>判断一个字符串是否为空。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Nothing to see here&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Nothing to see here&quot;</span></span><br></pre></td></tr></table></figure>

<p>修改字符串。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variableString <span class="operator">=</span> <span class="string">&quot;Horse&quot;</span></span><br><span class="line">variableString <span class="operator">+=</span> <span class="string">&quot; and carriage&quot;</span></span><br><span class="line"><span class="comment">// variableString is now &quot;Horse and carriage&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> constantString <span class="operator">=</span> <span class="string">&quot;Highlander&quot;</span></span><br><span class="line">constantString <span class="operator">+=</span> <span class="string">&quot; and another Highlander&quot;</span></span><br><span class="line"><span class="comment">// this reports a compile-time error - a constant string cannot be modified</span></span><br></pre></td></tr></table></figure>

<p>字符串的传递是复制值。每一个新的拷贝都是独立存在的实例，相互之间没有关联，这意味着你将一个字符串传递给另一个变量之后，你对其做的修改不会影响到其拷贝上。</p>
<h3 id="操作字符"><a href="#操作字符" class="headerlink" title="操作字符"></a>操作字符</h3><p>可以使用 for-in 对字符串的每一个字符进行遍历。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">&quot;Dog!🐶&quot;</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(character)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// D</span></span><br><span class="line"><span class="comment">// o</span></span><br><span class="line"><span class="comment">// g</span></span><br><span class="line"><span class="comment">// !</span></span><br><span class="line"><span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure>

<p>如果要声明一个字符变量需要提供类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;!&quot;</span></span><br></pre></td></tr></table></figure>

<p>字符数组可以初始化一个字符串。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> catCharacters: [<span class="type">Character</span>] <span class="operator">=</span> [<span class="string">&quot;C&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot;🐱&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> catString <span class="operator">=</span> <span class="type">String</span>(catCharacters)</span><br><span class="line"><span class="built_in">print</span>(catString)</span><br><span class="line"><span class="comment">// Prints &quot;Cat!🐱&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="链接字符串"><a href="#链接字符串" class="headerlink" title="链接字符串"></a>链接字符串</h3><p>可以用字符串的 append 方法将一个字符加入到字符串。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string1 <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">let</span> string2 <span class="operator">=</span> <span class="string">&quot; there&quot;</span></span><br><span class="line"><span class="keyword">var</span> welcome <span class="operator">=</span> string1 <span class="operator">+</span> string2</span><br><span class="line"><span class="comment">// welcome now equals &quot;hello there&quot;</span></span><br><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">welcome.append(exclamationMark)</span><br><span class="line"><span class="comment">// welcome now equals &quot;hello there!&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果你用多行字符串编辑一个列表，希望每一个元素占一行，那么你需要在最后留空一行才会加入一个换行符在字符串的结尾。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> badStart <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">one</span></span><br><span class="line"><span class="string">two</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> end <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">three</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(badStart <span class="operator">+</span> end)</span><br><span class="line"><span class="comment">// Prints two lines:</span></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// twothree</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> goodStart <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">one</span></span><br><span class="line"><span class="string">two</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(goodStart <span class="operator">+</span> end)</span><br><span class="line"><span class="comment">// Prints three lines:</span></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><p>模版字符串。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> multiplier <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> message <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(multiplier)</span> times 2.5 is <span class="subst">\(Double(multiplier) <span class="operator">*</span> <span class="number">2.5</span>)</span>&quot;</span></span><br><span class="line"><span class="comment">// message is &quot;3 times 2.5 is 7.5&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="字符计数"><a href="#字符计数" class="headerlink" title="字符计数"></a>字符计数</h3><p>字符串的 <code>.count</code> 可以获得字符的计数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unusualMenagerie <span class="operator">=</span> <span class="string">&quot;Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;unusualMenagerie has <span class="subst">\(unusualMenagerie.count)</span> characters&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;unusualMenagerie has 40 characters&quot;</span></span><br></pre></td></tr></table></figure>

<p>swift 对 character 类型值使用扩展的字位簇（grapheme clusters），这意味着字符串的拼接和修改并不总是会影响字符串的长度。例如给 <code>cafe</code> 这个单词加上法语的重音符号，修改后的字符串仍然是 4 位。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> word <span class="operator">=</span> <span class="string">&quot;cafe&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.count)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;the number of characters in cafe is 4&quot;</span></span><br><span class="line"></span><br><span class="line">word <span class="operator">+=</span> <span class="string">&quot;<span class="subst">\u&#123;301&#125;</span>&quot;</span>    <span class="comment">// COMBINING ACUTE ACCENT, U+0301</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.count)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;the number of characters in café is 4&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串的访问和修改"><a href="#字符串的访问和修改" class="headerlink" title="字符串的访问和修改"></a>字符串的访问和修改</h3><p>你可以通过它的方法、属性甚至是下标来访问和修改字符串。</p>
<p>不过通过索引的方式访问字符串比较特殊，因为每个字符可能使用不同量的内存储存，所以想要知道哪个字符在哪个为止，需要对字符串进行遍历才行。Swift 对字符串索引无法用一个整数来表示。</p>
<p><code>startIndex</code> 属性可以得到字符串索引的开始，<code>endIndex</code> 表示结束，结束的值是不包含的。所以 <code>endIndex</code> 不能作为下标取字符串中的字符。如果字符串为空，则 <code>startIndex</code> 和 <code>endIndex</code> 相等。</p>
<p>想通过下标拿字符串的字符，可以使用字符串的 <code>.index(before:)</code>、<code>.index(after:)</code> 和 <code>.index(_:offsetBy:)</code> 方法拿到索引值，用索引值去拿字符。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Guten Tag!&quot;</span></span><br><span class="line">greeting[greeting.startIndex]</span><br><span class="line"><span class="comment">// G</span></span><br><span class="line">greeting[greeting.index(before: greeting.endIndex)]</span><br><span class="line"><span class="comment">// !</span></span><br><span class="line">greeting[greeting.index(after: greeting.startIndex)]</span><br><span class="line"><span class="comment">// u</span></span><br><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> greeting.index(greeting.startIndex, offsetBy: <span class="number">7</span>)</span><br><span class="line">greeting[index]</span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure>

<p>下标越界会在运行时报错。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">greeting[greeting.endIndex] <span class="comment">// Error</span></span><br><span class="line">greeting.index(after: greeting.endIndex) <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> greeting.indices &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(greeting[index])</span> &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;G u t e n   T a g ! &quot;</span></span><br></pre></td></tr></table></figure>

<p>插入和移除字符。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> welcome <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">welcome.insert(<span class="string">&quot;!&quot;</span>, at: welcome.endIndex)</span><br><span class="line"><span class="comment">// welcome now equals &quot;hello!&quot;</span></span><br><span class="line"></span><br><span class="line">welcome.insert(contentsOf: <span class="string">&quot; there&quot;</span>, at: welcome.index(before: welcome.endIndex))</span><br><span class="line"><span class="comment">// welcome now equals &quot;hello there!&quot;</span></span><br><span class="line"></span><br><span class="line">welcome.remove(at: welcome.index(before: welcome.endIndex))</span><br><span class="line"><span class="comment">// welcome now equals &quot;hello there&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> range <span class="operator">=</span> welcome.index(welcome.endIndex, offsetBy: <span class="operator">-</span><span class="number">6</span>)<span class="operator">..&lt;</span>welcome.endIndex</span><br><span class="line">welcome.removeSubrange(range)</span><br><span class="line"><span class="comment">// welcome now equals &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>分隔字符串。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> greeting.firstIndex(of: <span class="string">&quot;,&quot;</span>) <span class="operator">??</span> greeting.endIndex</span><br><span class="line"><span class="keyword">let</span> beginning <span class="operator">=</span> greeting[<span class="operator">..&lt;</span>index]</span><br><span class="line"><span class="comment">// beginning is &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert the result to a String for long-term storage.</span></span><br><span class="line"><span class="keyword">let</span> newString <span class="operator">=</span> <span class="type">String</span>(beginning)</span><br></pre></td></tr></table></figure>

<p>前缀和后缀。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> romeoAndJuliet <span class="operator">=</span> [</span><br><span class="line">    <span class="string">&quot;Act 1 Scene 1: Verona, A public place&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 1 Scene 2: Capulet&#x27;s mansion&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 1 Scene 3: A room in Capulet&#x27;s mansion&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 1 Scene 4: A street outside Capulet&#x27;s mansion&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 1 Scene 5: The Great Hall in Capulet&#x27;s mansion&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 2 Scene 1: Outside Capulet&#x27;s mansion&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 2 Scene 2: Capulet&#x27;s orchard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 2 Scene 3: Outside Friar Lawrence&#x27;s cell&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 2 Scene 4: A street in Verona&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 2 Scene 5: Capulet&#x27;s mansion&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 2 Scene 6: Friar Lawrence&#x27;s cell&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> act1SceneCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> scene <span class="keyword">in</span> romeoAndJuliet &#123;</span><br><span class="line">    <span class="keyword">if</span> scene.hasPrefix(<span class="string">&quot;Act 1 &quot;</span>) &#123;</span><br><span class="line">        act1SceneCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;There are <span class="subst">\(act1SceneCount)</span> scenes in Act 1&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;There are 5 scenes in Act 1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mansionCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> cellCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> scene <span class="keyword">in</span> romeoAndJuliet &#123;</span><br><span class="line">    <span class="keyword">if</span> scene.hasSuffix(<span class="string">&quot;Capulet&#x27;s mansion&quot;</span>) &#123;</span><br><span class="line">        mansionCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> scene.hasSuffix(<span class="string">&quot;Friar Lawrence&#x27;s cell&quot;</span>) &#123;</span><br><span class="line">        cellCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(mansionCount)</span> mansion scenes; <span class="subst">\(cellCount)</span> cell scenes&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;6 mansion scenes; 2 cell scenes&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>11.<a href="https://github.com/zfanli/notes/blob/master/swift/11.BasicOperators.md">Swift Basic Operators</a></p>
<p>13.<a href="https://github.com/zfanli/notes/blob/master/swift/13.CollectionTypes.md">Swift Collection Types</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>13.Swift Collection Types</title>
    <url>/post/notes/swift/13-CollectionTypes/</url>
    <content><![CDATA[<p>Array、Set、Dictionary 是很经典的三个集合类型。流行语言都有对应的实现。本章比较详细的介绍了每种集合类型的各种操作，内容本身就是一个总结，也就不需要小结多说什么了。熟悉完这章内容基本就摸清了 Swift 的集合类型。</p>
<span id="more"></span>

<h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><p>Swift 的集合类型有 Array、Set 和 Dictionary 三种。它们的值类型都是固定的，你无法插入一个不同类型的值到这些集合类型中。当声明一个变量时，这三种类型的数据是属于可修改是，可以添加和删除元素。但是如果声明一个常量时，将会是不可修改类型，内容无法修改。</p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>声明数组使用 <code>Array&lt;Element&gt;</code>，有一个缩写方式是 <code>[Element]</code>。建议使用缩写。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someInts <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;someInts is of type [Int] with <span class="subst">\(someInts.count)</span> items.&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;someInts is of type [Int] with 0 items.&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果变量类型定义过一次，或者被推测过一次，可以使用 <code>[]</code> 再次将其初始化为空数组而不需要提示类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">someInts.append(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// someInts now contains 1 value of type Int</span></span><br><span class="line">someInts <span class="operator">=</span> []</span><br><span class="line"><span class="comment">// someInts is now an empty array, but is still of type [Int]</span></span><br></pre></td></tr></table></figure>

<p>创建数组时可以提供默认值。例如下面重复 <code>0.0</code> 3 次作为默认值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeDoubles <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">0.0</span>, count: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]</span></span><br></pre></td></tr></table></figure>

<p><code>+</code> 操作符可以直接合并两个 Array。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherThreeDoubles <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">2.5</span>, count: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sixDoubles <span class="operator">=</span> threeDoubles <span class="operator">+</span> anotherThreeDoubles</span><br><span class="line"><span class="comment">// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</span></span><br></pre></td></tr></table></figure>

<p>通过字面量声明数组。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList: [<span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;Eggs&quot;</span>, <span class="string">&quot;Milk&quot;</span>]</span><br><span class="line"><span class="comment">// shoppingList has been initialized with two initial items</span></span><br></pre></td></tr></table></figure>

<p>可以省略类型声明。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList <span class="operator">=</span> [<span class="string">&quot;Eggs&quot;</span>, <span class="string">&quot;Milk&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>数组有只读的 <code>count</code> 属性可以拿到数组长度。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The shopping list contains <span class="subst">\(shoppingList.count)</span> items.&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The shopping list contains 2 items.&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>isEmpty</code> 方法判断数组是否为空。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> shoppingList.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The shopping list is empty.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The shopping list is not empty.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The shopping list is not empty.&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>append</code> 在数组末尾添加新的元素。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">shoppingList.append(<span class="string">&quot;Flour&quot;</span>)</span><br><span class="line"><span class="comment">// shoppingList now contains 3 items, and someone is making pancakes</span></span><br></pre></td></tr></table></figure>

<p><code>+=</code> 快速合并另一个数组。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">shoppingList <span class="operator">+=</span> [<span class="string">&quot;Baking Powder&quot;</span>]</span><br><span class="line"><span class="comment">// shoppingList now contains 4 items</span></span><br><span class="line">shoppingList <span class="operator">+=</span> [<span class="string">&quot;Chocolate Spread&quot;</span>, <span class="string">&quot;Cheese&quot;</span>, <span class="string">&quot;Butter&quot;</span>]</span><br><span class="line"><span class="comment">// shoppingList now contains 7 items</span></span><br></pre></td></tr></table></figure>

<p>可以使用下标语法同时修改一个范围的值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">shoppingList[<span class="number">4</span><span class="operator">...</span><span class="number">6</span>] <span class="operator">=</span> [<span class="string">&quot;Bananas&quot;</span>, <span class="string">&quot;Apples&quot;</span>]</span><br><span class="line"><span class="comment">// shoppingList now contains 6 items</span></span><br></pre></td></tr></table></figure>

<p>在指定位置插入元素。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">shoppingList.insert(<span class="string">&quot;Maple Syrup&quot;</span>, at: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// shoppingList now contains 7 items</span></span><br><span class="line"><span class="comment">// &quot;Maple Syrup&quot; is now the first item in the list</span></span><br></pre></td></tr></table></figure>

<p>或者移除指定位置的值。<code>.remove(_:at)</code> 移除元素同时将值返回，如果你不需要返回值，可以不去接收。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mapleSyrup <span class="operator">=</span> shoppingList.remove(at: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// the item that was at index 0 has just been removed</span></span><br><span class="line"><span class="comment">// shoppingList now contains 6 items, and no Maple Syrup</span></span><br><span class="line"><span class="comment">// the mapleSyrup constant is now equal to the removed &quot;Maple Syrup&quot; string</span></span><br></pre></td></tr></table></figure>

<p>移除最后一个元素有一个简单的方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> apples <span class="operator">=</span> shoppingList.removeLast()</span><br><span class="line"><span class="comment">// the last item in the array has just been removed</span></span><br><span class="line"><span class="comment">// shoppingList now contains 5 items, and no apples</span></span><br><span class="line"><span class="comment">// the apples constant is now equal to the removed &quot;Apples&quot; string</span></span><br></pre></td></tr></table></figure>

<p>for-in 直接遍历 Array。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> shoppingList &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Six eggs</span></span><br><span class="line"><span class="comment">// Milk</span></span><br><span class="line"><span class="comment">// Flour</span></span><br><span class="line"><span class="comment">// Baking Powder</span></span><br><span class="line"><span class="comment">// Bananas</span></span><br></pre></td></tr></table></figure>

<p>如果遍历时需要拿到索引，使用 <code>.enumerated()</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> shoppingList.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Item <span class="subst">\(index <span class="operator">+</span> <span class="number">1</span>)</span>: <span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Item 1: Six eggs</span></span><br><span class="line"><span class="comment">// Item 2: Milk</span></span><br><span class="line"><span class="comment">// Item 3: Flour</span></span><br><span class="line"><span class="comment">// Item 4: Baking Powder</span></span><br><span class="line"><span class="comment">// Item 5: Bananas</span></span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 是无序的，同时没有重复值。你可以在不需要排序或者要保证值不重复的时候使用 Set。</p>
<p>Set 需要 Hash 值用来储存一个值，这要求这个值的类型是可哈希的（hashable），即这个类型能够计算自己的 Hash 值。对象的 Hash 值是一个整数数值，用来比较两个对象是否相同。比如 <code>if a == b</code> 实际上比较的是 <code>if a.hashValue == b.hashValue</code>。</p>
<p>Swift 的基础类型默认都是 Hashable 的，可以作为 Set 或 Dictionary 的键值类型。枚举类型的 case 在不存在关联值的情况下默认也是要求 Hashable 的类型。</p>
<blockquote>
<p>NOTE: 自定义类型作为 Set 或者 Dictionary 的键值类型时必须要实现 Swift 标准库中的 Hashable 协议。这个协议要求一个类型需要有一个可取得的 <code>hashValue</code> 整数数值属性。由于 Hashable 协议继承了 Equatable 协议，所以你还需要实现双等号操作符比较，并且满足三个条件：</p>
<ul>
<li>a == a (Reflexivity 自反性)</li>
<li>a == b implies b == a (Symmetry 对称性)</li>
<li>a == b &amp;&amp; b == c implies a == c (Transitivity 传递性)</li>
</ul>
</blockquote>
<p>使用 <code>Set&lt;Element&gt;</code> 声明一个 Set。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> letters <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;letters is of type Set&lt;Character&gt; with <span class="subst">\(letters.count)</span> items.&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;letters is of type Set&lt;Character&gt; with 0 items.&quot;</span></span><br></pre></td></tr></table></figure>

<p>同样，一旦确定了变量的信息，你对其重新初始化可以省略类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">letters.insert(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">// letters now contains 1 value of type Character</span></span><br><span class="line">letters <span class="operator">=</span> []</span><br><span class="line"><span class="comment">// letters is now an empty set, but is still of type Set&lt;Character&gt;</span></span><br></pre></td></tr></table></figure>

<p>字面量创建一个 Set。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> [<span class="string">&quot;Rock&quot;</span>, <span class="string">&quot;Classical&quot;</span>, <span class="string">&quot;Hip hop&quot;</span>]</span><br><span class="line"><span class="comment">// favoriteGenres has been initialized with three initial items</span></span><br></pre></td></tr></table></figure>

<p>字面量声明一个 Set 和声明一个 Array 的写法是相同的，所以如果不写变量类型，将会是一个 Array。这里 Set 类型是必须提示的，而值类型可以由 Swift 自动推测出来，所以可以省略。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;Rock&quot;</span>, <span class="string">&quot;Classical&quot;</span>, <span class="string">&quot;Hip hop&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>拿长度、空 Set 判断、插入元素、移除元素都和 Array 类似。唯一的差异是 Set 是无序的，插入和移除元素的时候寻找的是元素值而不是索引。看看下面的示例。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;I have <span class="subst">\(favoriteGenres.count)</span> favorite music genres.&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;I have 3 favorite music genres.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> favoriteGenres.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;As far as music goes, I&#x27;m not picky.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I have particular music preferences.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;I have particular music preferences.&quot;</span></span><br><span class="line"></span><br><span class="line">favoriteGenres.insert(<span class="string">&quot;Jazz&quot;</span>)</span><br><span class="line"><span class="comment">// favoriteGenres now contains 4 items</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedGenre <span class="operator">=</span> favoriteGenres.remove(<span class="string">&quot;Rock&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(removedGenre)</span>? I&#x27;m over it.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I never much cared for that.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Rock? I&#x27;m over it.&quot;</span></span><br></pre></td></tr></table></figure>

<p>此外 Set 可以检测是否包含一个元素。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> favoriteGenres.contains(<span class="string">&quot;Funk&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I get up on the good foot.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s too funky in here.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;It&#x27;s too funky in here.&quot;</span></span><br></pre></td></tr></table></figure>

<p>for-in 可以直接遍历 Set。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> genre <span class="keyword">in</span> favoriteGenres &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(genre)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Classical</span></span><br><span class="line"><span class="comment">// Jazz</span></span><br><span class="line"><span class="comment">// Hip hop</span></span><br></pre></td></tr></table></figure>

<p>Set 是无序的。需要排序的时候可以使用 <code>.sorted()</code>，其处理是将 Set 转化为 Array 并且用 &lt; 操作符排序。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> genre <span class="keyword">in</span> favoriteGenres.sorted() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(genre)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Classical</span></span><br><span class="line"><span class="comment">// Hip hop</span></span><br><span class="line"><span class="comment">// Jazz</span></span><br></pre></td></tr></table></figure>

<p>集合操作：</p>
<ul>
<li>intersection(_:) 取交集</li>
<li>symmetricDifference(_:) 取反集</li>
<li>union(_:) 取并集</li>
<li>subtracting(_:) 取减集</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oddDigits: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> evenDigits: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">let</span> singleDigitPrimeNumbers: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">oddDigits.union(evenDigits).sorted()</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">oddDigits.intersection(evenDigits).sorted()</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line">oddDigits.subtracting(singleDigitPrimeNumbers).sorted()</span><br><span class="line"><span class="comment">// [1, 9]</span></span><br><span class="line">oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()</span><br><span class="line"><span class="comment">// [1, 2, 9]</span></span><br></pre></td></tr></table></figure>

<p>集合比较：</p>
<ul>
<li>等号（=）比较两个集合是否有完全相同的元素</li>
<li>isSubset(of:) 判断一个集合是否是另一个的子集</li>
<li>isSuperset(of:) 判断一个集合是否是另一个的超集</li>
<li>isStrictSubset(of:) 或 isStrictSuperset(of:) 判断一个集合是否是另一个的超集或者子集，但不包括两个集合相等的情况</li>
<li>isDisjoint(with:) 判断两个集合是否不包含相同的元素</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> houseAnimals: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;🐶&quot;</span>, <span class="string">&quot;🐱&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> farmAnimals: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;🐮&quot;</span>, <span class="string">&quot;🐔&quot;</span>, <span class="string">&quot;🐑&quot;</span>, <span class="string">&quot;🐶&quot;</span>, <span class="string">&quot;🐱&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> cityAnimals: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;🐦&quot;</span>, <span class="string">&quot;🐭&quot;</span>]</span><br><span class="line"></span><br><span class="line">houseAnimals.isSubset(of: farmAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">farmAnimals.isSuperset(of: houseAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">farmAnimals.isDisjoint(with: cityAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h3><p>字典类型储存键值对，字典类型是无序的。每一个值对应一个唯一的键。</p>
<p>声明一个 Dictionary 使用 <code>Dictionary&lt;Key, Value&gt;</code>。但是可以简写为 <code>[Key: Value]</code> 形式。建议使用简写。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> namesOfIntegers <span class="operator">=</span> [<span class="type">Int</span>: <span class="type">String</span>]()</span><br><span class="line"><span class="comment">// namesOfIntegers is an empty [Int: String] dictionary</span></span><br></pre></td></tr></table></figure>

<p>可以使用 <code>[:]</code> 初始化一个现有的字典类型而不需要提供类型信息。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">namesOfIntegers[<span class="number">16</span>] <span class="operator">=</span> <span class="string">&quot;sixteen&quot;</span></span><br><span class="line"><span class="comment">// namesOfIntegers now contains 1 key-value pair</span></span><br><span class="line">namesOfIntegers <span class="operator">=</span> [:]</span><br><span class="line"><span class="comment">// namesOfIntegers is once again an empty dictionary of type [Int: String]</span></span><br></pre></td></tr></table></figure>

<p>字面量创建一个字典类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> airports: [<span class="type">String</span>: <span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;YYZ&quot;</span>: <span class="string">&quot;Toronto Pearson&quot;</span>, <span class="string">&quot;DUB&quot;</span>: <span class="string">&quot;Dublin&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>字面量的信息足够 Swift 推测类型，所以这时类型信息是可以省略的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> airports <span class="operator">=</span> [<span class="string">&quot;YYZ&quot;</span>: <span class="string">&quot;Toronto Pearson&quot;</span>, <span class="string">&quot;DUB&quot;</span>: <span class="string">&quot;Dublin&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>拿字典信息的长度、判断非空与 Array 和 Set 一致。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The airports dictionary contains <span class="subst">\(airports.count)</span> items.&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The airports dictionary contains 2 items.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> airports.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The airports dictionary is empty.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The airports dictionary is not empty.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The airports dictionary is not empty.&quot;</span></span><br></pre></td></tr></table></figure>

<p>插入元素和修改元素操作一致，提供一个 key 然后赋值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">airports[<span class="string">&quot;LHR&quot;</span>] <span class="operator">=</span> <span class="string">&quot;London&quot;</span></span><br><span class="line"><span class="comment">// the airports dictionary now contains 3 items</span></span><br><span class="line"></span><br><span class="line">airports[<span class="string">&quot;LHR&quot;</span>] <span class="operator">=</span> <span class="string">&quot;London Heathrow&quot;</span></span><br><span class="line"><span class="comment">// the value for &quot;LHR&quot; has been changed to &quot;London Heathrow&quot;</span></span><br></pre></td></tr></table></figure>

<p>除了下标操作之外，<code>updateValue(_:forKey:)</code> 方法提供同样的能力，可以用来添加和更新元素，不同之处在于它会返回旧的值，这样可以方便检查一个修改是否发生。它会在存在值的情况下更新新的值并返回旧的值，在不存在值的情况下添加新的值但是返回 <code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> oldValue <span class="operator">=</span> airports.updateValue(<span class="string">&quot;Dublin Airport&quot;</span>, forKey: <span class="string">&quot;DUB&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The old value for DUB was <span class="subst">\(oldValue)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The old value for DUB was Dublin.&quot;</span></span><br></pre></td></tr></table></figure>

<p>下面的方式可以简单的判断对应一个 key 是否存在值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> airportName <span class="operator">=</span> airports[<span class="string">&quot;DUB&quot;</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The name of the airport is <span class="subst">\(airportName)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;That airport is not in the airports dictionary.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The name of the airport is Dublin Airport.&quot;</span></span><br></pre></td></tr></table></figure>

<p>将 <code>nil</code> 赋值给一个 key 来移除一个值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">airports[<span class="string">&quot;APL&quot;</span>] <span class="operator">=</span> <span class="string">&quot;Apple International&quot;</span></span><br><span class="line"><span class="comment">// &quot;Apple International&quot; is not the real airport for APL, so delete it</span></span><br><span class="line">airports[<span class="string">&quot;APL&quot;</span>] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// APL has now been removed from the dictionary</span></span><br></pre></td></tr></table></figure>

<p>下面是 OOP 的方式去移除一个字典类型的值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedValue <span class="operator">=</span> airports.removeValue(forKey: <span class="string">&quot;DUB&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The removed airport&#x27;s name is <span class="subst">\(removedValue)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The airports dictionary does not contain a value for DUB.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The removed airport&#x27;s name is Dublin Airport.&quot;</span></span><br></pre></td></tr></table></figure>

<p>for-in 直接遍历字典类型，注意用两个参数分别接收 key 和 value。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (airportCode, airportName) <span class="keyword">in</span> airports &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(airportCode)</span>: <span class="subst">\(airportName)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// YYZ: Toronto Pearson</span></span><br><span class="line"><span class="comment">// LHR: London Heathrow</span></span><br></pre></td></tr></table></figure>

<p>或者你可以仅遍历 key 或 value。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> airportCode <span class="keyword">in</span> airports.keys &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Airport code: <span class="subst">\(airportCode)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Airport code: YYZ</span></span><br><span class="line"><span class="comment">// Airport code: LHR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> airportName <span class="keyword">in</span> airports.values &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Airport name: <span class="subst">\(airportName)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Airport name: Toronto Pearson</span></span><br><span class="line"><span class="comment">// Airport name: London Heathrow</span></span><br></pre></td></tr></table></figure>

<p>可以把字典类型的 key 或者 value 单独输出一个 Array。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> airportCodes <span class="operator">=</span> [<span class="type">String</span>](airports.keys)</span><br><span class="line"><span class="comment">// airportCodes is [&quot;YYZ&quot;, &quot;LHR&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> airportNames <span class="operator">=</span> [<span class="type">String</span>](airports.values)</span><br><span class="line"><span class="comment">// airportNames is [&quot;Toronto Pearson&quot;, &quot;London Heathrow&quot;]</span></span><br></pre></td></tr></table></figure>

<p>不过由于字典类型是无序的，要保证输出的顺序每次都一致的话，需要执行 <code>.sorted()</code> 方法。</p>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>12.<a href="https://github.com/zfanli/notes/blob/master/swift/12.StringsAndCharacters.md">Swift Strings and Characters</a></p>
<p>14.<a href="https://github.com/zfanli/notes/blob/master/swift/14.ControlFlow.md">Swift Control Flow</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>14.Swift Control Flow</title>
    <url>/post/notes/swift/14-ControlFlow/</url>
    <content><![CDATA[<p>流程控制语句：</p>
<ul>
<li>for-in</li>
<li>while</li>
<li>guard</li>
<li>switch</li>
<li>if</li>
</ul>
<p>其他关键字：</p>
<ul>
<li>continue</li>
<li>break</li>
<li>fallthrough</li>
<li>return</li>
<li>throw</li>
</ul>
<span id="more"></span>

<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="For-In-循环"><a href="#For-In-循环" class="headerlink" title="For-In 循环"></a>For-In 循环</h3><p>for-in 循环可以应对大多循环序列、数字、范围的场景。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Brian&quot;</span>, <span class="string">&quot;Jack&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hello, Anna!</span></span><br><span class="line"><span class="comment">// Hello, Alex!</span></span><br><span class="line"><span class="comment">// Hello, Brian!</span></span><br><span class="line"><span class="comment">// Hello, Jack!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numberOfLegs <span class="operator">=</span> [<span class="string">&quot;spider&quot;</span>: <span class="number">8</span>, <span class="string">&quot;ant&quot;</span>: <span class="number">6</span>, <span class="string">&quot;cat&quot;</span>: <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> (animalName, legCount) <span class="keyword">in</span> numberOfLegs &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(animalName)</span>s have <span class="subst">\(legCount)</span> legs&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ants have 6 legs</span></span><br><span class="line"><span class="comment">// cats have 4 legs</span></span><br><span class="line"><span class="comment">// spiders have 8 legs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(index)</span> times 5 is <span class="subst">\(index <span class="operator">*</span> <span class="number">5</span>)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 times 5 is 5</span></span><br><span class="line"><span class="comment">// 2 times 5 is 10</span></span><br><span class="line"><span class="comment">// 3 times 5 is 15</span></span><br><span class="line"><span class="comment">// 4 times 5 is 20</span></span><br><span class="line"><span class="comment">// 5 times 5 is 25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> minutes <span class="operator">=</span> <span class="number">60</span></span><br><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>minutes &#123;</span><br><span class="line">    <span class="comment">// render the tick mark each minute (60 times)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只需要循环次数而不需要值可以用下划线标注参数名。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> base <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> power <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> answer <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span>power &#123;</span><br><span class="line">    answer <span class="operator">*=</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(base)</span> to the power of <span class="subst">\(power)</span> is <span class="subst">\(answer)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;3 to the power of 10 is 59049&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>stride(from:to:by:)</code> 提供更灵活的范围，可以设定步长。下面时间从 0 开始到指定时间内每隔 5 分钟处理一次。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> minuteInterval <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0</span>, to: minutes, by: minuteInterval) &#123;</span><br><span class="line">    <span class="comment">// render the tick mark every 5 minutes (0, 5, 10, 15 ... 45, 50, 55)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>to</code> 是不包含在内的，如需包含可以使用 <code>through</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hours <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> hourInterval <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">3</span>, through: hours, by: hourInterval) &#123;</span><br><span class="line">    <span class="comment">// render the tick mark every 3 hours (3, 6, 9, 12)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="While-循环"><a href="#While-循环" class="headerlink" title="While 循环"></a>While 循环</h3><p>做一些变量准备。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> finalSquare <span class="operator">=</span> <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> board <span class="operator">=</span> [<span class="type">Int</span>](repeating: <span class="number">0</span>, count: finalSquare <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">board[<span class="number">03</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">08</span>; board[<span class="number">06</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">11</span>; board[<span class="number">09</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">09</span>; board[<span class="number">10</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">02</span></span><br><span class="line">board[<span class="number">14</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">10</span>; board[<span class="number">19</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">11</span>; board[<span class="number">22</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">02</span>; board[<span class="number">24</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">08</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> square <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> diceRoll <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> square <span class="operator">&lt;</span> finalSquare &#123;</span><br><span class="line">    <span class="comment">// roll the dice</span></span><br><span class="line">    diceRoll <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> diceRoll <span class="operator">==</span> <span class="number">7</span> &#123; diceRoll <span class="operator">=</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="comment">// move by the rolled amount</span></span><br><span class="line">    square <span class="operator">+=</span> diceRoll</span><br><span class="line">    <span class="keyword">if</span> square <span class="operator">&lt;</span> board.count &#123;</span><br><span class="line">        <span class="comment">// if we&#x27;re still on the board, move up or down for a snake or a ladder</span></span><br><span class="line">        square <span class="operator">+=</span> board[square]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Game over!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Repeat-While-循环"><a href="#Repeat-While-循环" class="headerlink" title="Repeat-While 循环"></a>Repeat-While 循环</h3><p>至少做一次再判断条件。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    <span class="comment">// move up or down for a snake or ladder</span></span><br><span class="line">    square <span class="operator">+=</span> board[square]</span><br><span class="line">    <span class="comment">// roll the dice</span></span><br><span class="line">    diceRoll <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> diceRoll <span class="operator">==</span> <span class="number">7</span> &#123; diceRoll <span class="operator">=</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="comment">// move by the rolled amount</span></span><br><span class="line">    square <span class="operator">+=</span> diceRoll</span><br><span class="line">&#125; <span class="keyword">while</span> square <span class="operator">&lt;</span> finalSquare</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Game over!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="If-没什么好说的"><a href="#If-没什么好说的" class="headerlink" title="If 没什么好说的"></a>If 没什么好说的</h3><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p>没什么好说的。特殊点是当存在一个匹配值之后会直接跳出，不需要 break。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someCharacter: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;z&quot;</span></span><br><span class="line"><span class="keyword">switch</span> someCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The first letter of the alphabet&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;z&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The last letter of the alphabet&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Some other character&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The last letter of the alphabet&quot;</span></span><br></pre></td></tr></table></figure>

<p>多条件匹配。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherCharacter: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> anotherCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;a&quot;</span>, <span class="string">&quot;A&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The letter A&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not the letter A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The letter A&quot;</span></span><br></pre></td></tr></table></figure>

<p>case 可以做更多功能性匹配。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> approximateCount <span class="operator">=</span> <span class="number">62</span></span><br><span class="line"><span class="keyword">let</span> countedThings <span class="operator">=</span> <span class="string">&quot;moons orbiting Saturn&quot;</span></span><br><span class="line"><span class="keyword">let</span> naturalCount: <span class="type">String</span></span><br><span class="line"><span class="keyword">switch</span> approximateCount &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    naturalCount <span class="operator">=</span> <span class="string">&quot;no&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span><span class="operator">..&lt;</span><span class="number">5</span>:</span><br><span class="line">    naturalCount <span class="operator">=</span> <span class="string">&quot;a few&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span><span class="operator">..&lt;</span><span class="number">12</span>:</span><br><span class="line">    naturalCount <span class="operator">=</span> <span class="string">&quot;several&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span><span class="operator">..&lt;</span><span class="number">100</span>:</span><br><span class="line">    naturalCount <span class="operator">=</span> <span class="string">&quot;dozens of&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">100</span><span class="operator">..&lt;</span><span class="number">1000</span>:</span><br><span class="line">    naturalCount <span class="operator">=</span> <span class="string">&quot;hundreds of&quot;</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    naturalCount <span class="operator">=</span> <span class="string">&quot;many&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;There are <span class="subst">\(naturalCount)</span> <span class="subst">\(countedThings)</span>.&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;There are dozens of moons orbiting Saturn.&quot;</span></span><br></pre></td></tr></table></figure>

<p>元组也能匹配。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> somePoint <span class="operator">=</span> (<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> somePoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(somePoint)</span> is at the origin&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">_</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(somePoint)</span> is on the x-axis&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">_</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(somePoint)</span> is on the y-axis&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="operator">-</span><span class="number">2</span><span class="operator">...</span><span class="number">2</span>, <span class="operator">-</span><span class="number">2</span><span class="operator">...</span><span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(somePoint)</span> is inside the box&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(somePoint)</span> is outside of the box&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;(1, 1) is inside the box&quot;</span></span><br></pre></td></tr></table></figure>

<p>在符合条件的情况下还能绑定值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherPoint <span class="operator">=</span> (<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> anotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;on the x-axis with an x value of <span class="subst">\(x)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;on the y-axis with a y value of <span class="subst">\(y)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;somewhere else at (<span class="subst">\(x)</span>, <span class="subst">\(y)</span>)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;on the x-axis with an x value of 2&quot;</span></span><br></pre></td></tr></table></figure>

<p>用 where 关键字进行更灵活的操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yetAnotherPoint <span class="operator">=</span> (<span class="number">1</span>, <span class="operator">-</span><span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> yetAnotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x <span class="operator">==</span> y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == y&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x <span class="operator">==</span> <span class="operator">-</span>y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == -y&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is just some arbitrary point&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;(1, -1) is on the line x == -y&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="控制转换语句"><a href="#控制转换语句" class="headerlink" title="控制转换语句"></a>控制转换语句</h3><ul>
<li>continue</li>
<li>break</li>
<li>fallthrough</li>
<li>return</li>
<li>throw</li>
</ul>
<p>其他不多说。在 Switch 如果不想匹配一个就走，可以用 <code>fallthrough</code> 继续往后匹配。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> integerToDescribe <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> description <span class="operator">=</span> <span class="string">&quot;The number <span class="subst">\(integerToDescribe)</span> is&quot;</span></span><br><span class="line"><span class="keyword">switch</span> integerToDescribe &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>:</span><br><span class="line">    description <span class="operator">+=</span> <span class="string">&quot; a prime number, and also&quot;</span></span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    description <span class="operator">+=</span> <span class="string">&quot; an integer.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(description)</span><br><span class="line"><span class="comment">// Prints &quot;The number 5 is a prime number, and also an integer.&quot;</span></span><br></pre></td></tr></table></figure>

<p>在流程控制语句嵌套的情况下使用 continue 或者 break 时可以给流程控制加上标签来精准控制。下面语句中 Switch 中的 continue 和 break 对外层的 while 产生影响，而不是内层的 Switch。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">gameLoop: <span class="keyword">while</span> square <span class="operator">!=</span> finalSquare &#123;</span><br><span class="line">    diceRoll <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> diceRoll <span class="operator">==</span> <span class="number">7</span> &#123; diceRoll <span class="operator">=</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">switch</span> square <span class="operator">+</span> diceRoll &#123;</span><br><span class="line">    <span class="keyword">case</span> finalSquare:</span><br><span class="line">        <span class="comment">// diceRoll will move us to the final square, so the game is over</span></span><br><span class="line">        <span class="keyword">break</span> gameLoop</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> newSquare <span class="keyword">where</span> newSquare <span class="operator">&gt;</span> finalSquare:</span><br><span class="line">        <span class="comment">// diceRoll will move us beyond the final square, so roll again</span></span><br><span class="line">        <span class="keyword">continue</span> gameLoop</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// this is a valid move, so find out its effect</span></span><br><span class="line">        square <span class="operator">+=</span> diceRoll</span><br><span class="line">        square <span class="operator">+=</span> board[square]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Game over!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="检查-API-可用性"><a href="#检查-API-可用性" class="headerlink" title="检查 API 可用性"></a>检查 API 可用性</h3><p>下面的写法可以判断 API 的可用性，并且在不同情况下采取不同的措施。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">#available</span>(<span class="keyword">iOS</span> <span class="number">10</span>, <span class="keyword">macOS</span> <span class="number">10.12</span>, <span class="operator">*</span>) &#123;</span><br><span class="line">    <span class="comment">// Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Fall back to earlier iOS and macOS APIs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>13.<a href="https://github.com/zfanli/notes/blob/master/swift/13.CollectionTypes.md">Swift Collection Types</a></p>
<p>15.<a href="https://github.com/zfanli/notes/blob/master/swift/15.Functions.md">Swift Functions</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>15.Swift Functions</title>
    <url>/post/notes/swift/15-Functions/</url>
    <content><![CDATA[<p>基本就是复习。没新内容。</p>
<span id="more"></span>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>基础语法里面已经介绍了函数的基本。下面看几个例子复习下。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span>(<span class="params">person</span>: <span class="type">String</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">&quot;Anna&quot;</span>))</span><br><span class="line"><span class="comment">// Prints &quot;Hello, Anna!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">&quot;Brian&quot;</span>))</span><br><span class="line"><span class="comment">// Prints &quot;Hello, Brian!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greetAgain</span>(<span class="params">person</span>: <span class="type">String</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello again, &quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greetAgain(person: <span class="string">&quot;Anna&quot;</span>))</span><br><span class="line"><span class="comment">// Prints &quot;Hello again, Anna!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHelloWorld</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHelloWorld())</span><br><span class="line"><span class="comment">// Prints &quot;hello, world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span>(<span class="params">person</span>: <span class="type">String</span>, <span class="params">alreadyGreeted</span>: <span class="type">Bool</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> alreadyGreeted &#123;</span><br><span class="line">        <span class="keyword">return</span> greetAgain(person: person)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> greet(person: person)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">&quot;Tim&quot;</span>, alreadyGreeted: <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// Prints &quot;Hello again, Tim!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span>(<span class="params">person</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(person)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">greet(person: <span class="string">&quot;Dave&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Hello, Dave!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMax</span>(<span class="params">array</span>: [<span class="type">Int</span>])</span> -&gt; (min: <span class="type">Int</span>, max: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentMin <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span><span class="operator">..&lt;</span>array.count] &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">&lt;</span> currentMin &#123;</span><br><span class="line">            currentMin <span class="operator">=</span> value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value <span class="operator">&gt;</span> currentMax &#123;</span><br><span class="line">            currentMax <span class="operator">=</span> value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bounds <span class="operator">=</span> minMax(array: [<span class="number">8</span>, <span class="operator">-</span><span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;min is <span class="subst">\(bounds.min)</span> and max is <span class="subst">\(bounds.max)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;min is -6 and max is 109&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMax</span>(<span class="params">array</span>: [<span class="type">Int</span>])</span> -&gt; (min: <span class="type">Int</span>, max: <span class="type">Int</span>)<span class="operator">?</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> array.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> currentMin <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span><span class="operator">..&lt;</span>array.count] &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">&lt;</span> currentMin &#123;</span><br><span class="line">            currentMin <span class="operator">=</span> value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value <span class="operator">&gt;</span> currentMax &#123;</span><br><span class="line">            currentMax <span class="operator">=</span> value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> bounds <span class="operator">=</span> minMax(array: [<span class="number">8</span>, <span class="operator">-</span><span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>]) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;min is <span class="subst">\(bounds.min)</span> and max is <span class="subst">\(bounds.max)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;min is -6 and max is 109&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>(<span class="params">firstParameterName</span>: <span class="type">Int</span>, <span class="params">secondParameterName</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// In the function body, firstParameterName and secondParameterName</span></span><br><span class="line">    <span class="comment">// refer to the argument values for the first and second parameters.</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(firstParameterName: <span class="number">1</span>, secondParameterName: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>(<span class="params">argumentLabel</span> <span class="params">parameterName</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// In the function body, parameterName refers to the argument value</span></span><br><span class="line">    <span class="comment">// for that parameter.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span>(<span class="params">person</span>: <span class="type">String</span>, <span class="params">from</span> <span class="params">hometown</span>: <span class="type">String</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello <span class="subst">\(person)</span>!  Glad you could visit from <span class="subst">\(hometown)</span>.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">&quot;Bill&quot;</span>, from: <span class="string">&quot;Cupertino&quot;</span>))</span><br><span class="line"><span class="comment">// Prints &quot;Hello Bill!  Glad you could visit from Cupertino.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>(<span class="keyword">_</span> <span class="params">firstParameterName</span>: <span class="type">Int</span>, <span class="params">secondParameterName</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// In the function body, firstParameterName and secondParameterName</span></span><br><span class="line">    <span class="comment">// refer to the argument values for the first and second parameters.</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(<span class="number">1</span>, secondParameterName: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>(<span class="params">parameterWithoutDefault</span>: <span class="type">Int</span>, <span class="params">parameterWithDefault</span>: <span class="type">Int</span> <span class="operator">=</span> <span class="number">12</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// If you omit the second argument when calling this function, then</span></span><br><span class="line">    <span class="comment">// the value of parameterWithDefault is 12 inside the function body.</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(parameterWithoutDefault: <span class="number">3</span>, parameterWithDefault: <span class="number">6</span>) <span class="comment">// parameterWithDefault is 6</span></span><br><span class="line">someFunction(parameterWithoutDefault: <span class="number">4</span>) <span class="comment">// parameterWithDefault is 12</span></span><br></pre></td></tr></table></figure>

<p>复习结束。</p>
<p>下面是可变参数，之前貌似没提到。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arithmeticMean</span>(<span class="keyword">_</span> <span class="params">numbers</span>: <span class="type">Double</span>...)</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        total <span class="operator">+=</span> number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total <span class="operator">/</span> <span class="type">Double</span>(numbers.count)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// returns 3.0, which is the arithmetic mean of these five numbers</span></span><br><span class="line">arithmeticMean(<span class="number">3</span>, <span class="number">8.25</span>, <span class="number">18.75</span>)</span><br><span class="line"><span class="comment">// returns 10.0, which is the arithmetic mean of these three numbers</span></span><br></pre></td></tr></table></figure>

<p>inout 关键字设定一个参数是可以被改变的。通常情况下函数内部修改传递的参数是会报错的，但是有时会遇到需要修改传进来的参数的场景，此时使用 inout 定一个一个参数标记其可以在函数内部被修改，并且在调用函数的时候相应的变量名前面需要加上 <code>&amp;</code> 标识符。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt <span class="operator">=</span> <span class="number">107</span></span><br><span class="line">swapTwoInts(<span class="operator">&amp;</span>someInt, <span class="operator">&amp;</span>anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;someInt is now 107, and anotherInt is now 3&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>下面的函数类型都是 <code>(Int, Int) -&gt; Int</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiplyTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">*</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他应用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mathFunction: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="operator">=</span> addTwoInts</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(<span class="number">2</span>, <span class="number">3</span>))</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Result: 5&quot;</span></span><br><span class="line"></span><br><span class="line">mathFunction <span class="operator">=</span> multiplyTwoInts</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(<span class="number">2</span>, <span class="number">3</span>))</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Result: 6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMathResult</span>(<span class="keyword">_</span> <span class="params">mathFunction</span>: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(a, b))</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Result: 8&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepForward</span>(<span class="keyword">_</span> <span class="params">input</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepBackward</span>(<span class="keyword">_</span> <span class="params">input</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseStepFunction</span>(<span class="params">backward</span>: <span class="type">Bool</span>)</span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> backward <span class="operator">?</span> stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数可嵌套。</p>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>14.<a href="https://github.com/zfanli/notes/blob/master/swift/14.ControlFlow.md">Swift Control Flow</a></p>
<p>16.<a href="https://github.com/zfanli/notes/blob/master/swift/16.CLosures.md">Swift Closures</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>16.Swift Closure</title>
    <url>/post/notes/swift/16-Closures/</url>
    <content><![CDATA[<p>闭包没多少内容。新东西是 <code>@excaping</code> 和 <code>@autoclosure</code> 自动闭包。</p>
<span id="more"></span>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reversedNames <span class="operator">=</span> names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>简洁写法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125; )</span><br><span class="line"></span><br><span class="line">reversedNames <span class="operator">=</span> names.sorted() &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br><span class="line"></span><br><span class="line">reversedNames <span class="operator">=</span> names.sorted &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>用操作符方法可以更简单。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: <span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h3><p>这又是一个新东西。</p>
<p>闭包可以作为一个参数传递给一个函数或者一个方法。但是这个参数只能在函数内使用，在一些场景中我们需要把传递进来的闭包参数放到一个全局的数组中储存，并且在之后的某个时间点调用，此时需要 <code>@excaping</code> 关键字标注，否则会得到一个编译错误。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span>(<span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithNonescapingClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span>()</span> &#123;</span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x <span class="operator">=</span> <span class="number">100</span> &#125;</span><br><span class="line">        someFunctionWithNonescapingClosure &#123; x <span class="operator">=</span> <span class="number">200</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance <span class="operator">=</span> <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// Prints &quot;200&quot;</span></span><br><span class="line"></span><br><span class="line">completionHandlers.first<span class="operator">?</span>()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// Prints &quot;100&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// Prints &quot;5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> customerProvider <span class="operator">=</span> &#123; customersInLine.remove(at: <span class="number">0</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// Prints &quot;5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Now serving Chris!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// Prints &quot;4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: () -&gt; <span class="type">String</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: &#123; customersInLine.remove(at: <span class="number">0</span>) &#125; )</span><br><span class="line"><span class="comment">// Prints &quot;Now serving Alex!&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面的情况可以使用 <code>@autoclosure</code> 自动封装闭包。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"><span class="comment">// Prints &quot;Now serving Ewa!&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以一起用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">var</span> customerProviders: [() -&gt; <span class="type">String</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectCustomerProviders</span>(<span class="keyword">_</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> <span class="keyword">@escaping</span> () -&gt; <span class="type">String</span>)</span> &#123;</span><br><span class="line">    customerProviders.append(customerProvider)</span><br><span class="line">&#125;</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Collected <span class="subst">\(customerProviders.count)</span> closures.&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Collected 2 closures.&quot;</span></span><br><span class="line"><span class="keyword">for</span> customerProvider <span class="keyword">in</span> customerProviders &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Now serving Barry!&quot;</span></span><br><span class="line"><span class="comment">// Prints &quot;Now serving Daniella!&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>15.<a href="https://github.com/zfanli/notes/blob/master/swift/15.Functions.md">Swift Functions</a></p>
<p>17.<a href="https://github.com/zfanli/notes/blob/master/swift/17.EnumeratesStructsClasses.md">Swift Enumerates &amp; Structs &amp; Classes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>17.Swift Enumerates &amp; Structs &amp; Classes</title>
    <url>/post/notes/swift/17-EnumeratesStructsClasses/</url>
    <content><![CDATA[<p>依旧是复习。新点只有一个递归枚举和关键字 <code>indirect</code>。</p>
<span id="more"></span>

<h2 id="枚举类型、结构体、类"><a href="#枚举类型、结构体、类" class="headerlink" title="枚举类型、结构体、类"></a>枚举类型、结构体、类</h2><p>这三个放一起。</p>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>复习内容。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// enumeration definition goes here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north</span><br><span class="line">    <span class="keyword">case</span> south</span><br><span class="line">    <span class="keyword">case</span> east</span><br><span class="line">    <span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> mercury, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>赋值一个枚举类型实例对象。类型如果可以被推测出来，可以省略枚举类型主体。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> directionToHead <span class="operator">=</span> <span class="type">CompassPoint</span>.west</span><br><span class="line"></span><br><span class="line">directionToHead <span class="operator">=</span> .east</span><br></pre></td></tr></table></figure>

<p>用 Switch 处理枚举类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">directionToHead <span class="operator">=</span> .south</span><br><span class="line"><span class="keyword">switch</span> directionToHead &#123;</span><br><span class="line"><span class="keyword">case</span> .north:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Lots of planets have a north&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .south:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Watch out for penguins&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .east:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Where the sun rises&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .west:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Where the skies are blue&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Watch out for penguins&quot;</span></span><br></pre></td></tr></table></figure>

<p>遍历枚举类型需要几个步骤。首先要扩展 <code>CaseIterable</code> 协议。这样枚举类型会多出几个方法。然后使用 <code>.allCases</code> 进行遍历。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Beverage</span>: <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> coffee, tea, juice</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numberOfChoices <span class="operator">=</span> <span class="type">Beverage</span>.allCases.count</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(numberOfChoices)</span> beverages available&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;3 beverages available&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> beverage <span class="keyword">in</span> <span class="type">Beverage</span>.allCases &#123;</span><br><span class="line">    <span class="built_in">print</span>(beverage)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// coffee</span></span><br><span class="line"><span class="comment">// tea</span></span><br><span class="line"><span class="comment">// juice</span></span><br></pre></td></tr></table></figure>

<p>枚举类型可以有关联值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> upc(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> qrCode(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> productBarcode <span class="operator">=</span> <span class="type">Barcode</span>.upc(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">productBarcode <span class="operator">=</span> .qrCode(<span class="string">&quot;ABCDEFGHIJKLMNOP&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>用 Switch 处理这些关联值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> .upc(<span class="keyword">let</span> numberSystem, <span class="keyword">let</span> manufacturer, <span class="keyword">let</span> product, <span class="keyword">let</span> check):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;UPC: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .qrCode(<span class="keyword">let</span> productCode):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;QR code: <span class="subst">\(productCode)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;QR code: ABCDEFGHIJKLMNOP.&quot;</span></span><br></pre></td></tr></table></figure>

<p>变量比较多时 <code>let</code> 需要写很多次，比较麻烦。可以按下面简写。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .upc(numberSystem, manufacturer, product, check):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;UPC : <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .qrCode(productCode):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;QR code: <span class="subst">\(productCode)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;QR code: ABCDEFGHIJKLMNOP.&quot;</span></span><br></pre></td></tr></table></figure>

<p>储存原始值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASCIIControlCharacter</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> tab <span class="operator">=</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> lineFeed <span class="operator">=</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> carriageReturn <span class="operator">=</span> <span class="string">&quot;<span class="subst">\r</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> mercury <span class="operator">=</span> <span class="number">1</span>, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north, south, east, west</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> earthsOrder <span class="operator">=</span> <span class="type">Planet</span>.earth.rawValue</span><br><span class="line"><span class="comment">// earthsOrder is 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sunsetDirection <span class="operator">=</span> <span class="type">CompassPoint</span>.west.rawValue</span><br><span class="line"><span class="comment">// sunsetDirection is &quot;west&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> possiblePlanet <span class="operator">=</span> <span class="type">Planet</span>(rawValue: <span class="number">7</span>)</span><br><span class="line"><span class="comment">// possiblePlanet is of type Planet? and equals Planet.uranus</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> positionToFind <span class="operator">=</span> <span class="number">11</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> somePlanet <span class="operator">=</span> <span class="type">Planet</span>(rawValue: positionToFind) &#123;</span><br><span class="line">    <span class="keyword">switch</span> somePlanet &#123;</span><br><span class="line">    <span class="keyword">case</span> .earth:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Mostly harmless&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Not a safe place for humans&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;There isn&#x27;t a planet at position <span class="subst">\(positionToFind)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;There isn&#x27;t a planet at position 11&quot;</span></span><br></pre></td></tr></table></figure>

<p>递归枚举是一个枚举类型的 case 的关联值是自身的一个实例，需要提示关键词 <code>indirect</code> 告诉编译器递归枚举。下面两种写法都可以。注意关键词的位置。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> addition(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> addition(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对这个枚举的一个应用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> five <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.number(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> four <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.number(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> sum <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.addition(five, four)</span><br><span class="line"><span class="keyword">let</span> product <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.multiplication(sum, <span class="type">ArithmeticExpression</span>.number(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evaluate</span>(<span class="keyword">_</span> <span class="params">expression</span>: <span class="type">ArithmeticExpression</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> expression &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .number(value):</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .addition(left, right):</span><br><span class="line">        <span class="keyword">return</span> evaluate(left) <span class="operator">+</span> evaluate(right)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .multiplication(left, right):</span><br><span class="line">        <span class="keyword">return</span> evaluate(left) <span class="operator">*</span> evaluate(right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(evaluate(product))</span><br><span class="line"><span class="comment">// Prints &quot;18&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h3><p>复习内容。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">    <span class="comment">// structure definition goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class definition goes here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resolution <span class="operator">=</span> <span class="type">Resolution</span>()</span><br><span class="line">    <span class="keyword">var</span> interlaced <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> frameRate <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someResolution <span class="operator">=</span> <span class="type">Resolution</span>()</span><br><span class="line"><span class="keyword">let</span> someVideoMode <span class="operator">=</span> <span class="type">VideoMode</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The width of someResolution is <span class="subst">\(someResolution.width)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The width of someResolution is 0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The width of someVideoMode is <span class="subst">\(someVideoMode.resolution.width)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The width of someVideoMode is 0&quot;</span></span><br><span class="line"></span><br><span class="line">someVideoMode.resolution.width <span class="operator">=</span> <span class="number">1280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The width of someVideoMode is now <span class="subst">\(someVideoMode.resolution.width)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The width of someVideoMode is now 1280&quot;</span></span><br></pre></td></tr></table></figure>

<p>按成员初始化一个结构体。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vga <span class="operator">=</span> <span class="type">Resolution</span>(width: <span class="number">640</span>, height: <span class="number">480</span>)</span><br></pre></td></tr></table></figure>

<p>枚举类型和结构体传递值，而类传递引用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north, south, east, west</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">turnNorth</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> .north</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> currentDirection <span class="operator">=</span> <span class="type">CompassPoint</span>.west</span><br><span class="line"><span class="keyword">let</span> rememberedDirection <span class="operator">=</span> currentDirection</span><br><span class="line">currentDirection.turnNorth()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The current direction is <span class="subst">\(currentDirection)</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The remembered direction is <span class="subst">\(rememberedDirection)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The current direction is north&quot;</span></span><br><span class="line"><span class="comment">// Prints &quot;The remembered direction is west&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tenEighty <span class="operator">=</span> <span class="type">VideoMode</span>()</span><br><span class="line">tenEighty.resolution <span class="operator">=</span> hd</span><br><span class="line">tenEighty.interlaced <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">tenEighty.name <span class="operator">=</span> <span class="string">&quot;1080i&quot;</span></span><br><span class="line">tenEighty.frameRate <span class="operator">=</span> <span class="number">25.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> alsoTenEighty <span class="operator">=</span> tenEighty</span><br><span class="line">alsoTenEighty.frameRate <span class="operator">=</span> <span class="number">30.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The frameRate property of tenEighty is now <span class="subst">\(tenEighty.frameRate)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The frameRate property of tenEighty is now 30.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>用类似 JS 的三等号操作符判断 2 个对象是否引用同一个对象。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> tenEighty <span class="operator">===</span> alsoTenEighty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>16.<a href="https://github.com/zfanli/notes/blob/master/swift/16.CLosures.md">Swift Closures</a></p>
<p>18.<a href="https://github.com/zfanli/notes/blob/master/swift/18.PropertiesAndMethods.md">Swift Properties and Methods</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>18.Swift Properties and Methods</title>
    <url>/post/notes/swift/18-PropertiesAndMethods/</url>
    <content><![CDATA[<p>复习内容。lazy 属性。</p>
<span id="more"></span>

<h2 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h2><p>复习内容。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>一般的属性不用多说了，就是给对象储存值，来看看值得一看的。</p>
<p>lazy 属性。直到第一次使用时才进行初始化。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataImporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    DataImporter is a class to import data from an external file.</span></span><br><span class="line"><span class="comment">    The class is assumed to take a nontrivial amount of time to initialize.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> filename <span class="operator">=</span> <span class="string">&quot;data.txt&quot;</span></span><br><span class="line">    <span class="comment">// the DataImporter class would provide data importing functionality here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> importer <span class="operator">=</span> <span class="type">DataImporter</span>()</span><br><span class="line">    <span class="keyword">var</span> data <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line">    <span class="comment">// the DataManager class would provide data management functionality here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager <span class="operator">=</span> <span class="type">DataManager</span>()</span><br><span class="line">manager.data.append(<span class="string">&quot;Some data&quot;</span>)</span><br><span class="line">manager.data.append(<span class="string">&quot;Some more data&quot;</span>)</span><br><span class="line"><span class="comment">// the DataImporter instance for the importer property has not yet been created</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(manager.importer.filename)</span><br><span class="line"><span class="comment">// the DataImporter instance for the importer property has now been created</span></span><br><span class="line"><span class="comment">// Prints &quot;data.txt&quot;</span></span><br></pre></td></tr></table></figure>

<p>计算属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX <span class="operator">=</span> origin.x <span class="operator">+</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY <span class="operator">=</span> origin.y <span class="operator">+</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newCenter) &#123;</span><br><span class="line">            origin.x <span class="operator">=</span> newCenter.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            origin.y <span class="operator">=</span> newCenter.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> square <span class="operator">=</span> <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>),</span><br><span class="line">                  size: <span class="type">Size</span>(width: <span class="number">10.0</span>, height: <span class="number">10.0</span>))</span><br><span class="line"><span class="keyword">let</span> initialSquareCenter <span class="operator">=</span> square.center</span><br><span class="line">square.center <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">15.0</span>, y: <span class="number">15.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;square.origin is now at (<span class="subst">\(square.origin.x)</span>, <span class="subst">\(square.origin.y)</span>)&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;square.origin is now at (10.0, 10.0)&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果计算属性的 set 没有定义变量名，则使用默认的 <code>newValue</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlternativeRect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX <span class="operator">=</span> origin.x <span class="operator">+</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY <span class="operator">=</span> origin.y <span class="operator">+</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            origin.x <span class="operator">=</span> newValue.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            origin.y <span class="operator">=</span> newValue.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只读属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cuboid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span>, depth <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> volume: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width <span class="operator">*</span> height <span class="operator">*</span> depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fourByFiveByTwo <span class="operator">=</span> <span class="type">Cuboid</span>(width: <span class="number">4.0</span>, height: <span class="number">5.0</span>, depth: <span class="number">2.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the volume of fourByFiveByTwo is <span class="subst">\(fourByFiveByTwo.volume)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;the volume of fourByFiveByTwo is 40.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>监视属性可以使用 <code>willSet</code> 和 <code>didSet</code> 钩子。这很方便的可以在属性改变时做点什么。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StepCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> totalSteps: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span>(newTotalSteps) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;About to set totalSteps to <span class="subst">\(newTotalSteps)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> totalSteps <span class="operator">&gt;</span> oldValue  &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Added <span class="subst">\(totalSteps <span class="operator">-</span> oldValue)</span> steps&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stepCounter <span class="operator">=</span> <span class="type">StepCounter</span>()</span><br><span class="line">stepCounter.totalSteps <span class="operator">=</span> <span class="number">200</span></span><br><span class="line"><span class="comment">// About to set totalSteps to 200</span></span><br><span class="line"><span class="comment">// Added 200 steps</span></span><br><span class="line">stepCounter.totalSteps <span class="operator">=</span> <span class="number">360</span></span><br><span class="line"><span class="comment">// About to set totalSteps to 360</span></span><br><span class="line"><span class="comment">// Added 160 steps</span></span><br><span class="line">stepCounter.totalSteps <span class="operator">=</span> <span class="number">896</span></span><br><span class="line"><span class="comment">// About to set totalSteps to 896</span></span><br><span class="line"><span class="comment">// Added 536 steps</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：简单实现了 Java 的 AOP。从语言基础上加入了属性赋值生命周期。</p>
</blockquote>
<h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><p>上面我们谈到的都是实例属性。实例属性是属于实例自己的属性。每当你创建一个新的实例时，新的实例会设置自己的属性值，和其他的实例是分隔开的。</p>
<p>你也可以定义类型本身的属性，无论你创建多少个实例，这些属性都只会有一份。这些属性就是类型属性。</p>
<p>类型属性在设置所有实例可以访问的常量或者全局变量时十分有用。</p>
<p>普通类型属性可以是变量也可以是常量，但是类型计算属性只能是变量，和实例计算属性一样。</p>
<p>在定于类型属性时需要 <code>static</code> 关键字。对于类来说，类型属性不能被子类覆盖，你可以使用 <code>class</code> 关键字声明类型属性使其可以被子类覆盖。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty <span class="operator">=</span> <span class="string">&quot;Some value.&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty <span class="operator">=</span> <span class="string">&quot;Some value.&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty <span class="operator">=</span> <span class="string">&quot;Some value.&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">27</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">overrideableComputedTypeProperty</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">107</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型属性的查询和设置都是对类型操作，而不是实例。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)</span><br><span class="line"><span class="comment">// Prints &quot;Some value.&quot;</span></span><br><span class="line"><span class="type">SomeStructure</span>.storedTypeProperty <span class="operator">=</span> <span class="string">&quot;Another value.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)</span><br><span class="line"><span class="comment">// Prints &quot;Another value.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeEnumeration</span>.computedTypeProperty)</span><br><span class="line"><span class="comment">// Prints &quot;6&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeClass</span>.computedTypeProperty)</span><br><span class="line"><span class="comment">// Prints &quot;27&quot;</span></span><br></pre></td></tr></table></figure>

<p>下面的例子展示了一个 AudioChannel 类，储存了两个类型属性，一个表示最大值，一个表示用户输入的最大值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AudioChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> thresholdLevel <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> maxInputLevelForAllChannels <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> currentLevel: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> currentLevel <span class="operator">&gt;</span> <span class="type">AudioChannel</span>.thresholdLevel &#123;</span><br><span class="line">                <span class="comment">// cap the new audio level to the threshold level</span></span><br><span class="line">                currentLevel <span class="operator">=</span> <span class="type">AudioChannel</span>.thresholdLevel</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> currentLevel <span class="operator">&gt;</span> <span class="type">AudioChannel</span>.maxInputLevelForAllChannels &#123;</span><br><span class="line">                <span class="comment">// store this as the new overall maximum input level</span></span><br><span class="line">                <span class="type">AudioChannel</span>.maxInputLevelForAllChannels <span class="operator">=</span> currentLevel</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看看操作的例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> leftChannel <span class="operator">=</span> <span class="type">AudioChannel</span>()</span><br><span class="line"><span class="keyword">var</span> rightChannel <span class="operator">=</span> <span class="type">AudioChannel</span>()</span><br><span class="line"></span><br><span class="line">leftChannel.currentLevel <span class="operator">=</span> <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(leftChannel.currentLevel)</span><br><span class="line"><span class="comment">// Prints &quot;7&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">AudioChannel</span>.maxInputLevelForAllChannels)</span><br><span class="line"><span class="comment">// Prints &quot;7&quot;</span></span><br><span class="line"></span><br><span class="line">rightChannel.currentLevel <span class="operator">=</span> <span class="number">11</span></span><br><span class="line"><span class="built_in">print</span>(rightChannel.currentLevel)</span><br><span class="line"><span class="comment">// Prints &quot;10&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">AudioChannel</span>.maxInputLevelForAllChannels)</span><br><span class="line"><span class="comment">// Prints &quot;10&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>枚举、结构体、类都可以拥有方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">increment</span>()</span> &#123;</span><br><span class="line">        count <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">increment</span>(<span class="params">by</span> <span class="params">amount</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        count <span class="operator">+=</span> amount</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reset</span>()</span> &#123;</span><br><span class="line">        count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter <span class="operator">=</span> <span class="type">Counter</span>()</span><br><span class="line"><span class="comment">// the initial counter value is 0</span></span><br><span class="line">counter.increment()</span><br><span class="line"><span class="comment">// the counter&#x27;s value is now 1</span></span><br><span class="line">counter.increment(by: <span class="number">5</span>)</span><br><span class="line"><span class="comment">// the counter&#x27;s value is now 6</span></span><br><span class="line">counter.reset()</span><br><span class="line"><span class="comment">// the counter&#x27;s value is now 0</span></span><br></pre></td></tr></table></figure>

<p>枚举类型和结构体的方法默认不得修改自身数据，但是如果需要修改的时候可以加上关键字 <code>mutating</code> 解除限制。但只限于变量，常量是无法修改的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">moveBy</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Double</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        x <span class="operator">+=</span> deltaX</span><br><span class="line">        y <span class="operator">+=</span> deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> somePoint <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line">somePoint.moveBy(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The point is now at (<span class="subst">\(somePoint.x)</span>, <span class="subst">\(somePoint.y)</span>)&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The point is now at (3.0, 4.0)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fixedPoint <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">3.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line">fixedPoint.moveBy(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="comment">// this will report an error</span></span><br></pre></td></tr></table></figure>

<p>枚举类型自己处理自己。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TriStateSwitch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> off, low, high</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .off:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .low</span><br><span class="line">        <span class="keyword">case</span> .low:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .high</span><br><span class="line">        <span class="keyword">case</span> .high:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ovenLight <span class="operator">=</span> <span class="type">TriStateSwitch</span>.low</span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight is now equal to .high</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight is now equal to .off</span></span><br></pre></td></tr></table></figure>

<p>方法同样分实例方法和类型方法。实例方法是由实例调用，类型方法需要对类型操作。通常使用 <code>static</code> 关键字表示，类可以使用 <code>class</code> 关键字修饰 <code>func</code> 来让子类可以覆盖它。</p>
<blockquote>
<p>R：类似 Java 中的静态工具方法。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">someTypeMethod</span>() </span>&#123;</span><br><span class="line">        <span class="comment">// type method implementation goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SomeClass</span>.someTypeMethod()</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LevelTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> highestUnlockedLevel <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> currentLevel <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">unlock</span>(<span class="keyword">_</span> <span class="params">level</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> level <span class="operator">&gt;</span> highestUnlockedLevel &#123; highestUnlockedLevel <span class="operator">=</span> level &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">isUnlocked</span>(<span class="keyword">_</span> <span class="params">level</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> level <span class="operator">&lt;=</span> highestUnlockedLevel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">advance</span>(<span class="params">to</span> <span class="params">level</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">LevelTracker</span>.isUnlocked(level) &#123;</span><br><span class="line">            currentLevel <span class="operator">=</span> level</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>17.<a href="https://github.com/zfanli/notes/blob/master/swift/17.EnumeratesStructsClasses.md">Swift Enumerates &amp; Structs &amp; Classes</a></p>
<p>19.<a href="https://github.com/zfanli/notes/blob/master/swift/19.SubscriptsAndInheritance.md">Swift Subscripts and Inheritance</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>19.Swift Subscripts and Inheritance</title>
    <url>/post/notes/swift/19-SubscriptsAndInheritance/</url>
    <content><![CDATA[<p>在枚举类型、结构体、类中定义 <code>subscript</code> 方法可以让对象实现下标操作。然后继承又一个 <code>final</code> 关键字可以阻止复写。</p>
<span id="more"></span>

<h2 id="下标语法"><a href="#下标语法" class="headerlink" title="下标语法"></a>下标语法</h2><p>下标可以快速访问元素、列表或者序列。枚举类型、结构体、类都可以定义下标。</p>
<p>定义下标语法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subscript</span>(<span class="params">index</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="comment">// return an appropriate subscript value here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">        <span class="comment">// perform a suitable setting action here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是只读下标的例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TimesTable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> multiplier: <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">subscript</span>(<span class="params">index</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> multiplier <span class="operator">*</span> index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> threeTimesTable <span class="operator">=</span> <span class="type">TimesTable</span>(multiplier: <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;six times three is <span class="subst">\(threeTimesTable[<span class="number">6</span>])</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;six times three is 18&quot;</span></span><br></pre></td></tr></table></figure>

<p>下标可以带多个参数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rows: <span class="type">Int</span>, columns: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> grid: [<span class="type">Double</span>]</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">rows</span>: <span class="type">Int</span>, <span class="params">columns</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.rows <span class="operator">=</span> rows</span><br><span class="line">        <span class="keyword">self</span>.columns <span class="operator">=</span> columns</span><br><span class="line">        grid <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">0.0</span>, count: rows <span class="operator">*</span> columns)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">indexIsValid</span>(<span class="params">row</span>: <span class="type">Int</span>, <span class="params">column</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> row <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> row <span class="operator">&lt;</span> rows <span class="operator">&amp;&amp;</span> column <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> column <span class="operator">&lt;</span> columns</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">subscript</span>(<span class="params">row</span>: <span class="type">Int</span>, <span class="params">column</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValid(row: row, column: column), <span class="string">&quot;Index out of range&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> grid[(row <span class="operator">*</span> columns) <span class="operator">+</span> column]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValid(row: row, column: column), <span class="string">&quot;Index out of range&quot;</span>)</span><br><span class="line">            grid[(row <span class="operator">*</span> columns) <span class="operator">+</span> column] <span class="operator">=</span> newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matrix <span class="operator">=</span> <span class="type">Matrix</span>(rows: <span class="number">2</span>, columns: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">matrix[<span class="number">0</span>, <span class="number">1</span>] <span class="operator">=</span> <span class="number">1.5</span></span><br><span class="line">matrix[<span class="number">1</span>, <span class="number">0</span>] <span class="operator">=</span> <span class="number">3.2</span></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是类的特性，可以继承方法、属性或其他类的特征。</p>
<p>定义一个基类。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentSpeed <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;traveling at <span class="subst">\(currentSpeed)</span> miles per hour&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// do nothing - an arbitrary vehicle doesn&#x27;t necessarily make a noise</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someVehicle <span class="operator">=</span> <span class="type">Vehicle</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Vehicle: <span class="subst">\(someVehicle.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Vehicle: traveling at 0.0 miles per hour</span></span><br></pre></td></tr></table></figure>

<p>定义子类继承基类。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubclass</span>: <span class="title">SomeSuperclass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// subclass definition goes here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasBasket <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tandem</span>: <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentNumberOfPassengers <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tandem <span class="operator">=</span> <span class="type">Tandem</span>()</span><br><span class="line">tandem.hasBasket <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">tandem.currentNumberOfPassengers <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">tandem.currentSpeed <span class="operator">=</span> <span class="number">22.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Tandem: <span class="subst">\(tandem.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Tandem: traveling at 22.0 miles per hour</span></span><br></pre></td></tr></table></figure>

<p>复写父类的方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Train</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Choo Choo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> train <span class="operator">=</span> <span class="type">Train</span>()</span><br><span class="line">train.makeNoise()</span><br><span class="line"><span class="comment">// Prints &quot;Choo Choo&quot;</span></span><br></pre></td></tr></table></figure>

<p>复写变量的 setter 或 getter。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gear <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.description <span class="operator">+</span> <span class="string">&quot; in gear <span class="subst">\(gear)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car <span class="operator">=</span> <span class="type">Car</span>()</span><br><span class="line">car.currentSpeed <span class="operator">=</span> <span class="number">25.0</span></span><br><span class="line">car.gear <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Car: <span class="subst">\(car.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Car: traveling at 25.0 miles per hour in gear 3</span></span><br></pre></td></tr></table></figure>

<p>复写属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticCar</span>: <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> currentSpeed: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            gear <span class="operator">=</span> <span class="type">Int</span>(currentSpeed <span class="operator">/</span> <span class="number">10.0</span>) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> automatic <span class="operator">=</span> <span class="type">AutomaticCar</span>()</span><br><span class="line">automatic.currentSpeed <span class="operator">=</span> <span class="number">35.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;AutomaticCar: <span class="subst">\(automatic.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// AutomaticCar: traveling at 35.0 miles per hour in gear 4</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>final</code> 关键字可以防止复写。</p>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>18.<a href="https://github.com/zfanli/notes/blob/master/swift/18.PropertiesAndMethods.md">Swift Properties and Methods</a></p>
<p>20.<a href="https://github.com/zfanli/notes/blob/master/swift/20.InitializationAndDeinitialization.md">Swift Initialization and Deinitialization</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>2.Swift Syntax Basics (字符串和变量)</title>
    <url>/post/notes/swift/2-SyntaxBasics-Strings-Variables/</url>
    <content><![CDATA[<p>参考官网的教程。</p>
<p><a href="https://docs.swift.org/swift-book/GuidedTour/GuidedTour.html">https://docs.swift.org/swift-book/GuidedTour/GuidedTour.html</a></p>
<p>教程提供一个 Xcode 的 playground，可以边看教程边修改代码，同时预览结果，体验不错。</p>
<blockquote>
<p>R：体验虽好，就是没有浏览器的字典插件可以用了，macOS 自带的词典也用不了，查词比较麻烦。</p>
</blockquote>
<span id="more"></span>

<h2 id="“Hello-world-”"><a href="#“Hello-world-”" class="headerlink" title="“Hello, world!”"></a>“Hello, world!”</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Swift 的语法看上去类似 C 和 Objective-C。对于 input/output 或者字符串处理来说，不需要 import 任何库。写在全局作用域的代码自动成为程序的入口，你不需要类似 <code>main()</code> 的函数。你也不需要给每行都写上一个分号。</p>
<h2 id="Simple-Values"><a href="#Simple-Values" class="headerlink" title="Simple Values"></a>Simple Values</h2><p>使用 <code>let</code> 声明一个常量，使用 <code>var</code> 声明一个变量。</p>
<blockquote>
<p>R：感觉和 JavaScript 有点冲突啊。JavaScript 中 <code>var</code>、<code>let</code> 都用来声明变量，<code>const</code> 用来声明常量。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myVariable <span class="operator">=</span> <span class="number">42</span></span><br><span class="line">myVariable <span class="operator">=</span> <span class="number">50</span></span><br><span class="line"><span class="keyword">let</span> myConstant <span class="operator">=</span> <span class="number">42</span></span><br></pre></td></tr></table></figure>

<p>变量类型根据指定的值推测。但是如果没有指派值，或者赋予的值不足以推测类型，则需要显示声明类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> implicitInteger <span class="operator">=</span> <span class="number">70</span></span><br><span class="line"><span class="keyword">let</span> implicitDouble <span class="operator">=</span> <span class="number">70.0</span></span><br><span class="line"><span class="keyword">let</span> explicitDouble: <span class="type">Double</span> <span class="operator">=</span> <span class="number">70</span></span><br></pre></td></tr></table></figure>

<p>变量的值不会进行任何隐式的类型转换。如果你需要对数据进行类型转换，你必须手动来转换它。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> label <span class="operator">=</span> <span class="string">&quot;The width is &quot;</span></span><br><span class="line"><span class="keyword">let</span> width <span class="operator">=</span> <span class="number">94</span></span><br><span class="line"><span class="keyword">let</span> widthLabel <span class="operator">=</span> label <span class="operator">+</span> <span class="type">String</span>(width)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：手动移除掉 <code>String()</code> 转换方法后，将得到报错：<code>Binary operator &#39;+&#39; cannot be applied to operands of type &#39;String&#39; and &#39;Int&#39;</code></p>
</blockquote>
<p>模版字符串，带入变量的方式为反斜杠 <code>\</code> 加括号。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> apples <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> oranges <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> appleSummary <span class="operator">=</span> <span class="string">&quot;I have <span class="subst">\(apples)</span> apples.&quot;</span></span><br><span class="line"><span class="keyword">let</span> fruitSummary <span class="operator">=</span> <span class="string">&quot;I have <span class="subst">\(apples <span class="operator">+</span> oranges)</span> pieces of fruit.&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用三引号声明多行的文本。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> quotation <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">I said &quot;I have <span class="subst">\(apples)</span> apples.&quot;</span></span><br><span class="line"><span class="string">And then I said &quot;I have <span class="subst">\(apples <span class="operator">+</span> oranges)</span> pieces of fruit.&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>用中括号创建数组或字典，在中括号中写上 index 或者 key 来访问元素。最后一个元素也可以写逗号。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList <span class="operator">=</span> [<span class="string">&quot;catfish&quot;</span>, <span class="string">&quot;water&quot;</span>, <span class="string">&quot;tulips&quot;</span>]</span><br><span class="line">shoppingList[<span class="number">1</span>] <span class="operator">=</span> <span class="string">&quot;bottle of water&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> occupations <span class="operator">=</span> [</span><br><span class="line">    <span class="string">&quot;Malcolm&quot;</span>: <span class="string">&quot;Captain&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Kaylee&quot;</span>: <span class="string">&quot;Mechanic&quot;</span>,</span><br><span class="line"> ]</span><br><span class="line">occupations[<span class="string">&quot;Jayne&quot;</span>] <span class="operator">=</span> <span class="string">&quot;Public Relations&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：“最后一个元素也可以写逗号”，和 JavaScript、JSON 挺像。</p>
</blockquote>
<p>数组在添加元素时自动增长。</p>
<p>用下面初始化器语法创建一个空的数组或字典。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyArray <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line"><span class="keyword">let</span> emptyDictionary <span class="operator">=</span> [<span class="type">String</span>: <span class="type">Float</span>]()</span><br></pre></td></tr></table></figure>

<p>当类型可以被推导时，可以省略类型声明。比如在给一个变量重新赋值时，或者传递一个参数给某个函数时。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">shoppingList <span class="operator">=</span> []</span><br><span class="line">occupations <span class="operator">=</span> [:]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：给变量重新赋值时，之前的值会作为类型推导的信息。传递一个参数给某个函数时，函数接收的参数类型是确定的。所以这两种情况可以省略类型声明。</p>
</blockquote>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>1.<a href="https://github.com/zfanli/notes/blob/master/swift/1.SwiftIntroduction.md">Official Documentation - Introducing Swift 5</a></p>
<p>3.<a href="https://github.com/zfanli/notes/blob/master/swift/3.SyntaxBasics(FlowControl).md">Swift Syntax Basics (流程控制)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>21.Swift Optional Chaining</title>
    <url>/post/notes/swift/21-OptionalChaining/</url>
    <content><![CDATA[<p>可选型操作链（Optional Chaining）是为了应对查询或调用当前可能是 <code>nil</code> 的变量的属性、方法和下标时的一个处理。当这个变量有值时操作会成功，否则会返回 <code>nil</code>。多个查询或调用操作可以链接在一起。链上的每个操作返回 <code>nil</code> 时，操作就会结束并返回 <code>nil</code>。</p>
<span id="more"></span>

<h2 id="可选型操作链"><a href="#可选型操作链" class="headerlink" title="可选型操作链"></a>可选型操作链</h2><h3 id="可选型操作链作为强制解包（Forced-Unwrapping）的一个替代"><a href="#可选型操作链作为强制解包（Forced-Unwrapping）的一个替代" class="headerlink" title="可选型操作链作为强制解包（Forced Unwrapping）的一个替代"></a>可选型操作链作为强制解包（Forced Unwrapping）的一个替代</h3><p>在对象后面放一个 <code>?</code> 构成一个可选型操作链，表示你希望在非 <code>nil</code> 时访问对象的属性和方法。这和强制解包很相似，强制解包在变量后使用 <code>!</code> 表示，它们之间最大的区别在于当变量是 <code>nil</code> 时，可选型操作链会优雅地返回 <code>nil</code>，但是强制解包会触发一个运行时错误。</p>
<p>由于实际上可选型操作链可以对 <code>nil</code> 操作，所以无论链式操作的属性和方法是不是可选型类型的，其结果将必定是一个可能为 <code>nil</code> 的可选型类型。你可以使用可用型操作链来判断一个操作是否成功，如果成功就会得到一个值，反之则得到 <code>nil</code>。</p>
<p>由此需要注意，可选型操作链的返回结果应该是可选型的预期返回结果。比如如果预期返回 <code>Int</code> 类型数据，那么经过可选型操作链返回的结果应该是 <code>Int?</code>。</p>
<p>下面的例子展示了可选型操作链和强制解包的区别。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> residence: <span class="type">Residence</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Residence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfRooms <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义两个类，Person 有一个 Residence 实例作为属性，它是可选的，所以在实例化 Person 时它没有被初始化，它将是 <code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> john <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> roomCount <span class="operator">=</span> john.residence<span class="operator">!</span>.numberOfRooms</span><br><span class="line"><span class="comment">// this triggers a runtime error</span></span><br></pre></td></tr></table></figure>

<p>这是强制解包操作，它会触发一个运行时错误，原因是 john 的 residence 属性没有被初始化，还不能访问它的属性。使用可选型操作链可以处理这个情况。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount <span class="operator">=</span> john.residence<span class="operator">?</span>.numberOfRooms &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s residence has <span class="subst">\(roomCount)</span> room(s).&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the number of rooms.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Unable to retrieve the number of rooms.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">john.residence <span class="operator">=</span> <span class="type">Residence</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount <span class="operator">=</span> john.residence<span class="operator">?</span>.numberOfRooms &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s residence has <span class="subst">\(roomCount)</span> room(s).&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the number of rooms.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;John&#x27;s residence has 1 room(s).&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="定义模型类以展示可选型操作链的使用场景"><a href="#定义模型类以展示可选型操作链的使用场景" class="headerlink" title="定义模型类以展示可选型操作链的使用场景"></a>定义模型类以展示可选型操作链的使用场景</h3><p>下面对 Person 和 Residence 类进行重构，并添加 Room 和 Address 类。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> residence: <span class="type">Residence</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Residence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rooms <span class="operator">=</span> [<span class="type">Room</span>]()</span><br><span class="line">    <span class="keyword">var</span> numberOfRooms: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rooms.count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Room</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rooms[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            rooms[i] <span class="operator">=</span> newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printNumberOfRooms</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The number of rooms is <span class="subst">\(numberOfRooms)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> address: <span class="type">Address</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123; <span class="keyword">self</span>.name <span class="operator">=</span> name &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buildingName: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> buildingNumber: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> street: <span class="type">String</span>?</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buildingIdentifier</span>()</span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> buildingNumber <span class="operator">=</span> buildingNumber, <span class="keyword">let</span> street <span class="operator">=</span> street &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(buildingNumber)</span> <span class="subst">\(street)</span>&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> buildingName <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> buildingName</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的看一下它们的关系。Person 类不变，拥有一个可选型 Residence 属性。Residence 改变比较大，它将储存一个 Room 数组，因此 numberOfRooms 可以转变成一个计算属性。Residence 还实现了下标操作，还有一个方法用来打印房间数，同时它还有一个可选型的 Address 类型属性。</p>
<p>Room 类相对简单，它只有一个名称，并在初始化时赋值。Address 保有三个可选型的字符串属性储存不同信息，一个方法来在属性有值的情况下构建地址信息。</p>
<h3 id="用可选型操作链访问属性"><a href="#用可选型操作链访问属性" class="headerlink" title="用可选型操作链访问属性"></a>用可选型操作链访问属性</h3><p>可选型操作链访问属性，可以对执行成功与否进行判断。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> john <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount <span class="operator">=</span> john.residence<span class="operator">?</span>.numberOfRooms &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s residence has <span class="subst">\(roomCount)</span> room(s).&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the number of rooms.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Unable to retrieve the number of rooms.&quot;</span></span><br></pre></td></tr></table></figure>

<p>另一方面，可以对属性进行操作，如果访问的对象为 <code>nil</code>，那么操作不会成功，也不会报错。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someAddress <span class="operator">=</span> <span class="type">Address</span>()</span><br><span class="line">someAddress.buildingNumber <span class="operator">=</span> <span class="string">&quot;29&quot;</span></span><br><span class="line">someAddress.street <span class="operator">=</span> <span class="string">&quot;Acacia Road&quot;</span></span><br><span class="line">john.residence<span class="operator">?</span>.address <span class="operator">=</span> someAddress</span><br></pre></td></tr></table></figure>

<p>上面对 john 对操作会失败，因为此时 john 对 residence 属性仍未初始化。但是可能你不太能看出来右边是否有被执行，下面的代码对上面的操作进行了改写，如果右边被执行的话，会打印一段信息告诉你。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createAddress</span>()</span> -&gt; <span class="type">Address</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Function was called.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> someAddress <span class="operator">=</span> <span class="type">Address</span>()</span><br><span class="line">    someAddress.buildingNumber <span class="operator">=</span> <span class="string">&quot;29&quot;</span></span><br><span class="line">    someAddress.street <span class="operator">=</span> <span class="string">&quot;Acacia Road&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> someAddress</span><br><span class="line">&#125;</span><br><span class="line">john.residence<span class="operator">?</span>.address <span class="operator">=</span> createAddress()</span><br></pre></td></tr></table></figure>

<p>如果你执行了这段代码，你会知道，左边为 <code>nil</code> 时，右边的 <code>createAddress()</code> 实际上并没有被执行。</p>
<h3 id="用可选型操作链调用方法"><a href="#用可选型操作链调用方法" class="headerlink" title="用可选型操作链调用方法"></a>用可选型操作链调用方法</h3><p>你可以使用可选型操作链调用一个可选型变量的方法，并且判断方法是否调用成功了，即使这个方法不存在返回值。比如上面 Residence 的方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumberOfRooms</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The number of rooms is <span class="subst">\(numberOfRooms)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法没有返回值，但是实际上函数和方法有一个默认返回值 <code>Void</code>，表现为空元组 <code>()</code>。用可选型操作链执行这个方法，它的返回值将是 <code>Void?</code>。可以通过判断其是否返回 <code>nil</code> 来检查方法是否调用成功。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> john.residence<span class="operator">?</span>.printNumberOfRooms() <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was possible to print the number of rooms.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was not possible to print the number of rooms.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;It was not possible to print the number of rooms.&quot;</span></span><br></pre></td></tr></table></figure>

<p>这解释了上一节最后的例子。赋值操作的返回值应该是 <code>Void?</code>，所以能判断它是否执行成功。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (john.residence<span class="operator">?</span>.address <span class="operator">=</span> someAddress) <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was possible to set the address.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was not possible to set the address.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;It was not possible to set the address.&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用可选型操作链访问下标"><a href="#使用可选型操作链访问下标" class="headerlink" title="使用可选型操作链访问下标"></a>使用可选型操作链访问下标</h3><p>使用可选型操作链访问下标时要注意问号必须在变量名的后面，在下标的前面。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstRoomName <span class="operator">=</span> john.residence<span class="operator">?</span>[<span class="number">0</span>].name &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The first room name is <span class="subst">\(firstRoomName)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the first room name.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Unable to retrieve the first room name.&quot;</span></span><br></pre></td></tr></table></figure>

<p>你可以用下标赋值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">john.residence<span class="operator">?</span>[<span class="number">0</span>] <span class="operator">=</span> <span class="type">Room</span>(name: <span class="string">&quot;Bathroom&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> johnsHouse <span class="operator">=</span> <span class="type">Residence</span>()</span><br><span class="line">johnsHouse.rooms.append(<span class="type">Room</span>(name: <span class="string">&quot;Living Room&quot;</span>))</span><br><span class="line">johnsHouse.rooms.append(<span class="type">Room</span>(name: <span class="string">&quot;Kitchen&quot;</span>))</span><br><span class="line">john.residence <span class="operator">=</span> johnsHouse</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstRoomName <span class="operator">=</span> john.residence<span class="operator">?</span>[<span class="number">0</span>].name &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The first room name is <span class="subst">\(firstRoomName)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the first room name.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The first room name is Living Room.&quot;</span></span><br></pre></td></tr></table></figure>

<p>操作字典类型稍有不同。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testScores <span class="operator">=</span> [<span class="string">&quot;Dave&quot;</span>: [<span class="number">86</span>, <span class="number">82</span>, <span class="number">84</span>], <span class="string">&quot;Bev&quot;</span>: [<span class="number">79</span>, <span class="number">94</span>, <span class="number">81</span>]]</span><br><span class="line">testScores[<span class="string">&quot;Dave&quot;</span>]<span class="operator">?</span>[<span class="number">0</span>] <span class="operator">=</span> <span class="number">91</span></span><br><span class="line">testScores[<span class="string">&quot;Bev&quot;</span>]<span class="operator">?</span>[<span class="number">0</span>] <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">testScores[<span class="string">&quot;Brian&quot;</span>]<span class="operator">?</span>[<span class="number">0</span>] <span class="operator">=</span> <span class="number">72</span></span><br><span class="line"><span class="comment">// the &quot;Dave&quot; array is now [91, 82, 84] and the &quot;Bev&quot; array is now [80, 94, 81]</span></span><br></pre></td></tr></table></figure>

<h3 id="多级链"><a href="#多级链" class="headerlink" title="多级链"></a>多级链</h3><p>你可以链接很长一串操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> johnsStreet <span class="operator">=</span> john.residence<span class="operator">?</span>.address<span class="operator">?</span>.street &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s street name is <span class="subst">\(johnsStreet)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the address.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Unable to retrieve the address.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> johnsAddress <span class="operator">=</span> <span class="type">Address</span>()</span><br><span class="line">johnsAddress.buildingName <span class="operator">=</span> <span class="string">&quot;The Larches&quot;</span></span><br><span class="line">johnsAddress.street <span class="operator">=</span> <span class="string">&quot;Laurel Street&quot;</span></span><br><span class="line">john.residence<span class="operator">?</span>.address <span class="operator">=</span> johnsAddress</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> johnsStreet <span class="operator">=</span> john.residence<span class="operator">?</span>.address<span class="operator">?</span>.street &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s street name is <span class="subst">\(johnsStreet)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the address.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;John&#x27;s street name is Laurel Street.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> buildingIdentifier <span class="operator">=</span> john.residence<span class="operator">?</span>.address<span class="operator">?</span>.buildingIdentifier() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s building identifier is <span class="subst">\(buildingIdentifier)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;John&#x27;s building identifier is The Larches.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> beginsWithThe <span class="operator">=</span></span><br><span class="line">    john.residence<span class="operator">?</span>.address<span class="operator">?</span>.buildingIdentifier()<span class="operator">?</span>.hasPrefix(<span class="string">&quot;The&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> beginsWithThe &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s building identifier begins with <span class="subst">\&quot;</span>The<span class="subst">\&quot;</span>.&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s building identifier does not begin with <span class="subst">\&quot;</span>The<span class="subst">\&quot;</span>.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;John&#x27;s building identifier begins with &quot;The&quot;.&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>20.<a href="https://github.com/zfanli/notes/blob/master/swift/20.InitializationAndDeinitialization.md">Swift Initialization and Deinitialization</a></p>
<p>22.<a href="https://github.com/zfanli/notes/blob/master/swift/22.ErrorHandling.md">Swift Error Handling</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>22.Swift Error Handling</title>
    <url>/post/notes/swift/22-ErrorHandling/</url>
    <content><![CDATA[<p>这部分内容还是复习。对于错误处理可以抛出可以处理。对于抛出介绍了 <code>guard</code> 和 <code>throw</code>，处理介绍了 do-catch、<code>try?</code> 和 <code>try!</code> 方法。</p>
<p><code>defer</code> 方法可以保证无论代码什么时候离开当前作用域，都将执行一段清洁操作。</p>
<span id="more"></span>

<h2 id="Error-处理"><a href="#Error-处理" class="headerlink" title="Error 处理"></a>Error 处理</h2><p>不再赘述为什么要 Error 处理了。官方文档很明显是面对第一次学习编程语言的人的，用了三到四大段话描述为什么要 Error 处理…( ꒪Д꒪)</p>
<p>在 Swift 中定义一个 Error 类型只需要实现 Error 协议，这个协议是空的，只是一个身份象征。Swift 的枚举类型可以很合适的创建一个 Error 类型，他可以根据 Error 条件设计，并且可以附带关联值，可以方便的交流。下面是一个例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">VendingMachineError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> invalidSelection</span><br><span class="line">    <span class="keyword">case</span> insufficientFunds(coinsNeeded: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> outOfStock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当检查条件失败，使用 <code>throw</code> 抛出一个 Error。下面展示了如何抛出一个 Error，并且附带关联值，表示这个 Error 的原因是缺失 5 个硬币。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="type">VendingMachineError</span>.insufficientFunds(coinsNeeded: <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h3 id="使用抛出函数传播-Error"><a href="#使用抛出函数传播-Error" class="headerlink" title="使用抛出函数传播 Error"></a>使用抛出函数传播 Error</h3><p>为了指出一个函数、方法或初始化器可能会抛出 Error，你需要在定义它们的时候在参数后加上 <code>throws</code> 关键字。一个函数被标记了 <code>throws</code>，那么它就是一个抛出函数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canThrowErrors</span>()</span> <span class="keyword">throws</span> -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cannotThrowErrors</span>()</span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure>

<p>抛出函数可以将发生在其内部的 Error 向上抛给调用它的作用域。</p>
<blockquote>
<p>R：Error 的传播只能经由抛出函数向调用方抛出传播，如果 Error 发生在一个非抛出函数内，那么它必须在自己内部处理 Error。</p>
</blockquote>
<p>下面的例子中，VendingMachine 类有一个 <code>vend(itemNamed:)</code> 方法，在所选商品售罄或超过余额时会抛出 VendingMachineError Error。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> price: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inventory <span class="operator">=</span> [</span><br><span class="line">        <span class="string">&quot;Candy Bar&quot;</span>: <span class="type">Item</span>(price: <span class="number">12</span>, count: <span class="number">7</span>),</span><br><span class="line">        <span class="string">&quot;Chips&quot;</span>: <span class="type">Item</span>(price: <span class="number">10</span>, count: <span class="number">4</span>),</span><br><span class="line">        <span class="string">&quot;Pretzels&quot;</span>: <span class="type">Item</span>(price: <span class="number">7</span>, count: <span class="number">11</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">var</span> coinsDeposited <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">vend</span>(<span class="params">itemNamed</span> <span class="params">name</span>: <span class="type">String</span>)</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> item <span class="operator">=</span> inventory[name] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.invalidSelection</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> item.count <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.outOfStock</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> item.price <span class="operator">&lt;=</span> coinsDeposited <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.insufficientFunds(coinsNeeded: item.price <span class="operator">-</span> coinsDeposited)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        coinsDeposited <span class="operator">-=</span> item.price</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> newItem <span class="operator">=</span> item</span><br><span class="line">        newItem.count <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">        inventory[name] <span class="operator">=</span> newItem</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Dispensing <span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vend(itemNamed:)</code> 使用 <code>guard</code> 语句保证在任何一个要求不符合的情况下退出方法并抛出恰当的 Error。由于 <code>throw</code> 立刻转移程序控制，所以商品只会在满足全部条件的情况下被售出。</p>
<p><code>vend(itemNamed:)</code> 方法通过抛出的方式将 Error 传播出去了，所以调用它的地方必须采取两种措施。</p>
<ul>
<li>采用 do-catch，或者 <code>try?</code>、<code>try!</code> 的方式处理掉 Error；</li>
<li>或者继续传播 Error 到上一层。</li>
</ul>
<p>例如下面的例子中，<code>buyFavoriteSnack(person:vendingMachine:)</code> 方法将 Error 继续向上传播。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteSnacks <span class="operator">=</span> [</span><br><span class="line">    <span class="string">&quot;Alice&quot;</span>: <span class="string">&quot;Chips&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Bob&quot;</span>: <span class="string">&quot;Licorice&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Eve&quot;</span>: <span class="string">&quot;Pretzels&quot;</span>,</span><br><span class="line">]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buyFavoriteSnack</span>(<span class="params">person</span>: <span class="type">String</span>, <span class="params">vendingMachine</span>: <span class="type">VendingMachine</span>)</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> snackName <span class="operator">=</span> favoriteSnacks[person] <span class="operator">??</span> <span class="string">&quot;Candy Bar&quot;</span></span><br><span class="line">    <span class="keyword">try</span> vendingMachine.vend(itemNamed: snackName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面展示用初始化器抛出 Error，初始化器调用了一个可能抛出 Error 的方法，如果出现 Error，会自动向上抛出。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PurchasedSnack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">vendingMachine</span>: <span class="type">VendingMachine</span>)</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> vendingMachine.vend(itemNamed: name)</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-do-catch-处理-Error"><a href="#使用-do-catch-处理-Error" class="headerlink" title="使用 do-catch 处理 Error"></a>使用 do-catch 处理 Error</h3><p>do-catch 语法的构成如下。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> expression</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern <span class="number">1</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern <span class="number">2</span> <span class="keyword">where</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 do-catch 处理 Error。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vendingMachine <span class="operator">=</span> <span class="type">VendingMachine</span>()</span><br><span class="line">vendingMachine.coinsDeposited <span class="operator">=</span> <span class="number">8</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> buyFavoriteSnack(person: <span class="string">&quot;Alice&quot;</span>, vendingMachine: vendingMachine)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Success! Yum.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">VendingMachineError</span>.invalidSelection &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Invalid Selection.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">VendingMachineError</span>.outOfStock &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Out of Stock.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">VendingMachineError</span>.insufficientFunds(<span class="keyword">let</span> coinsNeeded) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Insufficient funds. Please insert an additional <span class="subst">\(coinsNeeded)</span> coins.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unexpected error: <span class="subst">\(error)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Insufficient funds. Please insert an additional 2 coins.&quot;</span></span><br></pre></td></tr></table></figure>

<p>do-catch 并不是必须处理所有的 Error，如果 do-catch 没有处理到的 Error 发生了，使用 <code>throws</code> 关键字标记函数可以将其向上传播。但是这个 Error 需要在上级的某个作用域中被处理掉，否则你会得到一个运行时报错。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nourish</span>(<span class="params">with</span> <span class="params">item</span>: <span class="type">String</span>)</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> vendingMachine.vend(itemNamed: item)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">is</span> <span class="type">VendingMachineError</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid selection, out of stock, or not enough money.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> nourish(with: <span class="string">&quot;Beet-Flavored Chips&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unexpected non-vending-machine-related error: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Invalid selection, out of stock, or not enough money.&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="将-Error-转化为可选值"><a href="#将-Error-转化为可选值" class="headerlink" title="将 Error 转化为可选值"></a>将 Error 转化为可选值</h3><p>使用 <code>try?</code> 将可能报错函数转化为一个可选型的值。如果报错，则变量赋值为 <code>nil</code>，否则赋值为函数返回值。下面的例子中，x 和 y 有相同的结果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someThrowingFunction</span>()</span> <span class="keyword">throws</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x <span class="operator">=</span> <span class="keyword">try?</span> someThrowingFunction()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    y <span class="operator">=</span> <span class="keyword">try</span> someThrowingFunction()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    y <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try?</code> 可以让你用更简洁的方式处理 Error。下面的例子中，使用两种方式获取数据，每一种成功则退出函数，全都失败则返回 <code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchData</span>()</span> -&gt; <span class="type">Data</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try?</span> fetchDataFromDisk() &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try?</span> fetchDataFromServer() &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="禁止-Error-传播"><a href="#禁止-Error-传播" class="headerlink" title="禁止 Error 传播"></a>禁止 Error 传播</h3><p>有时你知道一个抛出 Error 的函数或方法在运行时是不会抛出 Error 的。此时你可以使用 <code>try!</code> 来处理这种情况。此时如果报出了 Error，将不会被传播，而是触发一个运行时的断言报错。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> photo <span class="operator">=</span> <span class="keyword">try!</span> loadImage(atPath: <span class="string">&quot;./Resources/John Appleseed.jpg&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="指定清洁动作"><a href="#指定清洁动作" class="headerlink" title="指定清洁动作"></a>指定清洁动作</h3><p><code>defer</code> 语句可以用来在当前代码块的代码结束执行时做一些操作。这个语句可以保证无论是代码正常离开，或者报错、break、return 出去的情况下都能执行必要的清洁操作。例如，你可以使用 <code>defer</code> 语句保证一个打开的文件最终被关闭释放资源。</p>
<p><code>defer</code> 语句的内容将延迟到当前域的代码全部执行结束之后才会被执行。在 <code>defer</code> 语句中不能转移控制，执行例如 return 和 break 等操作，或者抛出一个 Error。另外，延迟动作的执行顺序是自下而上的，与一般自上而下执行的正常代码相比是颠倒的。这意味着如果存在多个 <code>defer</code> 语句，最先写的语句最后执行，最后写的语句最先执行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processFile</span>(<span class="params">filename</span>: <span class="type">String</span>)</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> exists(filename) &#123;</span><br><span class="line">        <span class="keyword">let</span> file <span class="operator">=</span> <span class="keyword">open</span>(filename)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            close(file)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> line <span class="operator">=</span> <span class="keyword">try</span> file.readline() &#123;</span><br><span class="line">            <span class="comment">// Work with the file.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// close(file) is called here, at the end of the scope.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：Swift 的 <code>defer</code> 语句稍有类似 Java 的 try-catch 中的 <code>final</code> 或者 <code>try-with</code> 语句，但是更灵活。</p>
</blockquote>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>21.<a href="https://github.com/zfanli/notes/blob/master/swift/21.OptionalChaining.md">Swift Optional Chaining</a></p>
<p>23.<a href="https://github.com/zfanli/notes/blob/master/swift/23.TypeCasting.md">Swift Type Casting</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>23.Swift Type Casting</title>
    <url>/post/notes/swift/23-TypeCasting/</url>
    <content><![CDATA[<p>操作符 <code>is</code> 和 <code>as</code>，一个负责检查，一个负责转换。<code>as?</code> 优雅转换，失败可以返回 <code>nil</code>，<code>as!</code> 强制转换，失败就失败，失败就报错！</p>
<span id="more"></span>

<h2 id="类型强转"><a href="#类型强转" class="headerlink" title="类型强转"></a>类型强转</h2><p>Swift 提供 <code>is</code> 和 <code>as</code> 操作符用来检查类型和强制转换类型。</p>
<p>先定义几个类型。</p>
<p>下面是一个顶级类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediaItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是两个子类。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span>: <span class="title">MediaItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> director: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">director</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.director <span class="operator">=</span> director</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Song</span>: <span class="title">MediaItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> artist: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">artist</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.artist <span class="operator">=</span> artist</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面定义一个数组包含 2 个 Movie 和 3 个 Song。Swift 可以发现 Movie 和 Song 有共同的父类 MediaItem，所以 library 的类型将被推测为 <code>[MediaItem]</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> library <span class="operator">=</span> [</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">&quot;Casablanca&quot;</span>, director: <span class="string">&quot;Michael Curtiz&quot;</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">&quot;Blue Suede Shoes&quot;</span>, artist: <span class="string">&quot;Elvis Presley&quot;</span>),</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">&quot;Citizen Kane&quot;</span>, director: <span class="string">&quot;Orson Welles&quot;</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">&quot;The One And Only&quot;</span>, artist: <span class="string">&quot;Chesney Hawkes&quot;</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">&quot;Never Gonna Give You Up&quot;</span>, artist: <span class="string">&quot;Rick Astley&quot;</span>)</span><br><span class="line">]</span><br><span class="line"><span class="comment">// the type of &quot;library&quot; is inferred to be [MediaItem]</span></span><br></pre></td></tr></table></figure>

<p>此时会出现一个问题，当你遍历 library 时，每个 item 的类型将是 MediaItem，而不是 Movie 或者 Song。你需要处理它们正确的原本的类型，此时你需要检查并强转它们。</p>
<h3 id="检查类型"><a href="#检查类型" class="headerlink" title="检查类型"></a>检查类型</h3><p>使用 <code>is</code> 操作符检查类型。下面检查 library 中每个元素的类型，并对 Movie 和 Song 进行计数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> movieCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> songCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> library &#123;</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">is</span> <span class="type">Movie</span> &#123;</span><br><span class="line">        movieCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> item <span class="keyword">is</span> <span class="type">Song</span> &#123;</span><br><span class="line">        songCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Media library contains <span class="subst">\(movieCount)</span> movies and <span class="subst">\(songCount)</span> songs&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Media library contains 2 movies and 3 songs&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="向下强转类型转换"><a href="#向下强转类型转换" class="headerlink" title="向下强转类型转换"></a>向下强转类型转换</h3><p>当你确定一个变量的原本类型的时候，你可以用强转操作符对其进行强制转换，操作符为 <code>as?</code> 或 <code>as!</code>。</p>
<p>由于强转操作有可能失败，所以操作符分成两个构成：<code>as?</code> 失败时返回 <code>nil</code>；<code>as!</code> 失败时触发一个运行时的断言错误。</p>
<p>下面是向下强制类型转换的例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> library &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> movie <span class="operator">=</span> item <span class="keyword">as?</span> <span class="type">Movie</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Movie: <span class="subst">\(movie.name)</span>, dir. <span class="subst">\(movie.director)</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> song <span class="operator">=</span> item <span class="keyword">as?</span> <span class="type">Song</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Song: <span class="subst">\(song.name)</span>, by <span class="subst">\(song.artist)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Movie: Casablanca, dir. Michael Curtiz</span></span><br><span class="line"><span class="comment">// Song: Blue Suede Shoes, by Elvis Presley</span></span><br><span class="line"><span class="comment">// Movie: Citizen Kane, dir. Orson Welles</span></span><br><span class="line"><span class="comment">// Song: The One And Only, by Chesney Hawkes</span></span><br><span class="line"><span class="comment">// Song: Never Gonna Give You Up, by Rick Astley</span></span><br></pre></td></tr></table></figure>

<h3 id="对-Any-或-AnyObject-进行类型强制转换"><a href="#对-Any-或-AnyObject-进行类型强制转换" class="headerlink" title="对 Any 或 AnyObject 进行类型强制转换"></a>对 <code>Any</code> 或 <code>AnyObject</code> 进行类型强制转换</h3><p>Swift 提供两种方式处理非指定类型：</p>
<ul>
<li><code>Any</code> 可以指定任何类型，包括函数类型；</li>
<li><code>AnyObject</code> 可以指定任何类的实例类型。</li>
</ul>
<p>下面是使用 <code>Any</code> 的一个例子，这个数组可以储存任何类型的数据，包括函数类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> things <span class="operator">=</span> [<span class="keyword">Any</span>]()</span><br><span class="line"></span><br><span class="line">things.append(<span class="number">0</span>)</span><br><span class="line">things.append(<span class="number">0.0</span>)</span><br><span class="line">things.append(<span class="number">42</span>)</span><br><span class="line">things.append(<span class="number">3.14159</span>)</span><br><span class="line">things.append(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">things.append((<span class="number">3.0</span>, <span class="number">5.0</span>))</span><br><span class="line">things.append(<span class="type">Movie</span>(name: <span class="string">&quot;Ghostbusters&quot;</span>, director: <span class="string">&quot;Ivan Reitman&quot;</span>))</span><br><span class="line">things.append(&#123; (name: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span> <span class="string">&quot;Hello, <span class="subst">\(name)</span>&quot;</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>下面使用类型检查和强转操作符进行恢复。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> things &#123;</span><br><span class="line">    <span class="keyword">switch</span> thing &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Int</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;zero as an Int&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Double</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;zero as a Double&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someInt <span class="keyword">as</span> <span class="type">Int</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;an integer value of <span class="subst">\(someInt)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someDouble <span class="keyword">as</span> <span class="type">Double</span> <span class="keyword">where</span> someDouble <span class="operator">&gt;</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;a positive double value of <span class="subst">\(someDouble)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">is</span> <span class="type">Double</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;some other double value that I don&#x27;t want to print&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someString <span class="keyword">as</span> <span class="type">String</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;a string value of <span class="subst">\&quot;</span><span class="subst">\(someString)</span><span class="subst">\&quot;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">as</span> (<span class="type">Double</span>, <span class="type">Double</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;an (x, y) point at <span class="subst">\(x)</span>, <span class="subst">\(y)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> movie <span class="keyword">as</span> <span class="type">Movie</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;a movie called <span class="subst">\(movie.name)</span>, dir. <span class="subst">\(movie.director)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> stringConverter <span class="keyword">as</span> (<span class="type">String</span>) -&gt; <span class="type">String</span>:</span><br><span class="line">        <span class="built_in">print</span>(stringConverter(<span class="string">&quot;Michael&quot;</span>))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;something else&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zero as an Int</span></span><br><span class="line"><span class="comment">// zero as a Double</span></span><br><span class="line"><span class="comment">// an integer value of 42</span></span><br><span class="line"><span class="comment">// a positive double value of 3.14159</span></span><br><span class="line"><span class="comment">// a string value of &quot;hello&quot;</span></span><br><span class="line"><span class="comment">// an (x, y) point at 3.0, 5.0</span></span><br><span class="line"><span class="comment">// a movie called Ghostbusters, dir. Ivan Reitman</span></span><br><span class="line"><span class="comment">// Hello, Michael</span></span><br></pre></td></tr></table></figure>

<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>22.<a href="https://github.com/zfanli/notes/blob/master/swift/22.ErrorHandling.md">Swift Error Handling</a></p>
<p>24.<a href="https://github.com/zfanli/notes/blob/master/swift/24.Extensions.md">Swift Extensions</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>24.Swift Extensions</title>
    <url>/post/notes/swift/24-Extensions/</url>
    <content><![CDATA[<p>这部分内容也是复习。扩展可以给任何类型添加新的属性、方法、初始化器，虽然它有以下的限制：</p>
<ul>
<li>对类来说无法添加新的指定初始化器或卸载器，它们只能由原始实现提供；</li>
<li>给另一个 Module 的结构体添加新的初始化器时，在调用其本身的初始化器之前无法访问 <code>self</code> 属性。</li>
</ul>
<span id="more"></span>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>扩展用来给现有的类、结构体、枚举类型甚至是协议添加功能。你可以在不用访问类型的原始代码的情况下对其进行扩展。</p>
<p>Swift 中的扩展可以做到下面这些事：</p>
<ul>
<li>添加计算实例属性和计算的类型属性；</li>
<li>定义实例的方法和类型的方法；</li>
<li>提供新的初始化器；</li>
<li>定义下标；</li>
<li>定义和使用新的嵌套类型；</li>
<li>让一个现有的类型实现一个协议。</li>
</ul>
<p>在 Swift 中，你甚至可以对协议进行扩展来提供它所要求的实现，或者是提供符合的类型能利用的其他附加功能。</p>
<h3 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h3><p>下面是使用扩展的语法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SomeType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// new functionality to add to SomeType goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展可以让现有的类型实现新的协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SomeType</span>: <span class="title">SomeProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implementation of protocol requirements goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>扩展可以给现有类型添加新的计算属性。下面的例子对 Swift 内置的 Double 类型添加了计算属性，实现对计算距离单位的基础支持。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> km: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> m: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> cm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">100.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> mm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> ft: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">3.28084</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> oneInch <span class="operator">=</span> <span class="number">25.4</span>.mm</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;One inch is <span class="subst">\(oneInch)</span> meters&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;One inch is 0.0254 meters&quot;</span></span><br><span class="line"><span class="keyword">let</span> threeFeet <span class="operator">=</span> <span class="number">3</span>.ft</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Three feet is <span class="subst">\(threeFeet)</span> meters&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Three feet is 0.914399970739201 meters&quot;</span></span><br></pre></td></tr></table></figure>

<p>这些计算属性表示 Double 值应该被作为某个长度单位处理。尽管它们作为计算属性实现，但是可以使用点语法将其加在浮点数值的字面量后，作为一种方式来执行字面量的长度换算。</p>
<p>它们是只读的，为了简洁省略了 get 关键字。它们甚至可以做运算。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aMarathon <span class="operator">=</span> <span class="number">42</span>.km <span class="operator">+</span> <span class="number">195</span>.m</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A marathon is <span class="subst">\(aMarathon)</span> meters long&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;A marathon is 42195.0 meters long&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h3><p>扩展可以给现有的类型添加新的初始化器。这可以让你扩展其他类型接收你的定制类型作为初始化器的参数，或者提供原始实现中没有的新的初始化选项。</p>
<p>对于类来说，扩展可以添加新的便利初始化器，但是无法添加新的指定初始化器或者是卸载器。指定初始化器和卸载着只能由原始实现提供。</p>
<p>如果你给另一个模块的结构体添加新的初始化器，在调用其本身的初始化器之前你无法访问 <code>self</code> 属性。</p>
<p>下面的代码定义了一个四边形和尺寸、点的属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Rect 结构体给所有属性提供了默认值，所以它会收到一个默认的初始化器，以及一个按成员初始化器。你可以像下面这样创建 Rect 的新实例。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultRect <span class="operator">=</span> <span class="type">Rect</span>()</span><br><span class="line"><span class="keyword">let</span> memberwiseRect <span class="operator">=</span> <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">2.0</span>, y: <span class="number">2.0</span>),</span><br><span class="line">   size: <span class="type">Size</span>(width: <span class="number">5.0</span>, height: <span class="number">5.0</span>))</span><br></pre></td></tr></table></figure>

<p>你可以使用扩展给 Rect 添加指定的中点和尺寸属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">center</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> originX <span class="operator">=</span> center.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY <span class="operator">=</span> center.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个新的初始化器首先用拿到的参数计算出点的信息，然后调用结构体原本的初始化器进行初始化。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> centerRect <span class="operator">=</span> <span class="type">Rect</span>(center: <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">4.0</span>),</span><br><span class="line">                      size: <span class="type">Size</span>(width: <span class="number">3.0</span>, height: <span class="number">3.0</span>))</span><br><span class="line"><span class="comment">// centerRect&#x27;s origin is (2.5, 2.5) and its size is (3.0, 3.0)</span></span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>扩展可以给类型添加新的方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">repetitions</span>(<span class="params">task</span>: () -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="keyword">self</span> &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.repetitions &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure>

<p>添加方法可以修改实例本身，但是对于结构体和枚举类型来说，修改自身的方法需要 <code>mutating</code> 关键字。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">square</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">someInt.square()</span><br><span class="line"><span class="comment">// someInt is now 9</span></span><br></pre></td></tr></table></figure>

<h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><p>可以添加下标支持给现有的类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">subscript</span>(<span class="params">digitIndex</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> decimalBase <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>digitIndex &#123;</span><br><span class="line">            decimalBase <span class="operator">*=</span> <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">self</span> <span class="operator">/</span> decimalBase) <span class="operator">%</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">746381295</span>[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// returns 5</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// returns 9</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">2</span>]</span><br><span class="line"><span class="comment">// returns 2</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">8</span>]</span><br><span class="line"><span class="comment">// returns 7</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h3><p>还可以添加嵌套类型。下面对 Int 添加嵌套的枚举类型，可以判断数值的符号。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Kind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> negative, zero, positive</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> kind: <span class="type">Kind</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .zero</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x <span class="operator">&gt;</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .positive</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> .negative</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printIntegerKinds</span>(<span class="keyword">_</span> <span class="params">numbers</span>: [<span class="type">Int</span>])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">switch</span> number.kind &#123;</span><br><span class="line">        <span class="keyword">case</span> .negative:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;- &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> .zero:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;0 &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> .positive:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;+ &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">printIntegerKinds([<span class="number">3</span>, <span class="number">19</span>, <span class="operator">-</span><span class="number">27</span>, <span class="number">0</span>, <span class="operator">-</span><span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>])</span><br><span class="line"><span class="comment">// Prints &quot;+ + - 0 - 0 + &quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>23.<a href="https://github.com/zfanli/notes/blob/master/swift/23.TypeCasting.md">Swift Type Casting</a></p>
<p>25.<a href="https://github.com/zfanli/notes/blob/master/swift/25.Protocols.md">Swift Protocols</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>27.Swift Opaque Types</title>
    <url>/post/notes/swift/27-OpaqueTypes/</url>
    <content><![CDATA[<p>不透明类型是用来隐藏具体类型信息，只以协议类型描述返回值的一个机制。作用在于保持私有类型的私有性，模块外的用户得到协议类型的返回值，不用处理具体实现的类型。这样的好处在于内部更换实现对外部不再有影响，而且不透明类型只是对用户不透明，编译器可以得到具体类型进行特化处理，最好的优化性能。</p>
<p>其语法形式是在返回值协议类型前加 <code>some</code> 关键字。</p>
<p>这篇主题看上去挺重要但实际上很枯燥。主要是，太啰嗦了，而且啰嗦了一大堆也没看懂重点在哪里。</p>
<p>再议！</p>
<span id="more"></span>

<h2 id="不透明类型"><a href="#不透明类型" class="headerlink" title="不透明类型"></a>不透明类型</h2><p>不透明类型是指一个函数或方法隐藏了类型信息，其返回值类型将描述为其支持的协议，而不是一个具体的类型。隐藏类型信息可以让模块中潜在的返回值类型保持私有，让模块内的代码和外部调用模块的代码区分边界。将返回类型定义为协议类型也能做到这一点，但是不透明返回类型保留了一定的类型身份信息，这些信息将对编译器可见，对用户不可见。</p>
<h3 id="不透明类型解决的问题"><a href="#不透明类型解决的问题" class="headerlink" title="不透明类型解决的问题"></a>不透明类型解决的问题</h3><p>例如，假设你正在写一个基于 ASCII 码的艺术图形绘制的模块。一个 ASCII 艺术图形的基础特性就是 <code>draw()</code> 方法，它会返回一个描绘这个图像的字符串，它的声明如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span>()</span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Triangle</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line">        <span class="keyword">for</span> length <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span>size &#123;</span><br><span class="line">            result.append(<span class="type">String</span>(repeating: <span class="string">&quot;*&quot;</span>, count: length))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.joined(separator: <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> smallTriangle <span class="operator">=</span> <span class="type">Triangle</span>(size: <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(smallTriangle.draw())</span><br><span class="line"><span class="comment">// *</span></span><br><span class="line"><span class="comment">// **</span></span><br><span class="line"><span class="comment">// ***</span></span><br></pre></td></tr></table></figure>

<p>你可以用泛型去实现一个颠倒图形的操作，如下面代码。但是这个方法有一个严重的限制：它的结果暴露了实际用来创建颠倒图形使用的类型的具体的泛型类型信息。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlippedShape</span>&lt;<span class="title">T</span>: <span class="title">Shape</span>&gt;: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> shape: <span class="type">T</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> lines <span class="operator">=</span> shape.draw().split(separator: <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> lines.reversed().joined(separator: <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> flippedTriangle <span class="operator">=</span> <span class="type">FlippedShape</span>(shape: smallTriangle)</span><br><span class="line"><span class="built_in">print</span>(flippedTriangle.draw())</span><br><span class="line"><span class="comment">// ***</span></span><br><span class="line"><span class="comment">// **</span></span><br><span class="line"><span class="comment">// *</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：插入一段说明。</p>
<p>上面的 <code>Triangle</code> 类型应该算作一个用于公开的 API 类型。而将一个 <code>Triangle</code> 输出进行颠倒，按照预期我们应该得到另一个 <code>Triangle</code> 并且调用它的 <code>draw()</code> 方法就可以得到一个颠倒的图形输出，但是实际上模块内部的实现方式是用一个泛型结构体拿到之前那个 <code>Triangle</code> 对象，然后调用它的 <code>draw()</code> 方法，缓存得到的字符串，接着逆转输出。</p>
<p>从实现上来说没有什么问题，但是如果我们想得到一个颠倒的三角形图案，我们得到的却是一个类型为 <code>FlippedShape</code> 的泛型类型对象，而非预期的 <code>Triangle</code> 对象。从名称上看来 <code>FlippedShape</code> 或许并不是一个适合公开的类型，而且随着模块更新或实现方式变更，不能保证以后进行同样的操作得到的是相同的 <code>FlippedShape</code> 类型对象。</p>
<p>所以这里来说，暴露了一个不稳定的内部潜在类型其实是不安全的，这里最好提供一个稳定的类型，而不要关联一个随时会更新换代的内部类型。</p>
</blockquote>
<p>下面再定义一个 <code>JoinedShape&lt;T: Shape, U: Shape&gt;</code> 方法用来将两个形状垂直拼到一起。使用这个方法构建一个拼接到一起的形状会得到一个类型为 <code>JoinedShape&lt;Triangle, FlippedShape&lt;Triangle&gt;&gt;</code> 的对象。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">JoinedShape</span>&lt;<span class="title">T</span>: <span class="title">Shape</span>, <span class="title">U</span>: <span class="title">Shape</span>&gt;: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> top: <span class="type">T</span></span><br><span class="line">    <span class="keyword">var</span> bottom: <span class="type">U</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top.draw() <span class="operator">+</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span> <span class="operator">+</span> bottom.draw()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> joinedTriangles <span class="operator">=</span> <span class="type">JoinedShape</span>(top: smallTriangle, bottom: flippedTriangle)</span><br><span class="line"><span class="built_in">print</span>(joinedTriangles.draw())</span><br><span class="line"><span class="comment">// *</span></span><br><span class="line"><span class="comment">// **</span></span><br><span class="line"><span class="comment">// ***</span></span><br><span class="line"><span class="comment">// ***</span></span><br><span class="line"><span class="comment">// **</span></span><br><span class="line"><span class="comment">// *</span></span><br></pre></td></tr></table></figure>

<p>由于需要声明完整的返回类型，暴露形状创建的细节信息将会导致不属于模块公开接口的类型泄漏出去。模块内部的代码有非常多的方式构建一个相同的形状，而模块外的代码也不应该处理各种图形转换的实现细节。类似于 <code>JoinedShape</code> 和 <code>FlippedShape</code> 之类的包装器类型对用户来说是没有意义的，它们应该是对外不可见的。模块的公开接口应该由合并、颠倒之类的操作构成，但是这些操作应该返回另一个 <code>Shape</code> 值。</p>
<blockquote>
<p>R：而不是一个具体的内部实现类型。</p>
</blockquote>
<h3 id="返回一个不透明类型"><a href="#返回一个不透明类型" class="headerlink" title="返回一个不透明类型"></a>返回一个不透明类型</h3><p>你可以将不透明类型当作一个反向的泛型类型。泛型代码让调用者来决定函数的参数，并用函数实现中抽象出来的方式返回值。下面的例子中返回值的类型取决于调用者。</p>
<blockquote>
<p>R：来啦！又是用一个难懂的概念解释另一个难懂的概念。</p>
<p>这段翻译可能有点无力，因为我也不确定我是不是理解对了，原文如下：</p>
<p>You can think of an opaque type like being the reverse of a generic type. Generic types let the code that calls a function pick the type for that function’s parameters and return value in a way that’s abstracted away from the function implementation.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">x</span>: <span class="type">T</span>, <span class="keyword">_</span> <span class="params">y</span>: <span class="type">T</span>)</span> -&gt; <span class="type">T</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Comparable</span> &#123; <span class="operator">...</span> &#125;</span><br></pre></td></tr></table></figure>

<p><code>max(_:_:)</code> 函数的调用者决定 x 和 y 的类型，只要这个类型符合 <code>Comparable</code> 协议。函数内部的代码以通用的方式编写，这样它就可以处理调用者提供的任何类型。<code>max(_:_:)</code> 函数只用到了 <code>Comparable</code> 协议提供的功能性。</p>
<p>如果函数返回一个不透明类型，则角色互换。不透明类型可以让函数实现用调用者代码中抽象出来的方式决定返回值的类型。例如下面的代码在不暴露潜在类型的情况下返回一个梯形。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Square</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> line <span class="operator">=</span> <span class="type">String</span>(repeating: <span class="string">&quot;*&quot;</span>, count: size)</span><br><span class="line">        <span class="keyword">let</span> result <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">String</span>&gt;(repeating: line, count: size)</span><br><span class="line">        <span class="keyword">return</span> result.joined(separator: <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeTrapezoid</span>()</span> -&gt; <span class="keyword">some</span> <span class="type">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> top <span class="operator">=</span> <span class="type">Triangle</span>(size: <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> middle <span class="operator">=</span> <span class="type">Square</span>(size: <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> bottom <span class="operator">=</span> <span class="type">FlippedShape</span>(shape: top)</span><br><span class="line">    <span class="keyword">let</span> trapezoid <span class="operator">=</span> <span class="type">JoinedShape</span>(</span><br><span class="line">        top: top,</span><br><span class="line">        bottom: <span class="type">JoinedShape</span>(top: middle, bottom: bottom)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> trapezoid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> trapezoid <span class="operator">=</span> makeTrapezoid()</span><br><span class="line"><span class="built_in">print</span>(trapezoid.draw())</span><br><span class="line"><span class="comment">// *</span></span><br><span class="line"><span class="comment">// **</span></span><br><span class="line"><span class="comment">// **</span></span><br><span class="line"><span class="comment">// **</span></span><br><span class="line"><span class="comment">// **</span></span><br><span class="line"><span class="comment">// *</span></span><br></pre></td></tr></table></figure>

<p><code>makeTrapezoid()</code> 函数返回的类型是 <code>some Shape</code>。函数没有给返回值指定任何具体的类型，其结果是函数返回一个给定的实现了 <code>Shape</code> 协议的类型的值。以这种方式编写函数表现出它作为一个公开接口的基础面，也就是返回一个 <code>Shape</code> 类型值，而不需要将制作这些形状的指定类型定义为它的公开接口的一部分。这个实现使用了两个三角形和一个四边形，但是这个函数可以在不变更返回值的情况下用其他的方式进行重写，毕竟要实现绘制一个梯形有太多的方式可以使用。</p>
<p>这个例子强调了不透明类型类似反向的泛型这一点。<code>makeTrapezoid()</code> 函数内部的代码可以根据需要返回任意实现了 <code>Shape</code> 协议的类型，就像泛型函数调用者所做的一样。为了处理 <code>makeTrapezoid()</code> 函数返回的任何 <code>Shape</code> 类型的值，这个函数的调用代码需要用更通用的方式编写，就像一个泛型函数的实现。</p>
<p>你也可以将不透明类型和泛型配合使用。下面的函数都将返回一个实现了 <code>Shape</code> 协议的类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flip</span>&lt;<span class="type">T</span>: <span class="type">Shape</span>&gt;(<span class="keyword">_</span> <span class="params">shape</span>: <span class="type">T</span>)</span> -&gt; <span class="keyword">some</span> <span class="type">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">FlippedShape</span>(shape: shape)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">join</span>&lt;<span class="type">T</span>: <span class="type">Shape</span>, <span class="type">U</span>: <span class="type">Shape</span>&gt;(<span class="keyword">_</span> <span class="params">top</span>: <span class="type">T</span>, <span class="keyword">_</span> <span class="params">bottom</span>: <span class="type">U</span>)</span> -&gt; <span class="keyword">some</span> <span class="type">Shape</span> &#123;</span><br><span class="line">    <span class="type">JoinedShape</span>(top: top, bottom: bottom)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> opaqueJoinedTriangles <span class="operator">=</span> join(smallTriangle, flip(smallTriangle))</span><br><span class="line"><span class="built_in">print</span>(opaqueJoinedTriangles.draw())</span><br><span class="line"><span class="comment">// *</span></span><br><span class="line"><span class="comment">// **</span></span><br><span class="line"><span class="comment">// ***</span></span><br><span class="line"><span class="comment">// ***</span></span><br><span class="line"><span class="comment">// **</span></span><br><span class="line"><span class="comment">// *</span></span><br></pre></td></tr></table></figure>

<p><code>opaqueJoinedTriangles</code> 和上文例子中的 <code>joinedTriangles</code> 是一致的。不同的是 <code>flip(_:)</code> 和 <code>join(_:_:)</code> 函数包装了潜在的类型，将其以不透明类型的形式返回，这样类型信息对外部来说是不可见的。由于依赖泛型参数，这两个函数都是泛型的，而且类型参数会附带 <code>FlippedShape</code> 和 <code>JoinedShape</code> 所需的类型信息。</p>
<p>如果一个函数多处返回不透明类型，这些可能的返回值都需要有相同的类型。对于泛型类型来说，返回值类型可以使用泛型参数类型，但它仍然需要是同一个类型。下面是一个<strong>无效版本</strong>的例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invalidFlip</span>&lt;<span class="type">T</span>: <span class="type">Shape</span>&gt;(<span class="keyword">_</span> <span class="params">shape</span>: <span class="type">T</span>)</span> -&gt; <span class="keyword">some</span> <span class="type">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> shape <span class="keyword">is</span> <span class="type">Square</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shape <span class="comment">// Error: return types don&#x27;t match</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">FlippedShape</span>(shape: shape) <span class="comment">// Error: return types don&#x27;t match</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数违反了返回值必须是相同类型的要求，所以它是无效的代码。要修复这个问题，可以将 Square 的判断移到 <code>FlippedShape</code> 函数里。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlippedShape</span>&lt;<span class="title">T</span>: <span class="title">Shape</span>&gt;: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> shape: <span class="type">T</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> shape <span class="keyword">is</span> <span class="type">Square</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> shape.draw()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> lines <span class="operator">=</span> shape.draw().split(separator: <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> lines.reversed().joined(separator: <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在返回值中使用泛型是不违反要求的，比如下面代码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">`repeat`</span>&lt;<span class="type">T</span>: <span class="type">Shape</span>&gt;(<span class="params">shape</span>: <span class="type">T</span>, <span class="params">count</span>: <span class="type">Int</span>)</span> -&gt; <span class="keyword">some</span> <span class="type">Collection</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Array</span>&lt;<span class="type">T</span>&gt;(repeating: shape, count: count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不透明类型和协议类型的区别"><a href="#不透明类型和协议类型的区别" class="headerlink" title="不透明类型和协议类型的区别"></a>不透明类型和协议类型的区别</h3><p>不透明返回值类型和协议类型返回值看上去比较相似，区别之处在于是否保留类型身份信息。不透明类型引用一个指定的类型，但是这对调用者来说是不可见的；而协议类型可引用任何符合该协议的类型。通常来说，协议类型给予你更多灵活性在潜在类型上，但不透明类型可以让你对这些潜在类型作出强保证。</p>
<p>例如下面的代码没有使用不透明类型，而是使用一个协议类型作为返回值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protoFlip</span>&lt;<span class="type">T</span>: <span class="type">Shape</span>&gt;(<span class="keyword">_</span> <span class="params">shape</span>: <span class="type">T</span>)</span> -&gt; <span class="type">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">FlippedShape</span>(shape: shape)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>protoFlip(_:)</code> 的处理和 <code>flip(_:)</code> 完全一致，并且始终返回相同类型的值。和 <code>flip(_:)</code> 不同的是 <code>protoFlip(_:)</code> 不要求始终返回相同类型的值，他只要求实现 <code>Shape</code> 协议就可以。另一方面 <code>protoFlip(_:)</code> 在 API 约束上比 <code>flip(_:)</code> 更加宽松。它保留了返回多种类型值的灵活性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protoFlip</span>&lt;<span class="type">T</span>: <span class="type">Shape</span>&gt;(<span class="keyword">_</span> <span class="params">shape</span>: <span class="type">T</span>)</span> -&gt; <span class="type">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> shape <span class="keyword">is</span> <span class="type">Square</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shape</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">FlippedShape</span>(shape: shape)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修订后的版本可以返回两个类型的值，取决于参数类型。这个函数返回的值的；类型可能完全不同。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> protoFlippedTriangle <span class="operator">=</span> protoFlip(smallTriangle)</span><br><span class="line"><span class="keyword">let</span> sameThing <span class="operator">=</span> protoFlip(smallTriangle)</span><br><span class="line">protoFlippedTriangle <span class="operator">==</span> sameThing  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：不太清除这篇主题的重要性。总之，目前研究比较枯燥，等到实践中再验证吧。下面贴部分代码示例。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Container</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Protocol with associated types can&#x27;t be used as a return type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeProtocolContainer</span>&lt;<span class="type">T</span>&gt;(<span class="params">item</span>: <span class="type">T</span>)</span> -&gt; <span class="type">Container</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [item]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Not enough information to infer C.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeProtocolContainer</span>&lt;<span class="type">T</span>, <span class="type">C</span>: <span class="type">Container</span>&gt;(<span class="params">item</span>: <span class="type">T</span>)</span> -&gt; <span class="type">C</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [item]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeOpaqueContainer</span>&lt;<span class="type">T</span>&gt;(<span class="params">item</span>: <span class="type">T</span>)</span> -&gt; <span class="keyword">some</span> <span class="type">Container</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [item]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> opaqueContainer <span class="operator">=</span> makeOpaqueContainer(item: <span class="number">12</span>)</span><br><span class="line"><span class="keyword">let</span> twelve <span class="operator">=</span> opaqueContainer[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(of: twelve))</span><br><span class="line"><span class="comment">// Prints &quot;Int&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>26.<a href="https://github.com/zfanli/notes/blob/master/swift/26.Generics.md">Swift Generics</a></p>
<p>28.<a href="https://github.com/zfanli/notes/blob/master/swift/28.AutomaticReferenceCounting.md">Swift Automatic Reference Counting</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>29.Swift Memory Safety</title>
    <url>/post/notes/swift/29-MemorySafety/</url>
    <content><![CDATA[<p>内存安全依然不需要我们多做考虑。本篇最大的目的还是了解什么情况下会出现内存不安全的问题，并且在编码时避免这些问题。由于目前为止没有涉及到协程或多线程的内容，要保重内存安全相对来说是简单的。</p>
<p>内存访问存在三个属性：操作是读还是写；操作持续多久；操作哪个内存位置。</p>
<p>一旦后两者出现重叠，也就是说对同一个内存位置同时进行操作，那么就会出现内存不安全的冲突情况。</p>
<span id="more"></span>

<p>需要注意的是元组、结构体或者枚举类型等值类型的数据，它们的属性都是本身的一部分，被储存在同一个内存位置。所以如果同时对它们的多个属性进行修改的时候，实际上是属于对同一个内存位置同时进行修改的，所以是冲突的。</p>
<p>但是对结构体来说，可能多数重叠操作是安全的。原则上编译器能提供证明操作安全，操作就是可以执行的。比如如果一个结构体声明在局部作用域，对这个结构体的多个属性操作编译器可以证明操作安全所以允许。</p>
<h2 id="内存安全性"><a href="#内存安全性" class="headerlink" title="内存安全性"></a>内存安全性</h2><p>默认情况下 Swift 会阻止你代码中的不安全的行为。例如 Swift 保证每个变量在被使用之前进行初始化，内存在被释放后不可访问，数组索引会检测边界。</p>
<p>通过要求修改内存的代码对内存进行独占访问，Swift 也可以保证对同一个内存区域进行多次访问不会冲突。因为 Swift 自动管理内存，大部分时间你根本不需要思考内存管理的问题。但是理解可能会发生的潜在冲突，可以帮助你避免编写冲突的内存访问代码。要知道，如果你的代码中存在冲突，在编译时或者运行时会报错。</p>
<h3 id="理解内存访问的冲突"><a href="#理解内存访问的冲突" class="headerlink" title="理解内存访问的冲突"></a>理解内存访问的冲突</h3><p>在你给变量赋值或给函数传参数时，就会发生内存访问。例如下面的代码进行了读写访问。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A write access to the memory where one is stored.</span></span><br><span class="line"><span class="keyword">var</span> one <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A read access from the memory where one is stored.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;We&#x27;re number <span class="subst">\(one)</span>!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当你的代码试图多处同时对一个内存进行访问时就可能发生冲突。对同一个内存位置同时进行多次访问可能会造成不可预计的、或是矛盾的行为。在 Swift 中有很多方式跨很多行去修改一个值，这导致在它自己的修改过程中访问这个值是可能的。但是这是有问题的。</p>
<p>设想一个场景，你在纸上记账，可能步骤是：先写下账目；再更新合计金额。这时如果有人在你写账目的时候要求查看合计金额，那么你记账前的金额是对方想要的吗？还是你记账结束后的总额才是对方想要的？这是取决于对方的意图的。</p>
<h3 id="内存访问的特性"><a href="#内存访问的特性" class="headerlink" title="内存访问的特性"></a>内存访问的特性</h3><p>内存访问存在三个特性：</p>
<ul>
<li>是写入还是读取；</li>
<li>持续多久；</li>
<li>内存的位置。</li>
</ul>
<p>如果你有两个操作满足下面的条件，那么就会发生冲突：</p>
<ul>
<li>至少一个是写入操作；</li>
<li>访问相同的内存位置；</li>
<li>持续时间有交叠。</li>
</ul>
<p>读和写的操作的区别很明显：读操作不修改内存；写操作修改内存。而内存位置指你现在访问的是什么，可以是一个变量、常量或者是属性。持续时间分为即时和长期两种。</p>
<p>即时访问不允许在其开始访问和结束访问一个内存位置之间让其他代码访问该内存位置。因此，两个即时访问无法同时发生在一个内存位置。例如下面的所有读写操作都是即时完成的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">oneMore</span>(<span class="params">than</span> <span class="params">number</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myNumber <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">myNumber <span class="operator">=</span> oneMore(than: myNumber)</span><br><span class="line"><span class="built_in">print</span>(myNumber)</span><br><span class="line"><span class="comment">// Prints &quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<p>而然还是有很多方式可以在其他代码执行期间对内存进行长久访问。长期访问的意思是在开始修改一个内存位置之后到修改结束这段时间内，还是允许其他代码执行的，这中间的过程就是一个交叠。一个长期访问可以和其他长期访问和即时访问进行交叠。</p>
<blockquote>
<p>R：这感觉有点像异步。</p>
</blockquote>
<h3 id="访问-In-Out-参数时的冲突"><a href="#访问-In-Out-参数时的冲突" class="headerlink" title="访问 In-Out 参数时的冲突"></a>访问 In-Out 参数时的冲突</h3><p>函数对它的 In-Out 参数有长久写入的权利。写入权限从 In-Out 参数得到赋值开始一直持续到函数调用结束。如果函数有多个 In-Out 参数，写入权限以它们出现的顺序开始。</p>
<p>这导致了一个结果就是你无法在函数中访问 In-Out 参数的原始变量。无论是作用域规则或者访问权限允许你这样做。所有对原始变量的访问将报错。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stepSize <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span>(<span class="keyword">_</span> <span class="params">number</span>: <span class="keyword">inout</span> <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    number <span class="operator">+=</span> stepSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">increment(<span class="operator">&amp;</span>stepSize)</span><br><span class="line"><span class="comment">// Error: conflicting accesses to stepSize</span></span><br></pre></td></tr></table></figure>

<p>上面的例子就是这样的。函数中使用了 stepSize 变量，那么它就不能作为 In-Out 参数传进来了，它违反了规则。因为对 stepSize 所在的内存位置同时进行了两次读写操作。一次是读取它的值，同时还要写入新的值。这两个操作交叠导致了失败。这个现象是你不能又读又改同一个内存。</p>
<p>解决这个问题的方法是做一个显式的拷贝。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Make an explicit copy.</span></span><br><span class="line"><span class="keyword">var</span> copyOfStepSize <span class="operator">=</span> stepSize</span><br><span class="line">increment(<span class="operator">&amp;</span>copyOfStepSize)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the original.</span></span><br><span class="line">stepSize <span class="operator">=</span> copyOfStepSize</span><br><span class="line"><span class="comment">// stepSize is now 2</span></span><br></pre></td></tr></table></figure>

<p>这样同样对 stepSize 进行了一次读和一次写的操作，但是读操作在写之前就完成了，它们没有冲突。</p>
<p>下面还有一个例子展示了当函数有多个 In-Out 参数时，不能传递相同的变量。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">balance</span>(<span class="keyword">_</span> <span class="params">x</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">y</span>: <span class="keyword">inout</span> <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sum <span class="operator">=</span> x <span class="operator">+</span> y</span><br><span class="line">    x <span class="operator">=</span> sum <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">    y <span class="operator">=</span> sum <span class="operator">-</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> playerOneScore <span class="operator">=</span> <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> playerTwoScore <span class="operator">=</span> <span class="number">30</span></span><br><span class="line">balance(<span class="operator">&amp;</span>playerOneScore, <span class="operator">&amp;</span>playerTwoScore)  <span class="comment">// OK</span></span><br><span class="line">balance(<span class="operator">&amp;</span>playerOneScore, <span class="operator">&amp;</span>playerOneScore)</span><br><span class="line"><span class="comment">// Error: conflicting accesses to playerOneScore</span></span><br></pre></td></tr></table></figure>

<p>这里对同一个变量执行两次写操作，这是不能实现的，所以会报错。</p>
<h3 id="在方法中访问-self-导致冲突"><a href="#在方法中访问-self-导致冲突" class="headerlink" title="在方法中访问 self 导致冲突"></a>在方法中访问 self 导致冲突</h3><p>结构体的 mutating 方法在被调用的期间对 <code>self</code> 是有写入权限的。设想下面的例子，每个 Player 都有两个属性，一个是生命值，一个是能量。生命值在受到伤害时减少，能量在使用特殊技能时减少。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> health: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> energy: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> maxHealth <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">restoreHealth</span>()</span> &#123;</span><br><span class="line">        health <span class="operator">=</span> <span class="type">Player</span>.maxHealth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中有一个 <code>restoreHealth()</code> 方法，在调用它到它执行结束的期间里有对 <code>self</code> 的写入权限。它对作用是恢复一个玩家对生命值到最大值。目前来看没有其他方法会修改 Player 的属性导致与这个方法交叠。我们添加一个方法 <code>shareHealth(with:)</code>，这样就可能会发生交叠的情况了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">shareHealth</span>(<span class="params">with</span> <span class="params">teammate</span>: <span class="keyword">inout</span> <span class="type">Player</span>)</span> &#123;</span><br><span class="line">        balance(<span class="operator">&amp;</span>teammate.health, <span class="operator">&amp;</span>health)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oscar <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;Oscar&quot;</span>, health: <span class="number">10</span>, energy: <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> maria <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;Maria&quot;</span>, health: <span class="number">5</span>, energy: <span class="number">10</span>)</span><br><span class="line">oscar.shareHealth(with: <span class="operator">&amp;</span>maria)  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>这个方法有一个 In-Out 参数，并且调用之前定义的 <code>balance(_:_:)</code> 方法平衡两个玩家的生命值。上面的例子中平衡了 oscar 和 maria 的生命值，发生了两次写入操作，但是由于是分别对 oscar 和 maria 各自进行了一次写入，所以不发生冲突。这两次写入在时间上确实有交叠，但是修改对内存位置是不同的。</p>
<p>但是如果你用 oscar 去平衡 oscar 的生命中，那么就冲突了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">oscar.shareHealth(with: <span class="operator">&amp;</span>oscar)</span><br><span class="line"><span class="comment">// Error: conflicting accesses to oscar</span></span><br></pre></td></tr></table></figure>

<p>原因是在 <code>shareHealth(with:)</code> 方法中会进行两次长期访问，一个是对 <code>self</code> 的，一个是对 In-Out 参数的。首先这两个长期访问在持续时间上是重叠的，现在这两个对象还处于同一个内存位置，然后还将同时进行两次写入操作。这完全冲突了。</p>
<h3 id="访问属性的冲突"><a href="#访问属性的冲突" class="headerlink" title="访问属性的冲突"></a>访问属性的冲突</h3><p>像结构体、元组和枚举等类型都是由不同的值组成的，比如结构体的属性和元组的元素，都可以是不同类型的。但是由于其实值类型，对其元素进行写入操作要求访问整个值。对一个元组对两个元素进行重叠对写入访问将造成冲突。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> playerInformation <span class="operator">=</span> (health: <span class="number">10</span>, energy: <span class="number">20</span>)</span><br><span class="line">balance(<span class="operator">&amp;</span>playerInformation.health, <span class="operator">&amp;</span>playerInformation.energy)</span><br><span class="line"><span class="comment">// Error: conflicting access to properties of playerInformation</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中对元组 playerInformation 的两个属性调用了 <code>balance(_:_:)</code> 方法造成了冲突，原因是在 <code>balance(_:_:)</code> 方法中它会对两个 In-Out 参数进行写入操作。元组是值类型，元组及其元素是储存在同一个内存位置的，所以这个操作虽然针对元组对两个元素操作，但是实际上还是针对同一个内存位置同时要进行两次写入操作，所以导致冲突。</p>
<p>在全局作用域中结构体也会同样报错。下面对例子中对结构体的两个属性进行修改，这实际上还是对同一个内存位置进行两次写入要求。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> holly <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;Holly&quot;</span>, health: <span class="number">10</span>, energy: <span class="number">10</span>)</span><br><span class="line">balance(<span class="operator">&amp;</span>holly.health, <span class="operator">&amp;</span>holly.energy)  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>但是在实践中，结构体的大多数重叠的写入操作是安全的。例如如果将上面例子的 holly 放在一个局部作用域操作，编译器就能保证对这个结构体的属性进行重叠操作是安全的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> oscar <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;Oscar&quot;</span>, health: <span class="number">10</span>, energy: <span class="number">10</span>)</span><br><span class="line">    balance(<span class="operator">&amp;</span>oscar.health, <span class="operator">&amp;</span>oscar.energy)  <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子和之前不同之处在于结构体声明在局部作用域中，编译器可以保证即使重叠的两次写入操作也是安全的，所以不会报错。</p>
<p>对结构体来说，对属性交叠访问的限制可能不是内存安全必须的。内存安全是预期的保证，但是独占访问是更严格的要求，意思是有些代码保证来内存安全但是却不是独占访问。在编译器能保证非独占访问时仍然是内存安全时，Swift 允许这样的操作。如果下面的条件满足，编译器就能保证结构体属性重叠操作是安全的。</p>
<ul>
<li>你仅访问了储值属性而非计算属性；</li>
<li>结构体是局部变量而非全局变量；</li>
<li>结构体没有被闭包捕获，或者结构体只被非逃逸闭包（nonescaping closures）捕获。</li>
</ul>
<p>如果编译器不能证明操作安全，那操作就不被允许。</p>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>28.<a href="https://github.com/zfanli/notes/blob/master/swift/28.AutomaticReferenceCounting.md">Swift Automatic Reference Counting</a></p>
<p>30.<a href="https://github.com/zfanli/notes/blob/master/swift/30.AccessControl.md">Swift Access Control</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>3.Swift Syntax Basics (流程控制)</title>
    <url>/post/notes/swift/3-SyntaxBasics-FlowControl/</url>
    <content><![CDATA[<p>不同于其他语言，条件判断部分不需要括号。代码块依然需要大括号包围。</p>
<p>用 if-let 的方式可以快速的处理可能为 <code>nil</code> 的可选变量。还可以使用三元表达式简化版 <code>??</code> 操作符在变量不存在的情况下赋予默认值。</p>
<p>switch 条件匹配某个 case 之后将直接跳出，不需要其他语言中的 break 关键字。case 的匹配条件不仅限于比较，还可以使用布尔表达式。</p>
<p>for-in 可以方便遍历字典等类型，while 可以重复代码块。</p>
<p>当需要范围内重复，可以使用 for-in 配合 <code>..&lt;</code> 或 <code>...</code> 操作符定义一个区间，前者不包括右边，后者则包括。</p>
<span id="more"></span>

<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>条件判断关键字：</p>
<ul>
<li><code>if</code></li>
<li><code>switch</code></li>
</ul>
<p>循环关键字：</p>
<ul>
<li><code>for-in</code></li>
<li><code>while</code></li>
<li><code>repeat-while</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> individualScores <span class="operator">=</span> [<span class="number">75</span>, <span class="number">43</span>, <span class="number">103</span>, <span class="number">87</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">var</span> teamScore <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> score <span class="keyword">in</span> individualScores &#123;</span><br><span class="line">    <span class="keyword">if</span> score <span class="operator">&gt;</span> <span class="number">50</span> &#123;</span><br><span class="line">        teamScore <span class="operator">+=</span> <span class="number">3</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        teamScore <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(teamScore)</span><br><span class="line"><span class="comment">// prints 11</span></span><br></pre></td></tr></table></figure>

<p>if 条件控制语句的判断表达式必须返回一个布尔值，不存在任何隐式的比较。</p>
<p>在 if 语句中你可以配合使用 <code>let</code> 来处理值缺失（为 <code>nil</code>） 的场合。这些值是可选的。可选值允许是 <code>nil</code>，表示值缺失。在类型后面写一个问好（<code>?</code>）表示该值是可选的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalString: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(optionalString <span class="operator">==</span> <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// prints false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> optionalName: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;John Appleseed&quot;</span></span><br><span class="line"><span class="keyword">var</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name <span class="operator">=</span> optionalName &#123;</span><br><span class="line">    greeting <span class="operator">=</span> <span class="string">&quot;Hello, <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，如果 <code>optionalName</code> 的值为 <code>nil</code>，则条件判断结果为 false，大括号内的代码块会被跳过。如果不为 <code>nil</code>，<code>optionalName</code> 的值会赋值给常量 <code>name</code>，并且在这段代码块的作用域中有效。</p>
<p>另一个处理可选值的方法是使用 <code>??</code> 操作符，如果可选值缺失了，将会自动使用默认值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nickName: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> fullName: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;John Appleseed&quot;</span></span><br><span class="line"><span class="keyword">let</span> informalGreeting <span class="operator">=</span> <span class="string">&quot;Hi <span class="subst">\(nickName <span class="operator">??</span> fullName)</span>&quot;</span></span><br><span class="line"><span class="comment">// prints &quot;Hi John Appleseed&quot;</span></span><br></pre></td></tr></table></figure>

<p>switch 条件语句支持所有类型的数据和广泛的比较操作符，不仅限于整型或相等。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vegetable <span class="operator">=</span> <span class="string">&quot;red pepper&quot;</span></span><br><span class="line"><span class="keyword">switch</span> vegetable &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;celery&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Add some raisins and make ants on a log.&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;cucumber&quot;</span>, <span class="string">&quot;watercress&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;That would make a good tea sandwich.&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x.hasSuffix(<span class="string">&quot;pepper&quot;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Is it a spicy <span class="subst">\(x)</span>?&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Everything tastes good in soup.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：移除 default 会得到报错：Switch must be exhaustive。提示 switch 必须完整，就是说要包括所有场合。</p>
</blockquote>
<p>在 Swift 中，switch 执行完某一个 case 将直接推出判断，所以你不需要给每个 case 写上 <code>break</code> 手动跳出。</p>
<blockquote>
<p>R：这有别于大部分的语言。</p>
</blockquote>
<p>使用 <code>for-in</code> 遍历一个字典数据时需要提供一对变量名储存 key 和 value。字典类型是一个随机集合，所以对其进行遍历会采用任意的顺序。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> interestingNumbers <span class="operator">=</span> [</span><br><span class="line">    <span class="string">&quot;Prime&quot;</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>],</span><br><span class="line">    <span class="string">&quot;Fibonacci&quot;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">    <span class="string">&quot;Square&quot;</span>: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> largest <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (kind, numbers) <span class="keyword">in</span> interestingNumbers &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">if</span> number <span class="operator">&gt;</span> largest &#123;</span><br><span class="line">            largest <span class="operator">=</span> number</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(largest)</span><br><span class="line"><span class="comment">// prints 25</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>while</code> 循环一段代码，直到判断条件改变。将循环判断条件放在最后可以保证代码至少执行一次。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> n <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">    n <span class="operator">*=</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"><span class="comment">// prints 128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    m <span class="operator">*=</span> <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">while</span> m <span class="operator">&lt;</span> <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="comment">// prints 128</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：repeat-while 相当于 Java 里的 do-while。</p>
</blockquote>
<p>循环一个范围，使用 <code>..&lt;</code> 语法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> total <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">4</span> &#123;</span><br><span class="line">    total <span class="operator">+=</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(total)</span><br><span class="line"><span class="comment">// prints 6</span></span><br></pre></td></tr></table></figure>

<p><code>..&lt;</code> 操作符包含左边不包含右边，如果希望包含右边，使用 <code>...</code> 操作符。</p>
<blockquote>
<p>R：那个小于号似乎就代表着从左边的数字开始递增到不满足小于右边的条件为止。</p>
</blockquote>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>2.<a href="https://github.com/zfanli/notes/blob/master/swift/2.SyntaxBasics(Strings&Variables).md">Swift Syntax Basics (字符串和变量)</a></p>
<p>4.<a href="https://github.com/zfanli/notes/blob/master/swift/4.SyntaxBasics(Functions&Closures).md">Swift Syntax Basics (函数和闭包)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>30.Swift Access Control</title>
    <url>/post/notes/swift/30-AccessControl/</url>
    <content><![CDATA[<p>乍一看，好高级的话题。仔细一看，无非就是外部能访问的限制程度而已，功能和 Java 的 <code>public</code>、<code>private</code> 修饰符一样，无非细化程度更多。总结如下：</p>
<p>按照等级从高到低排序。</p>
<ul>
<li>（最高）<code>open</code> 和 <code>public</code> 关键字允许最少的访问限制，<code>open</code> 对于类来说，允许外部继承和覆盖类的属性，<code>public</code> 则不允许；</li>
<li><code>internal</code> 模块外部不能访问；</li>
<li><code>fileprivate</code> 定义文件内可访问；</li>
<li>（最低）<code>private</code> 定义仅两个打括号之间的代码能访问。</li>
</ul>
<p>普遍的规则是，内部的访问权限不能高于外部，可以低于外部。比如类标注为 internal 那么类成员就不能高于 internal 比如说 public。</p>
<p>默认不写访问控制等级就都是 internal。</p>
<p>对于元组、函数来说，访问控制等级是其内部等级最低的那个。函数必须显式声明访问等级，如果 internal 不适用的话。</p>
<span id="more"></span>

<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>访问控制用来限制外部源文件和模块对你的代码的访问。这个功能可以隐藏你的内部实现，只暴露借口给外部代码。</p>
<p>你可以对各个类型独立设定访问等级，包括类、结构体、枚举类型，你也可以对属性、方法、初始化器等单独设定访问等级。协议可以用来限定上下文，比如常、变量或者函数化。</p>
<p>Swift 为了减少显式声明访问等级，会默认对类型设定访问等级。通常如果你在开发一个单一目标的 App 你可以根本不需要手动设定访问等级。</p>
<h3 id="模块和源文件"><a href="#模块和源文件" class="headerlink" title="模块和源文件"></a>模块和源文件</h3><p>Swift 的访问控制是基于模块化概念的。</p>
<p>一个模块是代码分发的一个基础单元。一个框架或者应用可以被包装成一个单元，其他模块可以使用 <code>import</code> 关键字进行导入。</p>
<p>Xcode 中每一个构筑对象都会被作为一个模块对待。</p>
<blockquote>
<p>R：嗯，啰嗦的介绍了模块化，可是我不想啰嗦。总之模块化就对了。</p>
</blockquote>
<h3 id="访问等级"><a href="#访问等级" class="headerlink" title="访问等级"></a>访问等级</h3><p>Swift 提供五个访问等级。</p>
<ul>
<li>Open 和 Public 定义公开的访问权限，通常用于公开接口，区别下文会谈；</li>
<li>Internal 定义内部访问权限，模块外的代码无法访问，一般针对内部实现；</li>
<li>File-private 定义单文件内部访问权限，文件外无法对其进行访问，通常用于封装某个功能在一个文件中，外部不需要知道细节，即使在同一个模块；</li>
<li>Private 定义一个代码块中私有访问权限，表示这部分内容是独有的，这块代码以外是不可以访问它的。</li>
</ul>
<p>从限制程度上来看 Open 是最高级但是限制最少的，而 Private 是最低级但限制最多的。</p>
<p>Open 仅适用与类和类的成员，它与 Public 的区别如下。</p>
<ul>
<li>类标注 public 或其他访问权限时外部代码不能创建它的子类，只有模块内部才可以；</li>
<li>类的成员被标注 public 或其他访问权限时，外部子类不能对其进行覆盖，只有模块内的子类才能对其进行 <code>override</code>；</li>
<li>Open 可以让类接受外部继承；</li>
<li>Open 可以让外部子类覆盖类成员。</li>
</ul>
<p>对类设定 Open 指定这个类可以被外部继承，并且你会对次进行处理。</p>
<h3 id="访问等级指导原则"><a href="#访问等级指导原则" class="headerlink" title="访问等级指导原则"></a>访问等级指导原则</h3><p>Swift 的访问控制整体遵守这个指导原则：一个实体不能被定义为另一个访问等级低于它的实体。</p>
<p>比如：</p>
<ul>
<li>一个 public 变量不能被定义为一个 internal 或者更高访问限制的类型；</li>
<li>一个函数的访问等级不能高于它的参数和返回值。</li>
</ul>
<h3 id="默认访问等级"><a href="#默认访问等级" class="headerlink" title="默认访问等级"></a>默认访问等级</h3><p>你代码中的所有实体（除了个别情况后文会解释）都被默认设定为 internal 访问等级，通常情况下你不需要手动设定它。</p>
<h3 id="单一对象-App"><a href="#单一对象-App" class="headerlink" title="单一对象 App"></a>单一对象 App</h3><p>对于单一对象 App 来说代码时自包含的，不需要任何外部访问，默认的 internal 等级足够满足需求，所以你什么也不需要做。</p>
<h3 id="框架的访问等级"><a href="#框架的访问等级" class="headerlink" title="框架的访问等级"></a>框架的访问等级</h3><p>如果你开发一个框架，你需要其他模块使用你的 API，你需要将这些 API 设定为开放或者公开的。</p>
<h3 id="单元测试对象的访问等级"><a href="#单元测试对象的访问等级" class="headerlink" title="单元测试对象的访问等级"></a>单元测试对象的访问等级</h3><p>如果你给你写的单元测试对象在引入其他模块时标注 <code>@testable</code> 属性，这个单元测试可以访问所有模块内的实体，即使是 internal 的。这是为了方便测试目的。</p>
<h3 id="访问控制语法"><a href="#访问控制语法" class="headerlink" title="访问控制语法"></a>访问控制语法</h3><p>使用各个关键字修饰符定义访问控制的等级。例子中每列出来的有 <code>open</code> 关键字。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomePublicClass</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeInternalClass</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeFilePrivateClass</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SomePrivateClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> somePublicVariable <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">let</span> someInternalConstant <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">someFilePrivateFunction</span>()</span> &#123;&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">somePrivateFunction</span>()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>除非额外指定了访问等级，否则默认是 <code>internal</code>，上面例子中的 <code>internal</code> 关键字可省略。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeInternalClass</span> </span>&#123;&#125;              <span class="comment">// implicitly internal</span></span><br><span class="line"><span class="keyword">let</span> someInternalConstant <span class="operator">=</span> <span class="number">0</span>            <span class="comment">// implicitly internal</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>定义类型时声明访问权限。如果一个类型访问等级低于 internal，比如 private 则类型成员的访问等级都将默认为 private。但是如果一个类型访问等级高于或者等于 internal，如 public 或者 internal，则类型成员的默认等级都将为 internal。如果你需要将类型成员访问等级提高，需要手动标注修饰符。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomePublicClass</span> </span>&#123;                  <span class="comment">// explicitly public class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> somePublicProperty <span class="operator">=</span> <span class="number">0</span>            <span class="comment">// explicitly public class member</span></span><br><span class="line">    <span class="keyword">var</span> someInternalProperty <span class="operator">=</span> <span class="number">0</span>                 <span class="comment">// implicitly internal class member</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">someFilePrivateMethod</span>()</span> &#123;&#125;  <span class="comment">// explicitly file-private class member</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">somePrivateMethod</span>()</span> &#123;&#125;          <span class="comment">// explicitly private class member</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeInternalClass</span> </span>&#123;                       <span class="comment">// implicitly internal class</span></span><br><span class="line">    <span class="keyword">var</span> someInternalProperty <span class="operator">=</span> <span class="number">0</span>                 <span class="comment">// implicitly internal class member</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">someFilePrivateMethod</span>()</span> &#123;&#125;  <span class="comment">// explicitly file-private class member</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">somePrivateMethod</span>()</span> &#123;&#125;          <span class="comment">// explicitly private class member</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeFilePrivateClass</span> </span>&#123;        <span class="comment">// explicitly file-private class</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">someFilePrivateMethod</span>()</span> &#123;&#125;              <span class="comment">// implicitly file-private class member</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">somePrivateMethod</span>()</span> &#123;&#125;          <span class="comment">// explicitly private class member</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SomePrivateClass</span> </span>&#123;                <span class="comment">// explicitly private class</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">somePrivateMethod</span>()</span> &#123;&#125;                  <span class="comment">// implicitly private class member</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><p>元组类型根据自身元素的最高访问等级设定自己的访问等级。比如它有一个 internal 元素和一个 private 元素，那么这个元组就是 private 的。</p>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>函数的访问等级根据参数和返回值决定，但是必须显式标注。比如下面的例子函数得到一个 internal 参数和 private 参数，那么函数应该是 private 的，可能你预期这样声明这个函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>()</span> -&gt; (<span class="type">SomeInternalClass</span>, <span class="type">SomePrivateClass</span>) &#123;</span><br><span class="line">    <span class="comment">// function implementation goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是很可惜这样是不行的，你必须像下面这样显式声明访问等级。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>()</span> -&gt; (<span class="type">SomeInternalClass</span>, <span class="type">SomePrivateClass</span>) &#123;</span><br><span class="line">    <span class="comment">// function implementation goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举类型的 case 默认和类型拥有相同的访问等级，而且是不能独自设定的。下面的例子中所有 case 都是 public 的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> north</span><br><span class="line">    <span class="keyword">case</span> south</span><br><span class="line">    <span class="keyword">case</span> east</span><br><span class="line">    <span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类型的原始值和关联值只能高于枚举类型的访问等级。</p>
<h3 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h3><p>嵌套类型拥有和类成员相同的待遇，低于 internal 则自动和类型一致，高于 internal 则默认为 internal，除非你手动设定为更高的等级。</p>
<h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><p>在当前上下文中的类型你都可以继承。子类访问等级不能高于父类，例如父类是 internal 子类就不可以是 public。</p>
<p>此外，你可以在确定的访问等级下覆盖父类的成员。覆盖父类的成员可以提升成员的访问等级。下面的例子中子类 B 将父类 A 的 fileprivate 方法提升为了 internal 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">someMethod</span>()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">someMethod</span>()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且根据子类和父类的位置关系，子类覆盖的成员可以调用更低访问等级的父类成员。要求是子类的位置可以使用该属性。比如子类和父类在一个文件那么父类的 fileprivate 就可以被子类覆盖的成员中使用，如果子类父类在同一个模块则父类 internal 就可以被子类使用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">someMethod</span>()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">someMethod</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.someMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量、常量、属性和下标"><a href="#变量、常量、属性和下标" class="headerlink" title="变量、常量、属性和下标"></a>变量、常量、属性和下标</h3><p>访问权限不能比类型高。</p>
<h3 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h3><p>访问权限不能比属性高。可以单独设置，语法如下。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrackedString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> numberOfEdits <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            numberOfEdits <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stringToEdit <span class="operator">=</span> <span class="type">TrackedString</span>()</span><br><span class="line">stringToEdit.value <span class="operator">=</span> <span class="string">&quot;This string will be tracked.&quot;</span></span><br><span class="line">stringToEdit.value <span class="operator">+=</span> <span class="string">&quot; This edit will increment numberOfEdits.&quot;</span></span><br><span class="line">stringToEdit.value <span class="operator">+=</span> <span class="string">&quot; So will this one.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The number of edits is <span class="subst">\(stringToEdit.numberOfEdits)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The number of edits is 3&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h3><p>默认初始化器访问等级和类型相同。你可以定义不同访问等级的初始化器。</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议访问等级可以限制实现协议的上下文。</p>
<p>协议的继承会继承访问等级，不能更高。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>扩展也不能破坏访问等级。你需要遵守。</p>
<blockquote>
<p>R：总之，只能低不能高。其他就不记了，都一样的。</p>
</blockquote>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>29.<a href="https://github.com/zfanli/notes/blob/master/swift/29.MemorySafety.md">Swift Memory Safety</a></p>
<p>31.<a href="https://github.com/zfanli/notes/blob/master/swift/31.AdvancedOperators.md">Swift Advanced Operators</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>31.Swift Advanced Operators</title>
    <url>/post/notes/swift/31-AdvancedOperators/</url>
    <content><![CDATA[<p>高级操作符感觉通篇都让人感觉到 <code>Awwwwwwwa</code>，还可以这么玩。</p>
<p>你可以给你的类型自定义各种操作符下的实现。很棒吧。</p>
<p>这篇内容讲述了一些不常用但是用到就会觉得很方便的操作符。</p>
<p>包括位操作符，可以按位操作和位移操作。</p>
<p>溢出操作符，可以让数值溢出但是不报错。</p>
<p>自定义操作符。自定义自己的操作符。</p>
<p>到此语法指南就结束了。但是我仍然没看到多线程话题，Swift 没有多线程？</p>
<span id="more"></span>

<h2 id="高级操作符"><a href="#高级操作符" class="headerlink" title="高级操作符"></a>高级操作符</h2><p>Swift 中除了之前基础操作符章节描述的操作符之外，还有一些高级操作符用来处理更复杂的值操作。包括 C 或者 Objective-C 中你可能会熟悉的位操作符。</p>
<p>不同于 C，Swift 的算术操作符不存在溢出。溢出行为被视作一个陷阱并被作为错误报告。你如果选择使用溢出行为，使用 Swift 中第二套算术操作符，比如可以溢出的加法操作符 <code>&amp;+</code>。这些操作符都以 <code>&amp;</code> 开头。</p>
<p>这些操作符在你给自定义类型定制 Swift 标准操作符操作行为时比较有用。你可以给你自己定义的类型定制一套量身定做的实现来处理它们使用 Swift 标准操作符时的行为。</p>
<p>预定义的操作符没有限制，Swift 允许你定义自己的操作符。</p>
<h3 id="按位非"><a href="#按位非" class="headerlink" title="按位非"></a>按位非</h3><p>操作符是 <code>~</code>，用来二进制取反。看例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> initialBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b00001111</span></span><br><span class="line"><span class="keyword">let</span> invertedBits <span class="operator">=</span> <span class="operator">~</span>initialBits  <span class="comment">// equals 11110000</span></span><br></pre></td></tr></table></figure>

<h3 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h3><p>操作符是 <code>&amp;</code>，二进制与。看例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstSixBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b11111100</span></span><br><span class="line"><span class="keyword">let</span> lastSixBits: <span class="type">UInt8</span>  <span class="operator">=</span> <span class="number">0b00111111</span></span><br><span class="line"><span class="keyword">let</span> middleFourBits <span class="operator">=</span> firstSixBits <span class="operator">&amp;</span> lastSixBits  <span class="comment">// equals 00111100</span></span><br></pre></td></tr></table></figure>

<h3 id="按位或"><a href="#按位或" class="headerlink" title="按位或"></a>按位或</h3><p>操作符是 <code>|</code>，二进制或。看例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b10110010</span></span><br><span class="line"><span class="keyword">let</span> moreBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b01011110</span></span><br><span class="line"><span class="keyword">let</span> combinedbits <span class="operator">=</span> someBits <span class="operator">|</span> moreBits  <span class="comment">// equals 11111110</span></span><br></pre></td></tr></table></figure>

<h3 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或"></a>按位异或</h3><p>操作符是 <code>^</code>，二进制异或。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b00010100</span></span><br><span class="line"><span class="keyword">let</span> otherBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b00000101</span></span><br><span class="line"><span class="keyword">let</span> outputBits <span class="operator">=</span> firstBits <span class="operator">^</span> otherBits  <span class="comment">// equals 00010001</span></span><br></pre></td></tr></table></figure>

<h3 id="按位左偏移·右偏移"><a href="#按位左偏移·右偏移" class="headerlink" title="按位左偏移·右偏移"></a>按位左偏移·右偏移</h3><p>数字有无符号影响按位偏移行为。</p>
<p>对于无符号的数字：</p>
<ul>
<li>位根据要求向左右偏移；</li>
<li>超过边界的数字被抛弃；</li>
<li>空位补零。</li>
</ul>
<p>看例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shiftBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">4</span>   <span class="comment">// 00000100 in binary</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">1</span>             <span class="comment">// 00001000</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">2</span>             <span class="comment">// 00010000</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">5</span>             <span class="comment">// 10000000</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">6</span>             <span class="comment">// 00000000</span></span><br><span class="line">shiftBits <span class="operator">&gt;&gt;</span> <span class="number">2</span>             <span class="comment">// 00000001</span></span><br></pre></td></tr></table></figure>

<p>你可以在其他数据类型上使用位偏移。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pink: <span class="type">UInt32</span> <span class="operator">=</span> <span class="number">0xCC6699</span></span><br><span class="line"><span class="keyword">let</span> redComponent <span class="operator">=</span> (pink <span class="operator">&amp;</span> <span class="number">0xFF0000</span>) <span class="operator">&gt;&gt;</span> <span class="number">16</span>    <span class="comment">// redComponent is 0xCC, or 204</span></span><br><span class="line"><span class="keyword">let</span> greenComponent <span class="operator">=</span> (pink <span class="operator">&amp;</span> <span class="number">0x00FF00</span>) <span class="operator">&gt;&gt;</span> <span class="number">8</span>   <span class="comment">// greenComponent is 0x66, or 102</span></span><br><span class="line"><span class="keyword">let</span> blueComponent <span class="operator">=</span> pink <span class="operator">&amp;</span> <span class="number">0x0000FF</span>           <span class="comment">// blueComponent is 0x99, or 153</span></span><br></pre></td></tr></table></figure>

<p>上面的例子实际上做的是将一个 pink 颜色值 16 进制转换成三个数字对于 RGB 颜色值。三个 <code>&amp;</code> 操作是为了做一个遮罩，只留下 <code>FF</code> 位置的值，后面的位移操作是为了降位，因为 RGB 是三个最大为 255 或者 FF 的值。</p>
<p>如果一个数字有符号，行为会稍微不一样。</p>
<p>有符号的数字用第一位表示正负号。但是负数的表述和正数相反，比如 <code>1111100</code> 是 124，但是如果符号位是 1，即 <code>11111100</code>，则表述的是 -4。无符号时数值是字面量，负数时 1 表示 0 ，0 表示 1。</p>
<p>对负数来说向右位移左边补 1，向左位移符号位不变，右边补 0。</p>
<h3 id="溢出操作符"><a href="#溢出操作符" class="headerlink" title="溢出操作符"></a>溢出操作符</h3><p>默认情况下当你复制一个超过类型容纳上限的值给一个变量，Swift 不会创建它，并且会报错。这是一个安全保障。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> potentialOverflow <span class="operator">=</span> <span class="type">Int16</span>.max</span><br><span class="line"><span class="comment">// potentialOverflow equals 32767, which is the maximum value an Int16 can hold</span></span><br><span class="line">potentialOverflow <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// this causes an error</span></span><br></pre></td></tr></table></figure>

<p>此时需要进行错误处理。</p>
<p>不过如果你要做的就是按位裁切，你可以使用另一套算数操作符。</p>
<ul>
<li>Overflow addition (&amp;+)</li>
<li>Overflow subtraction (&amp;-)</li>
<li>Overflow multiplication (&amp;*)</li>
</ul>
<h3 id="值溢出"><a href="#值溢出" class="headerlink" title="值溢出"></a>值溢出</h3><p>下面例子对 8 位最大数字加 1 导致值溢出，溢出位抛弃，留下的值就是 0。无符号。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unsignedOverflow <span class="operator">=</span> <span class="type">UInt8</span>.max</span><br><span class="line"><span class="comment">// unsignedOverflow equals 255, which is the maximum value a UInt8 can hold</span></span><br><span class="line">unsignedOverflow <span class="operator">=</span> unsignedOverflow <span class="operator">&amp;+</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// unsignedOverflow is now equal to 0</span></span><br></pre></td></tr></table></figure>

<p>下面的例子对 8 位最小数字减 1，导致溢出，值变成 255。这是对无符号数来说的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unsignedOverflow <span class="operator">=</span> <span class="type">UInt8</span>.min</span><br><span class="line"><span class="comment">// unsignedOverflow equals 0, which is the minimum value a UInt8 can hold</span></span><br><span class="line">unsignedOverflow <span class="operator">=</span> unsignedOverflow <span class="operator">&amp;-</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// unsignedOverflow is now equal to 255</span></span><br></pre></td></tr></table></figure>

<p>如果有符号，最小数减 1，还是变成最大数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> signedOverflow <span class="operator">=</span> <span class="type">Int8</span>.min</span><br><span class="line"><span class="comment">// signedOverflow equals -128, which is the minimum value an Int8 can hold</span></span><br><span class="line">signedOverflow <span class="operator">=</span> signedOverflow <span class="operator">&amp;-</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// signedOverflow is now equal to 127</span></span><br></pre></td></tr></table></figure>

<h3 id="优先和结合"><a href="#优先和结合" class="headerlink" title="优先和结合"></a>优先和结合</h3><p>操作符有优先顺序，看看下面的例子，优先顺序和数学上定义一致。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="operator">+</span> <span class="number">3</span> <span class="operator">%</span> <span class="number">4</span> <span class="operator">*</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// this equals 17</span></span><br></pre></td></tr></table></figure>

<p>取余数和乘法操作符优先度高于加法，所以加法会最后执行。</p>
<h3 id="操作符方法"><a href="#操作符方法" class="headerlink" title="操作符方法"></a>操作符方法</h3><p>结构体和类可以对现有操作符进行自己的实现。这被称作现有操作符重载。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">+</span> (<span class="params">left</span>: <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>)</span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Vector2D</span>(x: left.x <span class="operator">+</span> right.x, y: left.y <span class="operator">+</span> right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子定义了对 Vector2D 类型对数据进行加法操作的实现。</p>
<p>通过对两个实例进行加法操作你可以得到预期的结果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherVector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> combinedVector <span class="operator">=</span> vector <span class="operator">+</span> anotherVector</span><br><span class="line"><span class="comment">// combinedVector is a Vector2D instance with values of (5.0, 5.0)</span></span><br></pre></td></tr></table></figure>

<h3 id="前缀和后缀操作符"><a href="#前缀和后缀操作符" class="headerlink" title="前缀和后缀操作符"></a>前缀和后缀操作符</h3><p>下面定义一个前缀一元操作符。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> <span class="title">-</span> (<span class="params">vector</span>: <span class="type">Vector2D</span>)</span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="operator">-</span>vector.x, y: <span class="operator">-</span>vector.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这样定义，我们可以对 Vector2D 取反。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> positive <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> negative <span class="operator">=</span> <span class="operator">-</span>positive</span><br><span class="line"><span class="comment">// negative is a Vector2D instance with values of (-3.0, -4.0)</span></span><br><span class="line"><span class="keyword">let</span> alsoPositive <span class="operator">=</span> <span class="operator">-</span>negative</span><br><span class="line"><span class="comment">// alsoPositive is a Vector2D instance with values of (3.0, 4.0)</span></span><br></pre></td></tr></table></figure>

<h3 id="组合操作符"><a href="#组合操作符" class="headerlink" title="组合操作符"></a>组合操作符</h3><p>下面定义一个组合操作符，其实定义和加法一样。区别在于左边是 In-Out 参数，直接修改它的值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">+=</span> (<span class="params">left</span>: <span class="keyword">inout</span> <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>)</span> &#123;</span><br><span class="line">        left <span class="operator">=</span> left <span class="operator">+</span> right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> original <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">let</span> vectorToAdd <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line">original <span class="operator">+=</span> vectorToAdd</span><br><span class="line"><span class="comment">// original now has values of (4.0, 6.0)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：等号操作符和三元操作符无法重载。关于赋值操作符只有类似 += 的组合操作符可以重载。</p>
</blockquote>
<h3 id="等价比较操作符"><a href="#等价比较操作符" class="headerlink" title="等价比较操作符"></a>等价比较操作符</h3><p>可以用双等号判断。一般我们自己实现 == 操作符，标准库会默认实现 !=，实现的方式就是对 == 的结果取反。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Vector2D</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">==</span> (<span class="params">left</span>: <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (left.x <span class="operator">==</span> right.x) <span class="operator">&amp;&amp;</span> (left.y <span class="operator">==</span> right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> twoThree <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherTwoThree <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">if</span> twoThree <span class="operator">==</span> anotherTwoThree &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;These two vectors are equivalent.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;These two vectors are equivalent.&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子自己实现了 == 操作，实际上满足下面的情况标准库可以自动帮助我们实现。</p>
<ul>
<li>实现 <code>Equatable</code> 协议的结构体只有储值属性；</li>
<li>枚举类型只有实现了 <code>Equatable</code> 协议的关联值；</li>
<li>枚举类型没有关联值。</li>
</ul>
<p>下面是自动实现的例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector3D</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span>, z <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> twoThreeFour <span class="operator">=</span> <span class="type">Vector3D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>, z: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherTwoThreeFour <span class="operator">=</span> <span class="type">Vector3D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>, z: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">if</span> twoThreeFour <span class="operator">==</span> anotherTwoThreeFour &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;These two vectors are also equivalent.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;These two vectors are also equivalent.&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义操作符"><a href="#自定义操作符" class="headerlink" title="自定义操作符"></a>自定义操作符</h3><p>自定义操作符用 <code>operator</code> 关键字配合 <code>prefix</code>、<code>infix</code> 或 <code>postfix</code> 关键字声明，需要在全局作用域。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> <span class="title">+++</span></span><br></pre></td></tr></table></figure>

<p>注意这样声明只是告诉 Swift 存在一个这样的操作符，但是它并没有其他含义。然后我们再对具体的类型实现这个操作符的操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> <span class="title">+++</span> (<span class="params">vector</span>: <span class="keyword">inout</span> <span class="type">Vector2D</span>)</span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        vector <span class="operator">+=</span> vector</span><br><span class="line">        <span class="keyword">return</span> vector</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toBeDoubled <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> afterDoubling <span class="operator">=</span> <span class="operator">+++</span>toBeDoubled</span><br><span class="line"><span class="comment">// toBeDoubled now has values of (2.0, 8.0)</span></span><br><span class="line"><span class="comment">// afterDoubling also has values of (2.0, 8.0)</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义中缀操作符优先级"><a href="#自定义中缀操作符优先级" class="headerlink" title="自定义中缀操作符优先级"></a>自定义中缀操作符优先级</h3><p>中缀操作符需要定义优先级分组。一个优先级分组表示这个中缀操作符在执行时的优先顺序。默认优先级分组是高于二元操作符的。下面定义了一个操作符 +- 并设定为 <code>AdditionPrecedence</code> 优先级。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">+-</span>: <span class="type">AdditionPrecedence</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">+-</span> (<span class="params">left</span>: <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>)</span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Vector2D</span>(x: left.x <span class="operator">+</span> right.x, y: left.y <span class="operator">-</span> right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> firstVector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">let</span> secondVector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> plusMinusVector <span class="operator">=</span> firstVector <span class="operator">+-</span> secondVector</span><br><span class="line"><span class="comment">// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：文档提示，你不需要给前缀和后缀操作符设定优先级，但是如果你同时使用前缀和后缀操作一个元素，那么后缀会先执行。</p>
</blockquote>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>30.<a href="https://github.com/zfanli/notes/blob/master/swift/30.AccessControl.md">Swift Access Control</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>4.Swift Syntax Basics (函数和闭包)</title>
    <url>/post/notes/swift/4-SyntaxBasics-Functions-Closures/</url>
    <content><![CDATA[<p>函数都明白，但是闭包是什么？其实就是匿名函数。</p>
<p>闭包实际上指的是一块封闭的作用域，里面有一串代码，外面影响不到里面。</p>
<p>而函数是闭包的一种形态，就是有名字的闭包。如果不给名字，就是匿名函数，匿名的闭包。通常同时说函数和闭包时，应该是在说一般函数和匿名函数。</p>
<p>在 Swift 中，闭包是头等类型的（first-class），可以作为参数接收，也可以作为返回值返回。</p>
<span id="more"></span>

<p>声明一个函数或匿名函数的时候需要定义参数和返回值，参数写在括号中，用 <code>-&gt;</code> 于返回值分隔开。匿名闭包作为回调函数时，由于类型是已知的，可以省略不写。</p>
<p>另外不同于 JavaScript 的箭头函数和 Java 的 Lambda 表达式，Swift 中的匿名闭包包括参数返回值定义都是写在大括号里面的，参数返回值定义和代码体之间用 <code>in</code> 关键字来分隔。</p>
<p>函数可以使用元组返回多个返回值。</p>
<h2 id="函数和闭包"><a href="#函数和闭包" class="headerlink" title="函数和闭包"></a>函数和闭包</h2><p>使用 <code>func</code> 关键字声明一个函数。使用 <code>-&gt;</code> 区分函数参数和返回值类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span>(<span class="params">person</span>: <span class="type">String</span>, <span class="params">day</span>: <span class="type">String</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello <span class="subst">\(person)</span>, today is <span class="subst">\(day)</span>.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">greet(person: <span class="string">&quot;Bob&quot;</span>, day: <span class="string">&quot;Tuesday&quot;</span>)</span><br><span class="line"><span class="comment">// &quot;Hello Bob, today is Tuesday.&quot;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，函数使用参数名作为参数的标签。你可以在参数名的前面自定义标签，或者用 <code>_</code> 表示不使用标签。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span>(<span class="keyword">_</span> <span class="params">person</span>: <span class="type">String</span>, <span class="params">on</span> <span class="params">day</span>: <span class="type">String</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello <span class="subst">\(person)</span>, today is <span class="subst">\(day)</span>.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">greet(<span class="string">&quot;John&quot;</span>, on: <span class="string">&quot;Wednesday&quot;</span>)</span><br><span class="line"><span class="comment">// &quot;Hello John, today is Wednesday.&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用元组来组合值，可以用来让函数返回多个值。元组的元素可以通过名称或者索引访问。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateStatistics</span>(<span class="params">scores</span>: [<span class="type">Int</span>])</span> -&gt; (min: <span class="type">Int</span>, max: <span class="type">Int</span>, sum: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> min <span class="operator">=</span> scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> max <span class="operator">=</span> scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> sum <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> score <span class="keyword">in</span> scores &#123;</span><br><span class="line">        <span class="keyword">if</span> score <span class="operator">&gt;</span> max &#123;</span><br><span class="line">            max <span class="operator">=</span> score</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> score <span class="operator">&lt;</span> min &#123;</span><br><span class="line">            min <span class="operator">=</span> score</span><br><span class="line">        &#125;</span><br><span class="line">        sum <span class="operator">+=</span> score</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (min, max, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> statistics <span class="operator">=</span> calculateStatistics(scores: [<span class="number">5</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(statistics.sum)</span><br><span class="line"><span class="comment">// prints 120</span></span><br><span class="line"><span class="built_in">print</span>(statistics.<span class="number">2</span>)</span><br><span class="line"><span class="comment">// prints 120</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：元组（Tuple）的概念应该是来自 Python。通过索引访问元素时是 0 基的。</p>
</blockquote>
<p>函数可以嵌套。嵌套函数可以访问外面一层函数定义的变量。你可以用嵌套函数来组织一个很长的，或者很复杂的函数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnFifteen</span>()</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span>()</span> &#123;</span><br><span class="line">        y <span class="operator">+=</span> <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    add()</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">returnFifteen()</span><br><span class="line"><span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>函数是头等类型的（first-class）。函数可以返回一个函数作为其返回值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementer</span>()</span> -&gt; ((<span class="type">Int</span>) -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addOne</span>(<span class="params">number</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="operator">+</span> number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addOne</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> increment <span class="operator">=</span> makeIncrementer()</span><br><span class="line">increment(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>函数也可以将另一个函数作为一个参数获取。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasAnyMatches</span>(<span class="params">list</span>: [<span class="type">Int</span>], <span class="params">condition</span>: (<span class="type">Int</span>) -&gt; <span class="type">Bool</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> condition(item) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lessThanTen</span>(<span class="params">number</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number <span class="operator">&lt;</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> numbers <span class="operator">=</span> [<span class="number">20</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">12</span>]</span><br><span class="line">hasAnyMatches(list: numbers, condition: lessThanTen)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：支持头等函数（first-class functions）的语言可以将函数作为一个对象进行传递。动态语言中 JavaScript 和 Python 等支持，静态语言中 Golang 和 Swift 等支持，Java 不支持。</p>
</blockquote>
<blockquote>
<p>R：然后开始讲闭包。</p>
</blockquote>
<p>函数实际上是闭包的一种情况：一块代码可以在之后被执行。闭包中的代码可以访问创建闭包的作用域下可用的变量和函数，即使当你真正执行它的时候是在另一个作用域中。你已经看到了，嵌套函数就是这样的。可以创建一个匿名的闭包，使用大括号包围一块代码，用 <code>in</code> 关键字分隔参数返回值定义和代码体。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">numbers.map(&#123; (number: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="number">3</span> <span class="operator">*</span> number</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：闭包一般指的是匿名函数呀。函数是有名字的闭包。</p>
</blockquote>
<p>闭包可以写的更简单。如果闭包的类型是已知的，这种情况一般是指派回调函数时，你可以省略参数定义，或者返回值定义，或者全都省略。单语句的闭包隐式的将语句的结果作为返回值返回。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mappedNumbers <span class="operator">=</span> numbers.map(&#123; number <span class="keyword">in</span> <span class="number">3</span> <span class="operator">*</span> number &#125;)</span><br><span class="line"><span class="built_in">print</span>(mappedNumbers)</span><br><span class="line"><span class="comment">// prints &quot;[60, 57, 21, 36]&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：JavaScript 和 Python 中常见的匿名函数写法。</p>
</blockquote>
<p>你可以不使用变量名，使用数字来获取变量。在写简短的闭包时会非常有用。当闭包作为函数的最后一个参数时可以将闭包放在括号的外面，如果这个函数仅接收一个闭包作为参数，你甚至可以把括号都省了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sortedNumbers <span class="operator">=</span> numbers.sorted &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(sortedNumbers)</span><br><span class="line"><span class="comment">// prints &quot;[20, 19, 12, 7]&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>3.<a href="https://github.com/zfanli/notes/blob/master/swift/3.SyntaxBasicsPart2.md">Swift Syntax Basics (流程控制)</a></p>
<p>5.<a href="https://github.com/zfanli/notes/blob/master/swift/5.SyntaxBasics(Objects&Classes).md">Swift Syntax Basics (对象和类)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>5.Swift Syntax Basics (对象和类)</title>
    <url>/post/notes/swift/5-SyntaxBasics-Objects-Classes/</url>
    <content><![CDATA[<p>Swift 中创建一个类、创建一个对象、访问对象的属性等操作和一般的 OOP 语言并无两样。</p>
<p>相对特殊一点的是，Java 中的构造器在 Swift 是初始化器，并且还有一个卸载器与之对应，用 <code>init</code> 和 <code>deinit</code> 表示。</p>
<p>另外特殊的一点是，Swift 的类中所有声明的变量都需要赋值，无论是声明时赋值或者初始化器中赋值。继承关系通过类名后接冒号接父类名，对父类方法的覆盖需要显式的 <code>override</code> 前缀，如果复写的方法在父类中不存在，编译时会报错。</p>
<span id="more"></span>

<p>类的属性可以定义 setter 和 getter。在对变量进行读取和赋值操作的时候进行一些额外的操作。另外还有 willSet 和 didSet 可以在 setter 调用前后执行一些操作，更加灵活。</p>
<p>如果一个对象可能是 <code>nil</code>，那么对它进行任何操作前可以使用 <code>?</code> 快速处理，如果它真的是 <code>nil</code>，后续操作不会执行。</p>
<h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><p>使用 <code>class</code> 关键字创建一个类。属性和方法的声明和平时并无区别。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A shape with <span class="subst">\(numberOfSides)</span> sides.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化一个类，使用点语法访问对象的属性和方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shape <span class="operator">=</span> <span class="type">Shape</span>()</span><br><span class="line">shape.numberOfSides <span class="operator">=</span> <span class="number">7</span></span><br><span class="line"><span class="keyword">var</span> shapeDescription <span class="operator">=</span> shape.simpleDescription()</span><br><span class="line"><span class="comment">// &quot;A shape with 7 sides.&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：也是和 OOP 并无两样。</p>
</blockquote>
<p>类的初始化器可以在创建对象时做些自定义。使用 <code>init()</code> 来做初始化。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">       <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;A shape with <span class="subst">\(numberOfSides)</span> sides.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：<code>init()</code> 注意没有 func 前缀，是个特殊的构造。作用就是 Java 的构造函数。</p>
</blockquote>
<p><code>init()</code> 会在创建对象的时候被调用。注意类的所有属性都需要赋值，赋值操作可以直接声明，也可以在初始化器中赋值，例如上面的例子中的两个属性。</p>
<p>还有一个 <code>deinit()</code> 可以在对象被释放时做一些操作，或许应该叫卸载器？在对象被销毁时做一些清洁操作比较实用。</p>
<blockquote>
<p>R：<code>init()</code> 和 <code>deinit()</code> 就是对象生命周期中的初始化和销毁时自定义的操作。一个钩子。</p>
</blockquote>
<p>定义一个子类，在声明类名的时候用冒号分隔父类名。创建类时没有要求继承任何顶级父类，所以你可以根据需要继承某个父类，或者省略父类。</p>
<p>在子类中如果要覆盖父类的方法实现需要显式的 <code>override</code> 前缀。如果没有前缀，在子类中定义了和父类方法同名的函数时，编译器会报错。如果有 <code>override</code> 前缀但实际上父类没有这个方法时同样会报错。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>: <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">sideLength</span>: <span class="type">Double</span>, <span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength <span class="operator">=</span> sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides <span class="operator">=</span> <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">area</span>()</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sideLength <span class="operator">*</span> sideLength</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A square with sides of length <span class="subst">\(sideLength)</span>.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test <span class="operator">=</span> <span class="type">Square</span>(sideLength: <span class="number">5.2</span>, name: <span class="string">&quot;my test square&quot;</span>)</span><br><span class="line">test.area()</span><br><span class="line"><span class="comment">// 27.04</span></span><br><span class="line">test.simpleDescription()</span><br><span class="line"><span class="comment">// &quot;A square with sides of length 5.2.&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以给属性定义 getter 和 setter 简化属性储存。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EquilateralTriangle</span>: <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">sideLength</span>: <span class="type">Double</span>, <span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength <span class="operator">=</span> sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> perimeter: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">3.0</span> <span class="operator">*</span> sideLength</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            sideLength <span class="operator">=</span> newValue <span class="operator">/</span> <span class="number">3.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;An equilateral triangle with sides of length <span class="subst">\(sideLength)</span>.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> triangle <span class="operator">=</span> <span class="type">EquilateralTriangle</span>(sideLength: <span class="number">3.1</span>, name: <span class="string">&quot;a triangle&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(triangle.perimeter)</span><br><span class="line"><span class="comment">// prints 9.3</span></span><br><span class="line">triangle.perimeter <span class="operator">=</span> <span class="number">9.9</span></span><br><span class="line"><span class="built_in">print</span>(triangle.sideLength)</span><br><span class="line"><span class="comment">// prints 3.3000000000000003</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：看上去像 Vue 中的 <code>computed</code> 和 <code>watch</code>。属性本身不储存值，需要的时候计算出来，赋值的时候也经过计算。普通的赋值用不上 setter 和 getter，只有那种修改某个值影响其他值的情况才需要。</p>
</blockquote>
<p>上面这个例子，在 <code>perimeter</code> 的 setter 中，新的值默认被赋予 <code>newValue</code> 名称，如要自定义名称，添加在 set 关键字后面。</p>
<p>注意初始化器的不同。</p>
<ul>
<li>给子类声明的属性赋值</li>
<li>调用父类的初始化器</li>
<li>修改父类属性的值（此时类的方法、getter、setter 是有效的）</li>
</ul>
<p>如果你需要的不是计算属性，而是在属性的值变更前后作出相应的操作，可以使用 <code>willSet</code> 和 <code>didSet</code> 钩子。定义的代码将在初始化器之外每次被更改时被执行。例如下面的类保证三角形的边长始终保持和四边形的边长一致。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TriangleAndSquare</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> triangle: <span class="type">EquilateralTriangle</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            square.sideLength <span class="operator">=</span> newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> square: <span class="type">Square</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            triangle.sideLength <span class="operator">=</span> newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">size</span>: <span class="type">Double</span>, <span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        square <span class="operator">=</span> <span class="type">Square</span>(sideLength: size, name: name)</span><br><span class="line">        triangle <span class="operator">=</span> <span class="type">EquilateralTriangle</span>(sideLength: size, name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> triangleAndSquare <span class="operator">=</span> <span class="type">TriangleAndSquare</span>(size: <span class="number">10</span>, name: <span class="string">&quot;another test shape&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.square.sideLength)</span><br><span class="line"><span class="comment">// prints 10</span></span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br><span class="line"><span class="comment">// prints 10</span></span><br><span class="line">triangleAndSquare.square <span class="operator">=</span> <span class="type">Square</span>(sideLength: <span class="number">50</span>, name: <span class="string">&quot;larger square&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br><span class="line"><span class="comment">// prints 50</span></span><br></pre></td></tr></table></figure>

<p>但一个值是可选的时候，在调用方法、访问属性或者订阅的时候可以在前面加上 <code>?</code>。如果这个值是 <code>nil</code>，则之后的处理都不会执行，表达式会返回 <code>nil</code> 作为结果。反之后面的操作会对这个值进行处理。使用 <code>?</code> 后这个表达式的值也将变成可选的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> optionalSquare: <span class="type">Square</span>? <span class="operator">=</span> <span class="type">Square</span>(sideLength: <span class="number">2.5</span>, name: <span class="string">&quot;optional square&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> sideLength <span class="operator">=</span> optionalSquare<span class="operator">?</span>.sideLength</span><br></pre></td></tr></table></figure>

<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>4.<a href="https://github.com/zfanli/notes/blob/master/swift/4.SyntaxBasics(Functions&Closures).md">Swift Syntax Basics (函数和闭包)</a></p>
<p>6.<a href="https://github.com/zfanli/notes/blob/master/swift/6.SyntaxBasics(Enumerations&Structures).md">Swift Syntax Basics (枚举类型和结构体)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>6.Swift Syntax Basics (枚举类型和结构体)</title>
    <url>/post/notes/swift/6-SyntaxBasics-Enumerations-Structures/</url>
    <content><![CDATA[<p>Swift 中的枚举类型看上去颇为强大。有点让我对枚举类型产生类改观。</p>
<p>Swift 的枚举类型有三种属性，一个 case 值；每个 case 还可以拥有一个原始值，这个值在所有实例中是相同的；每个 case 还可以定义关联值，关联值在创建 case 实例的时候定义，每个实例是不一样的。枚举类型可以有方法。</p>
<p>结构体和类非常类似，同样有属性有方法，还有初始化器，与类相比最大的不同在于结构体的传递是复制，而类是引用。在 Java 或者 JS 中，一个对象传递给另一个方法之后，对原始对象进行操作还是会反应到全局上，其原因是变量只定位到对象到引用，而结构体不同，变量与对象直接绑定，变量传递的也是复制后的新对象，传递前后的对象互为独立的个体，不会相互影响。</p>
<p>结构体和类可以轻易区分使用场景。但是枚举类型也可以有方法，这样看上去它和类也很相似，除了它不能拥有属性之外。</p>
<span id="more"></span>

<h2 id="枚举类型和结构体"><a href="#枚举类型和结构体" class="headerlink" title="枚举类型和结构体"></a>枚举类型和结构体</h2><p>使用 <code>enum</code> 创建一个枚举类型。枚举类型可以像类或其他类型一样拥有相关的方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Rank</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> ace <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> two, three, four, five, six, seven, eight, nine, ten</span><br><span class="line">    <span class="keyword">case</span> jack, queen, king</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .ace:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ace&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .jack:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;jack&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .queen:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;queen&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .king:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;king&quot;</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ace <span class="operator">=</span> <span class="type">Rank</span>.ace</span><br><span class="line"><span class="comment">// ace</span></span><br><span class="line"><span class="keyword">let</span> aceRawValue <span class="operator">=</span> ace.rawValue</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>默认情况 Swift 会给枚举类型的每个类型从 0 开始赋值，你可以显式的赋值改变这个行为。上面的例子中，ace 被显式赋值为 1，所以剩余的类型根据顺序从 1 开始赋值。也可以使用字符串或者浮点数来作为枚举类型的原始值。使用 <code>rawValue</code> 来访问一个枚举类型的原始值。</p>
<p>使用 <code>init?(rawValue:)</code> 初始化器来取得一个指定原始值的枚举类型。如果这个枚举类型存在匹配该原始值的 case 则返回该 case，否则会返回 <code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> convertedRank <span class="operator">=</span> <span class="type">Rank</span>(rawValue: <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> threeDescription <span class="operator">=</span> convertedRank.simpleDescription()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：<code>init?(rawValue:)</code> 的 <code>init?</code> 感觉是可选的初始化器。就类似于构造器的使用，初始化器的使用也是以类名后面加括号的方式。枚举类型相当于一个特使的类。</p>
</blockquote>
<p>枚举类型中 case 的值是一个实际的值，而不是指它的原始值。实际上如果没有必要的话，举类型可以不设定原始值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> spades, hearts, diamonds, clubs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .spades:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;spades&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .hearts:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;hearts&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .diamonds:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;diamonds&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .clubs:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;clubs&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> hearts <span class="operator">=</span> <span class="type">Suit</span>.hearts</span><br><span class="line"><span class="keyword">let</span> heartsDescription <span class="operator">=</span> hearts.simpleDescription()</span><br><span class="line"><span class="comment">// &quot;hearts&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，给常量 hearts 赋值时使用 <code>Suit.hearts</code> 的方式，但是在 Suit 内部访问某个 case 时，使用 <code>.hearts</code> 省略了 Suit。这是两种引用方式，通常如果值的类型是已知的，你都可以使用省略点前面的形式。这时值会从 self 对象中读取。</p>
<blockquote>
<p>R：在 Suit 中访问自身的 case 可以省略主体，这时点前面被省略的部分应该是 <code>self</code>。</p>
</blockquote>
<p>枚举类型的 case 的原始值对每个枚举类型的实例来说都是相同的。但是枚举类型也可以给每个 case 定义关联的值，这些值是在你声明一个枚举类型对象时定义的，它们可以是不相同的。这可以看作是枚举类型 case 储存的属性。例如，从服务器请求日出和日落的时间，此时服务器可能会返回请求的信息，也可能返回一个报错信息。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ServerResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> result(<span class="type">String</span>, <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> success <span class="operator">=</span> <span class="type">ServerResponse</span>.result(<span class="string">&quot;6:00 am&quot;</span>, <span class="string">&quot;8:09 pm&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> failure <span class="operator">=</span> <span class="type">ServerResponse</span>.failure(<span class="string">&quot;Out of cheese.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> success &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .result(sunrise, sunset):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Sunrise is at <span class="subst">\(sunrise)</span> and sunset is at <span class="subst">\(sunset)</span>.&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .failure(message):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Failure...  <span class="subst">\(message)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意日出日落时间是如何从枚举类型的 case 中提取出来的。</p>
<blockquote>
<p>R：这看上去是没见过的套路。枚举类型的 case 可以存储变量，这些变量在创建这些 case 相应的实例的时候赋值，并且可以通过 switch 读取出来。看上去很适合做数据修改时的 payload。</p>
</blockquote>
<p>使用 <code>struct</code> 创建一个结构体。结构体和类很相似，可以拥有方法和初始化器。结构体和类最大的不同之处在于，结构体的传递永远是复制数据，而类的传递只传递引用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rank: <span class="type">Rank</span></span><br><span class="line">    <span class="keyword">var</span> suit: <span class="type">Suit</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The <span class="subst">\(rank.simpleDescription())</span> of <span class="subst">\(suit.simpleDescription())</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> threeOfSpades <span class="operator">=</span> <span class="type">Card</span>(rank: .three, suit: .spades)</span><br><span class="line"><span class="keyword">let</span> threeOfSpadesDescription <span class="operator">=</span> threeOfSpades.simpleDescription()</span><br><span class="line"><span class="comment">// &quot;The 3 of spades&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：结构体实例化的对象是一个数据，而类实例化对象是一个引用。从 <code>let</code> 常量就可以看出来区别，结构体定义时使用 <code>let</code> 关键字时，对对象的属性进行修改会报错，编译器检测到对常量到修改，而相同情况下类则不会报错，因为其拿到的只是一个引用。看上去从安全程度上类更高一些，但是结构体应该会占用更多内存资源。</p>
</blockquote>
<h2 id="练习：打印一套-52-张扑克牌"><a href="#练习：打印一套-52-张扑克牌" class="headerlink" title="练习：打印一套 52 张扑克牌"></a>练习：打印一套 52 张扑克牌</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Suit</span>: <span class="title">CaseIterable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Rank</span>: <span class="title">CaseIterable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Suit</span>.allCases.forEach(&#123;s <span class="keyword">in</span></span><br><span class="line">    <span class="type">Rank</span>.allCases.forEach(&#123;r <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> card <span class="operator">=</span> <span class="type">Card</span>(rank: r, suit: s)</span><br><span class="line">        <span class="built_in">print</span>(card.simpleDescription())</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：枚举类型不能直接 for-in 遍历，这时可以让枚举类型扩展 CaseInterable 接口实现遍历功能，使用 forEach 方法遍历。</p>
</blockquote>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>5.<a href="https://github.com/zfanli/notes/blob/master/swift/5.SyntaxBasics(Objects&Classes).md">Swift Syntax Basics (对象和类)</a></p>
<p>7.<a href="https://github.com/zfanli/notes/blob/master/swift/7.SyntaxBasics(Protocols&Extensions).md">Swift Syntax Basics (枚举类型和结构体)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>7.Swift Syntax Basics (协议和扩展)</title>
    <url>/post/notes/swift/7-SyntaxBasics-Protocols-Extensions/</url>
    <content><![CDATA[<p>在 Swift 中称为协议，这个概念一听之下很陌生，但却是一个熟悉的概念。在 Java 中它叫接口，是面向接口编程的核心。它定义了一套规范，所有实现协议的类、枚举类型或者结构体都有相同的特征，它们属于本身类型之外还属于这个协议的子类型。但是如果使用协议作为一个变量的类型，并且将一个实现了该协议的对象赋值给它，虽然在运行时它的类型是协议的子类型，但在编译时会将其作为协议类型对待，这意味着你不能使用非协议定义的属性和方法。</p>
<p>扩展是一个很灵活的机制，在 Java 中没看到对应的实现，除非使用反射机制吧。</p>
<p>扩展允许在声明一个类型之后对该类型进行扩展，比较类似的可能是其他语言的 Mixin 机制了吧。不仅是自己声明的类型，外来引入的库或者框架的类型都是可以扩展的。</p>
<span id="more"></span>

<p>协议和扩展的内容比较少。对于初级入门来说信息量已经足够了吧。</p>
<h2 id="协议和扩展"><a href="#协议和扩展" class="headerlink" title="协议和扩展"></a>协议和扩展</h2><p>使用 <code>protocol</code> 声明一个协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">     <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span>()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类、枚举类型、结构体都可以实现（adopt）协议。</p>
<blockquote>
<p>R：官方采用 Adopt 表达实现这个动作，这个词是接受和开始使用一个新东西的意思。在 Java 中实现是 Implement，这个词是指开始实施一个新的计划或者使用一个新的系统。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> simpleDescription: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;A very simple class.&quot;</span></span><br><span class="line">     <span class="keyword">var</span> anotherProperty: <span class="type">Int</span> <span class="operator">=</span> <span class="number">69105</span></span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">adjust</span>()</span> &#123;</span><br><span class="line">          simpleDescription <span class="operator">+=</span> <span class="string">&quot;  Now 100% adjusted.&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="type">SimpleClass</span>()</span><br><span class="line">a.adjust()</span><br><span class="line"><span class="keyword">let</span> aDescription <span class="operator">=</span> a.simpleDescription</span><br><span class="line"><span class="comment">// &quot;A very simple class.  Now 100% adjusted.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimpleStructure</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> simpleDescription: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;A simple structure&quot;</span></span><br><span class="line">     <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span>()</span> &#123;</span><br><span class="line">          simpleDescription <span class="operator">+=</span> <span class="string">&quot; (adjusted)&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b <span class="operator">=</span> <span class="type">SimpleStructure</span>()</span><br><span class="line">b.adjust()</span><br><span class="line"><span class="keyword">let</span> bDescription <span class="operator">=</span> b.simpleDescription</span><br><span class="line"><span class="comment">// &quot;A simple structure (adjusted)&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意 ⚠️，在 SimpleStructure 中 adjust() 方法名前面的 <code>mutating</code> 关键字表示这个方法会修改结构体的属性。在 SimpleClass 中不需要这个关键字，因为类的方法可以随时修改自己的属性。</p>
<blockquote>
<p>R：协议就是 Java 中的接口呀？Swift 中难不成有面向协议编程的概念吗？可以从例子中看出来，实现一个协议和继承一个父类的写法是一致的。</p>
</blockquote>
<p>使用 <code>extension</code> 给一个现有类型扩展计算属性或者方法等功能性。你可以使用扩展机制给一个类型实现某个协议，这个类型可以是别处定义的，也可以是从其他库或者框架中导入的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The number <span class="subst">\(<span class="keyword">self</span>)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">+=</span> <span class="number">42</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">7</span>.simpleDescription)</span><br><span class="line"><span class="comment">// prints &quot;The number 7&quot;</span></span><br></pre></td></tr></table></figure>

<p>协议可以像其他类型一样使用（这句话有点绕）。例如，创建一个由实现了同一个协议的不同类型的对象组成的集合。不过当你处理一个类型是协议的值时，协议中没有定义的属性和方法是不能访问的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> protocolValue: <span class="type">ExampleProtocol</span> <span class="operator">=</span> a</span><br><span class="line"><span class="built_in">print</span>(protocolValue.simpleDescription)</span><br><span class="line"><span class="comment">// print(protocolValue.anotherProperty)  // Uncomment to see the error</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：用协议作为变量的类型，把一个实现了该协议的类或者结构体的实例对象传递给它时，相当于做了一个降级，所有自定义属性和方法都不能访问。</p>
</blockquote>
<p>虽然 protocolValue 在运行时的类似是 SimpleClass，但是编译器将以 ExampleProtocol 对待它。这意味着你在 SimpleClass 中定义的自定义属性和方法都不能访问。</p>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>6.<a href="https://github.com/zfanli/notes/blob/master/swift/6.SyntaxBasics(Enumerations&Structures).md">Swift Syntax Basics (枚举类型和结构体)</a></p>
<p>8.<a href="https://github.com/zfanli/notes/blob/master/swift/8.SyntaxBasics(ErrorHandling).md">Swift Syntax Basics (错误处理)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>8.Swift Syntax Basics (错误处理)</title>
    <url>/post/notes/swift/8-SyntaxBasics-ErrorHandling/</url>
    <content><![CDATA[<p>仔细一看，Swift 的错误处理比较 Java 系来看更加细致。在 do-cathc 块中必须要用 <code>try</code> 关键字指定哪一个函数调用会抛错误。其他也并无两样。</p>
<p>对于 Error 类型对象的定义，只要实现了 <code>Error</code> 协议就行。其他随意。</p>
<p>不同之处在于 <code>try?</code> 语法，快速处理一个不用关注错误的场景，这种情况一般只需要知道是否有错误，有就作为 <code>nil</code> 处理，错误类型本身不需要关注。</p>
<p>另外还有一个 <code>defer</code> 语法可以在代码执行结束即将返回的时候做一些特殊的操作，比如初始化或者清洁操作。看上去挺像 Java 系的 finial 块，但是作用不限于 try-catch 的结束，而是整个函数的结束。</p>
<span id="more"></span>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>一个错误对象可以是实现（Adopt） <code>Error</code> 协议的任何类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PrinterError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> outOfPaper</span><br><span class="line">    <span class="keyword">case</span> noToner</span><br><span class="line">    <span class="keyword">case</span> onFire</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 <code>throw</code> 抛出一个错误，用 <code>throws</code> 标记一个函数可能抛出错误。如果你在函数中抛出错误，函数会立刻返回，调用者要进行错误处理。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span>(<span class="params">job</span>: <span class="type">Int</span>, <span class="params">toPrinter</span> <span class="params">printerName</span>: <span class="type">String</span>)</span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> printerName <span class="operator">==</span> <span class="string">&quot;Never Has Toner&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">PrinterError</span>.noToner</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Job sent&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误处理有几种方式。其中之一是使用 do-catch。在可能抛错误的操作前标记 <code>try</code> 关键字。在 catch 中错误会被自动命名为 <code>error</code>，你也可以给其定义一个别的名称。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> printerResponse <span class="operator">=</span> <span class="keyword">try</span> send(job: <span class="number">1040</span>, toPrinter: <span class="string">&quot;Bi Sheng&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(printerResponse)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用多个 catch 处理不同的错误。在 case 后面接匹配模式，写法与 switch 的 case 匹配相同。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> printerResponse <span class="operator">=</span> <span class="keyword">try</span> send(job: <span class="number">1440</span>, toPrinter: <span class="string">&quot;Gutenberg&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(printerResponse)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">PrinterError</span>.onFire &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I&#x27;ll just put this over here, with the rest of the fire.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> printerError <span class="keyword">as</span> <span class="type">PrinterError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Printer error: <span class="subst">\(printerError)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式是使用 <code>try?</code> 将表达式结果标记为可选。如果函数抛出错误，错误会被抛弃，表达式的结果会是 <code>nil</code>。相反会返回函数执行的结果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> printerSuccess <span class="operator">=</span> <span class="keyword">try?</span> send(job: <span class="number">1884</span>, toPrinter: <span class="string">&quot;Mergenthaler&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> printerFailure <span class="operator">=</span> <span class="keyword">try?</span> send(job: <span class="number">1885</span>, toPrinter: <span class="string">&quot;Never Has Toner&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用 <code>defer</code> 让一块代码在函数的其他代码执行完毕后、函数返回前执行。并且无论函数是否抛出错误，代码都会执行。你可以使用 <code>defer</code> 做一些设置或者清洁工作，虽然他们可能需要执行不同次数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fridgeIsOpen <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> fridgeContent <span class="operator">=</span> [<span class="string">&quot;milk&quot;</span>, <span class="string">&quot;eggs&quot;</span>, <span class="string">&quot;leftovers&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fridgeContains</span>(<span class="keyword">_</span> <span class="params">food</span>: <span class="type">String</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    fridgeIsOpen <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        fridgeIsOpen <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> fridgeContent.contains(food)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">fridgeContains(<span class="string">&quot;banana&quot;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">print</span>(fridgeIsOpen)</span><br><span class="line"><span class="comment">// prints false</span></span><br></pre></td></tr></table></figure>

<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>7.<a href="https://github.com/zfanli/notes/blob/master/swift/7.SyntaxBasics(Protocols&Extensions).md">Swift Syntax Basics (枚举类型和结构体)</a></p>
<p>9.<a href="https://github.com/zfanli/notes/blob/master/swift/9.SyntaxBasics(Generics).md">Swift Syntax Basics (泛型)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>9.Swift Syntax Basics (范型)</title>
    <url>/post/notes/swift/9-SyntaxBasics-Generics/</url>
    <content><![CDATA[<p>泛型也是一个灵活而实用的机制（虽然 Java 系的泛型用的也不是很多）。教程用了很少的篇幅讲泛型，到这里我们也只能获得泛型大概的印象。其实和 Java 中的没两样。</p>
<p>另一个特色就是 <code>where</code> 关键字，这个和 SQL 的 where 很类似，可以给表达式或者方法加一层过滤器，对表达式来说只有满足 <code>where</code> 条件的才进行操作，对函数来说不满足 <code>where</code> 条件的参数会在编译时报错提示。</p>
<p>这是官方入门教程的最后一个篇章。到此我们对 Swift 的语法已经从头到尾进行了一次预览了。</p>
<span id="more"></span>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>定义泛型函数或者类型，在尖括号中写入泛型的名字。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeArray</span>&lt;<span class="type">Item</span>&gt;(<span class="params">repeating</span> <span class="params">item</span>: <span class="type">Item</span>, <span class="params">numberOfTimes</span>: <span class="type">Int</span>)</span> -&gt; [<span class="type">Item</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="operator">=</span> [<span class="type">Item</span>]()</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>numberOfTimes &#123;</span><br><span class="line">         result.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">makeArray(repeating: <span class="string">&quot;knock&quot;</span>, numberOfTimes: <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [&quot;knock&quot;, &quot;knock&quot;, &quot;knock&quot;, &quot;knock&quot;]</span></span><br></pre></td></tr></table></figure>

<p>你可以把函数和方法变成泛型格式，同样的类、枚举类型、结构体也可以。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reimplement the Swift standard library&#x27;s optional type</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OptionalValue</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> none</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">some</span>(<span class="type">Wrapped</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> possibleInteger: <span class="type">OptionalValue</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> .none</span><br><span class="line">possibleInteger <span class="operator">=</span> .some(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>使用 <code>where</code> 关键字，放在函数体前（大括号前面），来指定一系列的要求。比如要求实现一个协议、要求两个类型相同，或者要求类必须继承某一个父类。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyCommonElements</span>&lt;<span class="type">T</span>: <span class="type">Sequence</span>, <span class="type">U</span>: <span class="type">Sequence</span>&gt;(<span class="keyword">_</span> <span class="params">lhs</span>: <span class="type">T</span>, <span class="keyword">_</span> <span class="params">rhs</span>: <span class="type">U</span>)</span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">where</span> <span class="type">T</span>.<span class="type">Element</span>: <span class="type">Equatable</span>, <span class="type">T</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">U</span>.<span class="type">Element</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> lhsItem <span class="keyword">in</span> lhs &#123;</span><br><span class="line">        <span class="keyword">for</span> rhsItem <span class="keyword">in</span> rhs &#123;</span><br><span class="line">            <span class="keyword">if</span> lhsItem <span class="operator">==</span> rhsItem &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">anyCommonElements([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p><code>&lt;T: Equatable&gt;</code> 等同于 <code>&lt;T&gt; ... where T: Equatable</code>。</p>
<blockquote>
<p>R：这里的 <code>where</code> 相当于一个严格的类型检查，只有满足条件的参数调用该函数是合法的，否则编译时会报错提示。<code>where</code> 在其他写法中可以起到过滤的作用。</p>
</blockquote>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>8.<a href="https://github.com/zfanli/notes/blob/master/swift/8.SyntaxBasics(ErrorHandling).md">Swift Syntax Basics (错误处理)</a></p>
<p>10.<a href="https://github.com/zfanli/notes/blob/master/swift/10.SyntaxSupplements.md">Swift Syntax Supplements</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>[DICTATION] Why it&#39;s so hard to be happy?</title>
    <url>/post/notes/just%20notes/-Dictation-Why-it-s-so-hard-to-be-happy/</url>
    <content><![CDATA[<blockquote>
<p>💡 英语听读练习<a href="https://www.youtube.com/watch?v=rQoS_S9K464">《为何幸福如此困难？ - by Better Ideas》</a>。</p>
</blockquote>
<p>A long time ago, humanity rose to become the dominant species on planet earth, and we were able to do this because of one specific trait. It certainly wasn’t our physical prowess, pretty much any animal the same size as us would absolutely destroy us in a one-on-one physical altercation. And it wasn’t even our ability to use tools because that’s not unique to humans.</p>
<p>人类在很久以前就成为了地球上的支配者物种，让我们可以做到这一点的是我们身上的一个特质。显然这个特质并非是我们的身体力量，实际上与我们体型差不多的动物在和我们一对一的肢体交锋中都能决定性的毁灭我们。这个特质也不会是使用工具等能力，因为会使用工具不仅仅是人类。</p>
<blockquote>
<p>📒 <strong>prowess</strong>: someone’s prowess is their great skill at doing something; bravely in battle. 杰出的技能；英勇，勇敢。</p>
</blockquote>
<span id="more"></span>

<p>We were able to rise the power because of a specific development in the cerebral cortex. That of abstract thought, the ability to conceptualize, predict and plan for the future. Unlike any other animal, human beings weren’t just concerned with what they were going to eat today, but also what they were going to eat tomorrow, and weeks from now and years from now.</p>
<p>我们能够成为主导物种是因为大脑皮层的一种特殊发展让我们拥有了抽象的能力，这个能力让我们能概念化、预测和计划未来。不像其他动物，人类不仅关心他们今天要吃什么，也会关心明天吃什么，几周后吃什么，几年后吃什么。</p>
<blockquote>
<p>📒 <strong>cerebral cortex</strong>: 大脑皮层（解剖）。</p>
</blockquote>
<p>It was this instinct of future preservation that allowed us to ration our food, start to predict changes in seasons. We became the only animal in the history that was able to consciously forego present pleasure, in order to pave the way for a better future.</p>
<p>就是这种为未来而储备的本能让我们可以定量配给食物，开始预测季节的变化。我们成为了历史上唯一可以持续放弃眼前的享乐，而为更好的未来铺路的动物。</p>
<blockquote>
<p>📒 <strong>instinct</strong>:</p>
<ul>
<li>is the natural tendency that a person or animal has to behave or react in a particular way. 本能。</li>
<li>If you have an instinct for something, you are naturally good at it or able to do it. 天分。</li>
</ul>
<p>📒 <strong>ration</strong>:</p>
<ul>
<li>when something is rationed by a person or government, you are only allowed to have a limited of it, usually because there is not enough of it. 定量配给。</li>
</ul>
<p>📒 <strong>forego</strong>: 放弃（正式）。<strong>pave</strong>: 铺砌，创造条件。</p>
</blockquote>
<p>And while this trait was perhaps the single greatest survival mechanism we ever developed. I’d also argue it’s the very reason why it’s so difficult to be happy. Because the world is modernized, technology advanced so much faster than we did as humans. We live in this super advanced world, yet we’re still packing around primal hardware, it’s in our very natural to be constantly fantasizing about an ideal future. We’ll work jobs that we don’t like, grind away today, so that will eventually achieve prosperity tomorrow. Maybe if you’re a student, you’re grinding through school today, so you can eventually get the degree, get a well-paying job, maybe find the love of your life.</p>
<p>不过就如这个特质也许是我们人类发展出来的一个最伟大的生存机制，我还是主张它是我们难以获得幸福的最重要的原因。因为如今世界是现代化的，科技发展速度远超我们人类进化的速度。我们生活在这个极为先进的世界，但是我们的硬件设施却还是非常原始，持续幻想一个理想的未来几乎是我们的本能。我们会做自己不喜欢的工作，熬过今天，最终成就繁荣的明天。或许如果你是个学生，你今天在学校努力了一整天，这让你最后能拿到学位，找到一个高薪的工作，也可能找到你生命的另一半。</p>
<blockquote>
<p>📒 <strong>grind</strong>: if you refer to routine tasks or activities as the grind, you mean they are boring and take up a lot of time and effort. 消磨。grind away: 努力工作、学习 or 熬？</p>
<p>📒 <strong>prosperity</strong>: is a condition in which a person or community is doing well financially. 繁荣。</p>
</blockquote>
<p>Human beings are really good at postulating what might be in the future, and using the present to prepare for that moment. And I’m not saying that’s a bad thing, it’s an extremely useful thing, it’s a very motivating thing, we need to have some sort of goal and direction in our life otherwise we’re completely goalless and directionless.</p>
<p>人类非常擅长设想未来会出现什么，然后用当下来做准备。我没有说这有什么不好，这是非常好的，也是非常激励的，在人生中我们需要一些目标和方向，否则我们就是完全的无头苍蝇。</p>
<blockquote>
<p>📒 <strong>postulate</strong>:</p>
<ul>
<li>if you postulate something, you suggest it as the basis for a theory, argument, or calculation, or assume that it is the basis. 假定。</li>
</ul>
</blockquote>
<p>I mean, sometimes it’s kind of weird being human because not only do we exist in the present moment and have to do our day to day things, or duties and responsibilities, but we also psychologically exist at the exact same time in this abstract future, in this abstract potential, that we ourselves generated. And a lot of the time it’s this abstraction that motivates us to get through our present, especially if our present is something that we don’t generally like to interacting with.</p>
<p>我是说有时人类是奇怪的，因为我们不止活在当下，去做着我们每天必须做的事，或者义务和责任，在心理上我们还活在我们自己想象出来的抽象的未来、抽象的潜力中。并且大部分时间中，这个抽象本身激励着我们走过我们的当下，尤其是当我们的当下并非我们想要的时候。</p>
<blockquote>
<p>📒 <strong>psychologically</strong>: in a way that relates to the human mind and feelings. 心理上，心理学地。</p>
</blockquote>
<p>But the problem we run into, is the fact that there is another sensation that is universal to human beings, world wide. And that is the fact that we only experienced life in the present moment. We prepare for a future that we will actually never get to experience. And if we place too many cards in the future basket at the dramatic expense of the present moment, then our entire lives can end up looking like a squirrel, obsessively hoarding acorns in preparation for a winter that never comes. Which seems in a way, like we’re constantly postponing our own happiness, and that can be extremely exhausting. Especially if you’ve been doing that for years, and years and perhaps even decades. It’s almost like every single person who has ever lived and who will ever live if left uncheck will hamster wheel themselves right into their graves.</p>
<p>但我们遇到的问题是在全世界范围内的人类中，存在另一种普遍感觉的事实。这就是我们只在当下的时间中经历生活的事实。我们为了一个实际上绝对不会经历的未来而做准备。如果我们以牺牲当下为代价而放了太多砝码在未来上，我们的整个人生就会变得像一只痴迷于囤积橡子的松鼠一样，为了一个永远不会到来的冬天而做准备。这在某种意义上就像我们持续的推迟属于我们自己的幸福到来，这会让人极其疲惫。尤其是当你这样持续了几年甚至几十年。几乎每个人都经历过或将要经历这样的人生，如果不加以控制，他们就会像仓鼠的转轮一样，在永无止境的推迟中抵达人生的终点。</p>
<blockquote>
<p>📒 <strong>obsessively</strong>: if someone’s behavior is obsessive, they cannot stop doing a particular thing or behaving in a particular way. 痴迷的。</p>
<p>📒 <strong>hoard</strong>: if you hoard thins such as food or money, you save or store them, often in secret, because they are valuable or important to you. 贮存。</p>
<p>📒 <strong>postpone</strong>: if you postpone an event, you delay it or arrange for it to take place at a later time than was original planned. 推迟。</p>
</blockquote>
<p>So what’s the solution to this problem？ I’d be really demoralizing me coming here and saying, you will never achieve your dreams, your dreams are just an abstraction, you will never get what you want. But that’s not true, there is a way to be optimistic about the future, and still have ambition, yet still be able to take some of that future happiness into the present moment. And I propose that the way that’s possible is through gratefulness. Now, maybe you’ve heard this 1000 times, maybe you’ve heard that gratefulness is a really good idea and I should just be grateful for what I have. But how can I do that if my surroundings are honestly kind of shitty. And I understand this feeling completely, it’s not easy to be grateful at all. Especially if you’re an ambitious person, in fact I would say the more ambitious you are, the harder it is to be grateful. Because being grateful is actually risky. You risk neutering yourself of the drive to push forward, to trend your life in an upward direction.</p>
<p>所以如何解决这个问题？如果有人对我说，你的梦想永远不会实现的，你的梦想只是抽象的想法， 你永远得不到你想要的，我很非常的沮丧。但这不是真的，有一种方式可以对未来抱有乐观的同时保持野心，还能把未来的一些幸福拿到当下。而我的建议是，通过感恩可以实现这一点。也许这个观点你已经听过 1000 次了，也许你听过有人说感恩是个好主意，我需要对我有的东西感恩。不过如果我身边的情况确实是一团乱麻，我要怎么感恩？我完全理解这种心情，感恩根本就不是一件容易的事。尤其当如果你是一个野心家时，实际上我会说你越有野心就越难感恩。因为感恩是有风险的。你冒着失去前进动力的风险，让你的生活朝上发展。</p>
<blockquote>
<p>📒 <strong>demoralize</strong>: if something demoralizes someone, it makes them lose so much confidence in what they are doing that they want to give up. 使人丧气。</p>
<p>📒 <strong>ambition</strong>: if you have an ambition to do or achieve something, you want very much to do it or achieve it. 野心。</p>
<p>📒 <strong>neuter</strong>: verb. to neuter an organization, group, or person means to make them powerless and ineffective. 瓦解。</p>
</blockquote>
<p>If you spend your life dreaming of cookies, then gratefulness can often feel like you’re forcing yourself to no longer want the cookie, but you want to want the cookie because that increases your changes of getting the cookie. But I think that’s the wrong way to look at gratefulness. Gratefulness doesn’t stop you from getting cookies, it just help you to realize that the cookies aren’t all in front of you, they’re kind of all around you, and you’re more than welcome to take one out and eat one.</p>
<p>如果你一辈子都想要饼干，那么感恩经常让你感觉在强迫自己不要去想要饼干，但是你希望自己想要饼干，这会增加你得到饼干的机会。但我认为这这样看待感恩是不对的。感恩不会阻止你得到饼干，感恩只会让你意识到饼干不是在你的眼前，它们全都在你的四周，你完全可以选一个然后吃掉。</p>
<p>So about a year and a half ago, my mom started to develop a pretty severe case of insomnia, she’s always been a very naturally anxious person that kind runs in the family, but we started to go through some hard times the family, and this anxiety really turned into a really really bad case of insomnia. It wasn’t just going on for days, but it was weeks and weeks and weeks of just barely any sleep at all. Anyone who’s had a severe case of insomnia will know, that you start to become terrified of the nighttime, because you know that you’ll just be sitting there with your own terrifying thoughts, not being able to go to sleep.</p>
<p>大约一年半前，我的母亲开始有比较严重的失眠，她一直是家里那个天生焦虑的人，但我们的家庭开始经历一些艰难的时刻，这种焦虑就变成了非常严重的失眠。这不是几天的事情，无法入睡的情况是一周一周持续的。任何患有严重失眠症的人都知道，你会开始恐惧夜晚时间，因为你知道你会就坐在那脑子开始闪过可怕的思绪，就是无法入睡。</p>
<blockquote>
<p>📒 <strong>severe</strong>: you use severe to indicate that something bad or undesirable is great or intense. 严峻的。</p>
<p>📒 <strong>insomnia</strong>: someone who suffers from insomnia finds it difficult to sleep. 失眠。</p>
</blockquote>
<p>So this is going on for weeks, and I was starting to become extremely concerned for her mental health. One day she messaged me and said, “I finally been able to get some good night’s rest.” And I was so relieved.</p>
<p>当这持续了几个星期，我开始非常担心她的精神健康。有一天她发消息给我说，“我终于晚上可以好好的休息了。” 听到这我松了口气。</p>
<p>And it turns out she didn’t use any heavy pharmaceuticals, or there were no magic pills involved, all she did was every single night before she put her head on the pillow, she listed three things. One, something that made her smile that day. Two, something that she’s grateful for. And three, something that she did well. She started to doing this every single night, and it’s crazy to think, that just simply reflecting on the good things in her life, that her frantically busy and noisy brain, was able to calm down, and she was finally able to get the rest that she so desperately needed. And she didn’t just start doing this randomly, this is all based on a study that she read, I’ll put the link in the description, you guys can check it out.</p>
<p>她没使用很重的药物，有没有魔法药丸帮忙，她做的仅仅是在每个晚上睡前列出 3 件事。其一，这天让她开心的一件事；其二，让她感恩的一件事；其三，她做的好的一件事。她开始每天晚上都这样做，不敢想象的是就是如此简单的反思她生活中美好的事情，让她狂躁的大脑能够冷静下来，最终让她得到她迫切需要的休息。她也并非无缘无故开始做这件事情的，这个方法是基于她阅读的一篇研究，我会把连接放在下面，你们可以去看看。</p>
<blockquote>
<p><a href="https://bmjopen.bmj.com/content/7/5/e015826">https://bmjopen.bmj.com/content/7/5/e015826</a></p>
</blockquote>
<blockquote>
<p>📒 <strong>pharmaceutical</strong>: someone who suffers from insomnia finds it difficult to sleep. 失眠。</p>
<p>📒 <strong>frantically</strong>: if you are frantic, you are behaving in a wild and uncontrolled way because you are frightened or worried. 发狂。</p>
<p>📒 <strong>desperately</strong>: 拼命的。迫切的。</p>
</blockquote>
<p>I guess what I’m trying to say, is that gratitude. It gets you out of your head. You stop existing in the what ifs, and if this happens then that, or maybe this bad thing happened in the past, and maybe I can get this done in the future, you start to really look to the present. And the good things that are already in here. And I’d argue that by practicing habitual gratefulness. It doesn’t stop you from getting the things that you want, you still want the things that you want, that primal instinct is not going away, but what it does do is it gives you permission, to pull some of that future happiness into the present moment, because if you’re never happy with what you have, you will never be happy with what you get. Every single night before you put your head on your pillow, write three good things: something that made you smile, something that you’re grateful for, and something that you did well. This might be difficult to see at first, and the harder it is to see at first, the worst you are at it, but I promise you, you’ll get better. And as you get better and better, at identify the good things in your life, you’ll come to realize just how many of them there are.</p>
<p>我想说的是感激，能让你从混乱的想法中解脱出来。你不再存在于“如果”中，什么如果这个如果那个，或这件坏事在过去已经发生过了，或者我未来可以把这个做掉。你开始关注当下。发现美好的东西已经在这里了。我认为通过习惯性的感恩可以证明这点。感恩不会阻止你获得你想要的东西，它就像给了你许可，让你可以从未来中拿来一些幸福到当下，因为如果你从不对你拥有的而感激，你就无法从获得中得到幸福感。每天晚上在睡前写出这三件事：让你开心的事；让你感激的事；以及你做的好的事。一开始或许你很难马上想到，而且你越是一开始很难想到这些事，说明你的情况越是糟糕，但我保证你会变得更好。而当你变得越来越擅长在你的人生中找到美好事物时，你就会意识到原来这些事情有这么多。</p>
<blockquote>
<p>📒 <strong>habitual</strong>: A habitual action, state, or way of behaving is one that someone usually does or has, especially one that is considered to be typical or characteristics of them. 习惯性的。</p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>just notes</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>从需求来看 MongoDB 的最简单用法</title>
    <url>/post/notes/just%20notes/Simple-Usage-of-MongoDB/</url>
    <content><![CDATA[<p>从需求来看 MongoDB，了解能满足我们需求的最简用法。</p>
<p>这篇文章介绍如何在 Python 中操作 MongoDB，面向初学者。我们使用 MongoDB 来储存一个网站的数据，去满足搭建一个博客网站可能会遇到的需求，以此为例来熟悉和了解 MongoDB。</p>
<p>以下是这篇文章讨论的内容：</p>
<ul>
<li>设计符合需求的数据结构</li>
<li>document 的增删改查</li>
</ul>
<span id="more"></span>

<p>这些内容是基础知识。</p>
<h2 id="设计符合需求的数据结构"><a href="#设计符合需求的数据结构" class="headerlink" title="设计符合需求的数据结构"></a>设计符合需求的数据结构</h2><p>// TODO or delete</p>
<p>// Or maybe extract this part as a single post.</p>
<h2 id="document-的增删改查"><a href="#document-的增删改查" class="headerlink" title="document 的增删改查"></a>document 的增删改查</h2><h3 id="连接-MongoDB"><a href="#连接-MongoDB" class="headerlink" title="连接 MongoDB"></a>连接 MongoDB</h3><p>这是一个连接 MongoDB 的示例代码，主要用来定义几个变量方便后面使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"><span class="keyword">from</span> bson <span class="keyword">import</span> ObjectId</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mc = MongoClient() <span class="comment"># connect to default client</span></span><br><span class="line">db = mc[<span class="string">&#x27;test&#x27;</span>] <span class="comment"># use &#x27;test&#x27; database</span></span><br><span class="line">col = db[<span class="string">&#x27;test-collection&#x27;</span>] <span class="comment"># use &#x27;test-collection&#x27; collection</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="find-查询"><a href="#find-查询" class="headerlink" title="find 查询"></a>find 查询</h3><p>查询是使用数据库的基础需求。在 MongoDB 中查询分为两种，查询单个值的 <code>find_one</code> 和查询多个值的 <code>find</code>。使用方法示例如下。</p>
<h4 id="find-one-amp-find"><a href="#find-one-amp-find" class="headerlink" title="find_one &amp; find"></a>find_one &amp; find</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Query for only one document</span></span><br><span class="line">col.find_one(&#123;</span><br><span class="line">    <span class="string">&#x27;some_fields&#x27;</span>: <span class="string">&#x27;values&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;array_fields&#x27;</span>: [<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;object_fields&#x27;</span>: &#123;<span class="string">&#x27;keys&#x27;</span>: <span class="string">&#x27;values&#x27;</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment"># Query for one or more than one documents</span></span><br><span class="line">col.find(&#123;</span><br><span class="line">    <span class="string">&#x27;some_fields&#x27;</span>: <span class="string">&#x27;values&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;array_fields&#x27;</span>: [<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;object_fields&#x27;</span>: &#123;<span class="string">&#x27;keys&#x27;</span>: <span class="string">&#x27;values&#x27;</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以知道，查询方法接收一个参数作为查询条件，且这个参数需要是 <code>dict</code> 对象类型。这个例子如果放在 SQL 语句中对应 <code>select * from ... where ...</code> 句式。</p>
<p>上面的例子查询条件是几个精确值，很多时候我们的查询条件无法准确到一个具体的值，需要限定一个范围查询。MongoDB 使用比较操作符来圈定范围，来看下面这个例子 🌰。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.find(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;views&#x27;</span>: &#123;<span class="string">&#x27;$gte&#x27;</span>: <span class="number">1000</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这个例子中，我们可以拿到所有 <code>views</code> 值大于等于 1000 的文章。比较操作符 <code>$gte</code> 表达大于等于的关系，这是 <code>greater than or equal to</code> 的缩写，含义等同于 <code>&gt;=</code>。</p>
<p>常用的比较操作符有下面这些：</p>
<ul>
<li><code>$eq</code> equal to</li>
<li><code>$gt</code> greater than</li>
<li><code>$gte</code> greater than or equal to</li>
<li><code>$lt</code> less than</li>
<li><code>$lte</code> less than or equal to</li>
<li><code>$ne</code> not equal to</li>
<li><code>$in</code> match in an array</li>
<li><code>$nin</code> not match in an array</li>
</ul>
<p>这些操作符中，<code>$in</code> 和 <code>$nin</code> 需要匹配数组，例如 <code>$in</code> 的表达方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;field_name&#x27;</span>: &#123;<span class="string">&#x27;$in&#x27;</span>: [<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>...<span class="string">&#x27;values&#x27;</span>]&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>而其他的比较操作符需要匹配单个值，例如 <code>$eq</code> 的表达方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;field_name&#x27;</span>: &#123;<span class="string">&#x27;$eq&#x27;</span>: <span class="string">&#x27;value&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这些操作符可用于所有比较关系，不仅限于 <code>find</code> 查询，还包括更新、删除和 <code>aggregate</code> 聚合等场合。</p>
<h4 id="project-计划字段"><a href="#project-计划字段" class="headerlink" title="project 计划字段"></a>project 计划字段</h4><p><code>find</code> 默认拉取整个 document 作为输出，类似 SQL 的 <code>select * from table</code>，这意味着即使你只想要这个文档中的一个字段，你也将先得到整个文档，然后从中取得你想要的字段。通常出于带宽的限制以及性能的考虑，这都不是一个好主意，好在有办法只取某几个字段，在 MongoDB 中这个概念被称作 <code>project</code>。</p>
<p><code>find</code> 方法的第二个参数将被视为 <code>projection</code>，同样也需要是 <code>dict</code> 对象类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.find(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;author&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;content&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这个例子中，我们在第二个参数中列出需要的字段名，并将其值设为 <code>1</code>， 我们就完成了对需要字段的声明。<code>projection</code> 中字段对应的值是一个 flag，当其为 <code>1</code> 的时候，代表<strong>包含关系</strong>，让 MongoDB 可以理解我们的需求，仅取出需要的字段。</p>
<p>或者，我们也可以声明不要获取哪些字段。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.find(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;comments&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;reviews&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面说到 <code>projection</code> 中字段对应的值是 flag，那么 <code>0</code> 就表示<strong>不包含关系</strong>。MongoDB 会知道我们的意思，并且把我们声明不需要的字段以外的数据都取出来，这在一些场景下很有用。</p>
<p>在使用 <code>projection</code> 时需要注意，<code>_id</code> 字段在 MongoDB 中有特殊的地位，即使没有被声明为需要获取的字段，其依然会被默认抽取出来。但如果你确实不需要它，可以在 <code>projection</code> 中手动设置为 <code>0</code>，它就不会出现了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.find(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;_id&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;author&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;content&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>但是注意，除了 <code>_id</code> 以外，包含关系（<code>1</code>）和不包含关系（<code>0</code>）是不能共存的，否则你会得到下面这个错误。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pymongo.errors.OperationFailure: Projection cannot have a mix of inclusion and exclusion.</span><br></pre></td></tr></table></figure>

<p>所以需要记住，对于 <code>_id</code> 来说，想要不显示它需要手动设置为 <code>0</code>。但对其他字段来说，只能有两个选择，声明所有需要获取的字段，或者声明所有不需要获取的字段。如果你尝试同时要求 MongoDB 理解你需要哪些字段和不需要哪些字段，那么只能得到无情的报错。</p>
<h4 id="project-进阶"><a href="#project-进阶" class="headerlink" title="project 进阶"></a>project 进阶</h4><p>声明获取和不获取的字段只是 <code>project</code> 的一个功能，除此之外它还有很多很实用的能力。例如当需要查询一个数组对象时，有时我们需要更高精度的操作，比如做评论的分页时，通常一次性取出所有评论是没有必要的，有时甚至是昂贵的，这时我们可以使用 <code>project</code> 来帮我们做一些更进一步的操作。来看看这个例子 🌰。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.find(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"># Fetch the 0-3 of comments</span></span><br><span class="line">        <span class="string">&#x27;comments&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;$slice&#x27;</span>: <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># Fetch the 2-6 of comments</span></span><br><span class="line">        <span class="string">&#x27;comments&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;$slice&#x27;</span>: [<span class="number">2</span>, <span class="number">6</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># Fetch the last comment</span></span><br><span class="line">        <span class="string">&#x27;comments&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;$slice&#x27;</span>: -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的例子中展示了数组切片操作符的用法，其效果等同于 Python 中数组的切片操作。第一个 comments 取了数组的前 3 条数据，第二个 comments 取得了第 2 条到第 6 条的数据，最后一个 comments 取得了倒数第 1 条数据。</p>
<p>或者，有时我们仅需要取出符合要求的第一个评论，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.find(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"># Fetch the first deleted comment</span></span><br><span class="line">        <span class="string">&#x27;comments&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;$elemMatch&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;deleted&#x27;</span>: <span class="literal">True</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">col.find(</span><br><span class="line">    <span class="comment"># Fetch the first element matched the condition</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;comments&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;deleted&#x27;</span>: <span class="literal">True</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;comments.$&#x27;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的两个查询的效果一样，都是获取评论数组中满足删除 Flag 为 <code>true</code> 这个条件的第一条评论。不过这个例子的匹配世界上用处有限，因为通常我们需要取出的是满足条件的多条评论，而非最初的某一条。但是 <code>project</code> 虽然有办法实现，却不是在 <code>find</code> 方法中实现，在之后的关于 <code>aggregate</code> 的文章中我们再继续讨论如何满足这个需求吧。</p>
<p>目前为止涉及的文档：</p>
<ul>
<li><a href="https://docs.mongodb.com/manual/tutorial/query-documents/">Query Documents</a></li>
<li><a href="https://docs.mongodb.com/manual/reference/operator/query-comparison/">Comparison Query Operators</a></li>
<li><a href="https://docs.mongodb.com/manual/tutorial/project-fields-from-query-results/">Project Fields to Return from Query</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.find">collection – Collection level operations - find()</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.find_one">collection – Collection level operations - find_one()</a></li>
</ul>
<h3 id="update-更新"><a href="#update-更新" class="headerlink" title="update 更新"></a>update 更新</h3><p>修改已有的数据是普遍的需求。在我们要设计的博客系统中，用户主动以及被动的操作都会触发数据的变更，比如当用户打开一篇文章时，这篇文章的浏览数会得到更新；当用户赞了这篇文章时，这篇文章的点赞数也会得到更新；或者当用户在线修改了一篇文章的内容，这次修改也需要正确地更新到数据源上。</p>
<h4 id="update-one"><a href="#update-one" class="headerlink" title="update_one"></a>update_one</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Get user inputted content</span></span><br><span class="line">new_content = get_user_input()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Update specified article</span></span><br><span class="line">col.update_one(</span><br><span class="line">    <span class="comment"># Match article by id</span></span><br><span class="line">    &#123;<span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>)&#125;,</span><br><span class="line">    <span class="comment"># Update content</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;content&#x27;</span>: new_content&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面这个简单的例子中，我们假设通过 <code>get_user_input()</code> 函数拿到了用户的输入数据。接下来我们对指定的文章做了一次更新。</p>
<p>在例子中我们给 <code>update_one</code> 方法传递了两个参数，第一个是查询参数，对应 SQL 中的 <code>where</code> 小句。第二个参数是更新参数，<code>$set</code> 是更新操作的操作符，它的值也是一个 <code>dict</code> 对象，描述将什么字段更新成什么值，对应 SQL 中的 <code>update table set ...</code> 句式。</p>
<p>这是一个简单的更新操作，我们实际上做的是：</p>
<p>更新 <code>_id</code> 为给定值的文章，更新的字段是 <code>content（内容）</code>，更新的内容是我们之前拿到的用户输入值 <code>new_content</code>。</p>
<blockquote>
<p><code>_id</code> 是 MongoDB 中自动生成的一个字段，作为主键来标识数据的唯一性，它是一个对象而非字符串，在 Python 中指定的时候需要用 <code>ObjectId(）</code> 方法来生成一个 ID 对象。</p>
</blockquote>
<h4 id="inc-数值增量"><a href="#inc-数值增量" class="headerlink" title="$inc 数值增量"></a>$inc 数值增量</h4><p>回到更新文字阅读数和点赞数的例子 🌰，在这个场景中，我们希望阅读数和点赞数字段更新的结果是在原有的基础上增加 1，而不是设置一个具体的值给他。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.update_one(</span><br><span class="line">    <span class="comment"># Match article by id</span></span><br><span class="line">    &#123;<span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>)&#125;,</span><br><span class="line">    <span class="comment"># Update views</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;$inc&#x27;</span>: &#123;<span class="string">&#x27;views&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>MongoDB 提供了一个 <code>$inc</code> 操作符来实现给指定的字段做增量操作。所有我们实际的操作是：更新 <code>_id</code> 为给定值的文章，更新的字段是 <code>views（点击量）</code>，更新的内容是在原有的基础上加 1。当然增量的值是根据需要设定的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.update_one(</span><br><span class="line">    <span class="comment"># Match user by username</span></span><br><span class="line">    &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">    <span class="comment"># Update points</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;$inc&#x27;</span>: &#123;<span class="string">&#x27;points&#x27;</span>: <span class="number">100</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们给名为 Richard 的用户增加了 100 积分来激励他继续使用我们的网站。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.update_one(</span><br><span class="line">    <span class="comment"># Match user by username</span></span><br><span class="line">    &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">    <span class="comment"># Update points</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;$inc&#x27;</span>: &#123;<span class="string">&#x27;points&#x27;</span>: -<span class="number">999</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>负值当然也是允许的，接着因为剧情需要我们发现了 Richard 的违规行为，谨慎考虑后我们决定扣除 999 积分以示惩戒。</p>
<p>这些操作都可以使用 <code>$inc</code> 完成。不过当然我们的博客也不需要积分系统。</p>
<p>上面的例子都使用了 <code>update_one</code> 方法，顾名思义其只对一个目标进行更新，当更新多个目标时我们用到另一个方法。</p>
<h4 id="update-many"><a href="#update-many" class="headerlink" title="update_many"></a>update_many</h4><p>我们对所有点击量超过 1000 的文章进行一次更新，将它们标注为热点文章。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.update_many(</span><br><span class="line">    &#123;<span class="string">&#x27;views&#x27;</span>: &#123;<span class="string">&#x27;$gte&#x27;</span>: <span class="number">1000</span>&#125;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;hot_topic&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>使用 <code>update_many</code> 进行批量更新操作时，同样的第一个参数将作为查询参数来负责筛选出我们需要的数据，第二个参数则将指定的字段更新为新的值。</p>
<p><code>update_many</code> 会返回一个 <code>UpdateResult</code> 对象，里面包含诸如匹配行数和修改行数等信息。</p>
<p>但是当我们在设计 RESTful API 的时候，一个比较好的实践是，更新操作完成后将更新后的对象作为响应对象交付给客户端，这样可以减少请求数量，并且准确的保持服务端和客户端的数据一致性。</p>
<p>要满足这个需求，就目前所了解到的信息，我们可以先执行一次更新操作，然后在执行一次查询操作，将更新后的数据再次取出来。但这太繁琐了，没关系，有一个更好的办法可以使用。</p>
<h4 id="find-one-and-update"><a href="#find-one-and-update" class="headerlink" title="find_one_and_update"></a>find_one_and_update</h4><p>从名称上我们就可以轻松的理解这个方法的含义，就是查找一个对象并且更新它。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> ReturnDocument</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get user inputted content</span></span><br><span class="line">new_content = get_user_input()</span><br><span class="line"></span><br><span class="line">col.find_one_and_update(</span><br><span class="line">    <span class="comment"># Match article by id</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># Update content and timestamp</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;$set&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;content&#x27;</span>: new_content,</span><br><span class="line">            <span class="string">&#x27;updated_time&#x27;</span>: time()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># Project fields</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;content&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;reviews&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;comment&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;updated_time&#x27;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># Return modified document</span></span><br><span class="line">    return_document=ReturnDocument.AFTER</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>例子 🌰 稍微有点长，首先我们导入了两个工具。和之前一样，假设我们从 <code>get_user_input()</code> 方法拿到了用户的输入内容，这是我们将要更新的数据。接着使用 <code>find_one_and_update</code> 来更新数据。</p>
<p>第一个参数是作为查询参数，匹配一个唯一的 <code>_id</code>；第二个参数是更新内容，我们将 <code>content</code> 更新为新的用户输入，并且使用 <code>time()</code> 工具更新时间戳；注意，这里出现了<strong>第三个参数</strong>，由于要进行一次查找文档，我们可以利用 <code>project</code> 计划字段来指定需要的字段。关于更新和查找的参数就是这些。</p>
<p>第四个参数是一个选项，是可以省略的，但是要小心，默认情况下，<code>find_one_and_update</code> 方法就如其名，会先查找出文档，再进行更新操作，这样的话返回的就是<strong>更新前的文档</strong>。</p>
<p>显然，为了保持数据一致性我们需求的应该是更新后的文档，<code>return_document</code> 选项就是用来指定这个行为的。从 <code>pymongo</code> 包中导入的 <code>ReturnDocument</code> 工具可以提供几个选项，在这里我们将 <code>ReturnDocument.AFTER</code> 设置给 <code>return_document</code> 即可告诉 MongoDB 给我们更新后的文档。</p>
<p>关于更新，了解这些想必搭建一个 blog 网站是够用了。</p>
<p>这一部分涉及的文档：</p>
<ul>
<li><a href="https://docs.mongodb.com/manual/reference/operator/update-field/">Field Update Operators</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.update_one">collection – Collection level operations - update_one()</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.update_many">collection – Collection level operations - update_many()</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.find_one_and_update">collection – Collection level operations - find_one_and_update()</a></li>
</ul>
<h3 id="delete-删除"><a href="#delete-删除" class="headerlink" title="delete 删除"></a>delete 删除</h3><p>一般的删除操作我们仅在逻辑层面上对数据进行删除，具体的操作是设定一个删除 Flag，对需要删除的数据进行更新，将该 Flag 值更新为 <code>True</code>，这样只需要用到上述的更新方法就可以完成了。</p>
<p>逻辑删除的好处之一是在于留有一些余地，当某些数据被误删除时能够及时得到恢复，毕竟数据是最重要的，而储存空间是便宜的。</p>
<p>不过当某些数据被最终认定为无用数据时，就是时候进行物理删除了。</p>
<p><strong>删除操作非常简单，但同时需要非常慎重。</strong></p>
<h4 id="delete-one"><a href="#delete-one" class="headerlink" title="delete_one"></a>delete_one</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.delete_one(</span><br><span class="line">    <span class="comment"># Delete specified article</span></span><br><span class="line">    &#123;<span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>)&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的例子将删除 <code>_id</code> 匹配的文章。</p>
<h4 id="delete-many"><a href="#delete-many" class="headerlink" title="delete_many"></a>delete_many</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.delete_many(</span><br><span class="line">    <span class="comment"># Delete articles which deleted flag is True</span></span><br><span class="line">    &#123;<span class="string">&#x27;deleted&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的例子将删除所有被逻辑删除的文章。在这里逻辑删除 Flag 名称是 <code>deleted</code>。</p>
<p>可以看到，无论是删除一个目标还是删除多个目标，对于删除方法来说只需要一个匹配参数来识别数据。</p>
<h4 id="find-one-and-delete"><a href="#find-one-and-delete" class="headerlink" title="find_one_and_delete"></a>find_one_and_delete</h4><p>有时我们可能会需要将删除的文档放在 response 中返回给客户端，来看看例子 🌰。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.find_one_and_delete(</span><br><span class="line">    <span class="comment"># Match article by id</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># Project field_names</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;content&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;reviews&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;comment&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;updated_time&#x27;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面这个例子很简单，匹配 <code>_id</code> 对应的文章，删除它，第二个参数作为 <code>project</code> 声明获取的字段，最终我们会得到一个文档，但是在数据库上这个文档已经被删除了。</p>
<p>删除操作看上去很简单，但是一份数据被删除的后果可能会很严重，对于删除操作我们应该小心慎行，毕竟数据无价。</p>
<p>这部分内容涉及的文档：</p>
<ul>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.delete_one">collection – Collection level operations - delete_one()</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.delete_many">collection – Collection level operations - delete_many()</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.find_one_and_delete">collection – Collection level operations - find_one_and_delete()</a></li>
</ul>
<h3 id="insert-插入"><a href="#insert-插入" class="headerlink" title="insert 插入"></a>insert 插入</h3><p>插入操作是保存数据的核心。了解完查询、更新和删除操作的使用方法，插入操作则显得很简单。</p>
<h4 id="insert-one"><a href="#insert-one" class="headerlink" title="insert_one"></a>insert_one</h4><p>当用户发表了 1 条评论，我们需要将这条评论保存到正确的文档下面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.insert_one(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;article_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;comment&#x27;</span>: <span class="string">&#x27;Awesome!&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1531211551.682105</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的例子将保存一条来自用户 Richard 的评论，虽然评论内容没什么意义，但是它还是被正常的保存在数据库了。或许我们应该把这条评论的 ID 发回客户端，让我们稍微修改下这个例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = col.insert_one(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;article_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;comment&#x27;</span>: <span class="string">&#x27;Awesome!&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1531211551.682105</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">comment_id = result.inserted_id</span><br></pre></td></tr></table></figure>

<p>用一个变量接受插入操作的结果对象，里面包含了我们需要的 ID，使用 <code>inserted_id</code> key 可以将其取出来。你或许觉得有些麻烦，为何我们不能手动设置 ID，或者设置我们想要的 ID？</p>
<p>再修改一下代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.insert_one(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;_id&#x27;</span>: <span class="string">&#x27;cid007&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;article_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;comment&#x27;</span>: <span class="string">&#x27;Awesome!&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1531211551.682105</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当我们手动指定了 ID 字段，MongoDB 将不会自动为我们生成新的 ID，有些时候会比较有用，根据你的习惯来决定是否需要手动来设定 ID 吧！</p>
<h4 id="insert-many"><a href="#insert-many" class="headerlink" title="insert_many"></a>insert_many</h4><p>有时我们可能需要考虑到减少请求数量，仅在收集了一些评论之后才真正到进行更新，当然这里我们关注的重点是如何同时更新多条评论。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.insert_many(</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;article_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;comment&#x27;</span>: <span class="string">&#x27;Awesome!&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1531211551.682105</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;article_id&#x27;</span>: ObjectId(<span class="string">&#x27;5b432a42f04705565525529d&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;comment&#x27;</span>: <span class="string">&#x27;Awesome again!&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1531212418.92356</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们又插入了两条没有意义的评论。</p>
<p>可以看到 <code>insert_many</code> 接收一个文档 list，同样的，如果需要得到 ID，可以用一个变量接收插入操作的结果，使用 <code>inserted_ids</code> 来获得 ID，但是注意，获得的将会是一个 ID 的 list。</p>
<p>插入操作同样很简单。但是目前为止，我们似乎默认了一个事实，将评论储存在一个单独的 collection 中。</p>
<p>MongoDB 是一个文档数据库，不应该用传统的关系型数据库的思路来看待它，对于文章和评论这种典型的一对多的关系，内嵌数组会是一种更好的数据结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">articles = &#123;</span><br><span class="line">    <span class="comment"># Article ID</span></span><br><span class="line">    <span class="string">&#x27;_id&#x27;</span>: <span class="string">&#x27;5b33af56d2cbe686e00b75c9&#x27;</span>,</span><br><span class="line">    <span class="comment"># Other field_names</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># Comments</span></span><br><span class="line">    <span class="string">&#x27;comments&#x27;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment"># Comment ID</span></span><br><span class="line">            <span class="string">&#x27;cid&#x27;</span>: <span class="string">&#x27;5b3dc242f0470538510b28d7&#x27;</span>,</span><br><span class="line">            <span class="comment"># Username</span></span><br><span class="line">            <span class="string">&#x27;from&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">            <span class="comment"># Comment body</span></span><br><span class="line">            <span class="string">&#x27;body&#x27;</span>: <span class="string">&#x27;Content of comment.&#x27;</span>,</span><br><span class="line">            <span class="comment"># Created or updated timestamp</span></span><br><span class="line">            <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1529248843.301676</span>,</span><br><span class="line">            <span class="comment"># Deleted flag</span></span><br><span class="line">            <span class="string">&#x27;deleted&#x27;</span>: <span class="literal">False</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># Created or updated timestamp</span></span><br><span class="line">    <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1529248869.717813</span>,</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>评论作为一个 list 内嵌在所属的文章文档里，这时添加一个评论不再是插入操作了，它变成了一个更新操作。</p>
<h4 id="update-array-use-push"><a href="#update-array-use-push" class="headerlink" title="update array use $push"></a>update array use $push</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.update_one(</span><br><span class="line">    &#123;<span class="string">&#x27;_id&#x27;</span>: Object(<span class="string">&#x27;5b33af56d2cbe686e00b75c9&#x27;</span>)&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;$push&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;comments&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Richard&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;cid&#x27;</span>: ObjectId(),</span><br><span class="line">                <span class="string">&#x27;comment&#x27;</span>: <span class="string">&#x27;Awesome!&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1531211551.682105</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>使用 <code>$push</code> 操作符可以将一条评论添加到评论 list 中。而由于评论不再是单独的文档，不再自动生成 ID 属性，如果需要的话我们可以通过调用不带参数的 <code>ObjectId()</code> 来手动生成一个 ID 属性。</p>
<p>这部分涉及的文档：</p>
<ul>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.insert_one">collection – Collection level operations - insert_one()</a></li>
<li><a href="hhttp://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.insert_many">collection – Collection level operations - insert_many()</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/results.html#pymongo.results.InsertOneResult">results – Result class definitions - InsertOneResult</a></li>
<li><a href="http://api.mongodb.com/python/current/api/pymongo/results.html#pymongo.results.InsertManyResult">results – Result class definitions - InsertManyResult</a></li>
<li><a href="https://docs.mongodb.com/manual/reference/operator/update-array/">Array Update Operators</a></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我们已经了解了 MongoDB 的增删改查的操作。无论增删改查，都有两种模式，操作单一文档的方法后缀都是 <code>one</code>:</p>
<ul>
<li>insert_one</li>
<li>delete_one</li>
<li>update_one</li>
<li>find_one</li>
</ul>
<p>而操作多个文件基本都是加后缀 <code>many</code>，只有 <code>find</code> 是特殊的，什么都不加：</p>
<ul>
<li>insert_many</li>
<li>delete_many</li>
<li>update_many</li>
<li>find</li>
</ul>
<p>对于更新或者删除之后的数据，有时我们需要拿到更新后或者删除前的文档返回给客户端，有两个方法很实用：</p>
<ul>
<li>find_one_and_update</li>
<li>find_one_and_delete</li>
</ul>
<p>但是注意，<code>find_one_and_update</code> 默认返回更新前的文档，设定 <code>return_document=ReturnDocument.AFTER</code> 可以变更默认行为，让它返回修改后的文档。</p>
<p>对于查询来说，我们还了解了 <code>project</code> 的概念，以此来声明我们需要哪些字段。</p>
<p>对于 <code>project</code> 要注意两点：</p>
<ul>
<li><code>_id</code> 是默认会取出的，除非在 <code>project</code> 中显示地声明不包含关系（设为 <code>0</code>）</li>
<li><code>_id</code> 以外的字段，在 <code>project</code> 中不可以同时声明包含关系（设为 <code>1</code>）和不包含关系（设为 <code>0</code>），否则将会报错</li>
</ul>
<p>除此之外，我们还看了看 MongoDB 中的比较操作符，快速扫一眼：</p>
<ul>
<li><code>$eq</code> equal to</li>
<li><code>$gt</code> greater than</li>
<li><code>$gte</code> greater than or equal to</li>
<li><code>$lt</code> less than</li>
<li><code>$lte</code> less than or equal to</li>
<li><code>$ne</code> not equal to</li>
<li><code>$in</code> match in an array</li>
<li><code>$nin</code> not match in an array</li>
</ul>
<p>然后，还有更新操作符：</p>
<ul>
<li><code>$set</code> 设置更新字段内容</li>
<li><code>$inc</code> 设置更新字段增量</li>
<li><code>$push</code> 添加一个对象到内嵌数组</li>
</ul>
<p>感觉如何？是不是很简单？</p>
<p>但是等等！如果你熟悉 SQL 的话可能会想，除了这些基础的功能，在 SQL 中实用的 <code>GROUP BY</code>、<code>MAX</code>、<code>SUM</code> 甚至 <code>PARTITION BY</code> 等分析函数在 MongoDB 中没有对应的实现吗？</p>
<p>答案当然是有的！并且我们需要的大部分分析函数在 MongoDB 中都有相应的实现。MongoDB 使用 <code>aggregate</code> 来满足各种数据分析的需求，如果有机会在之后的文章中我们再来讨论一下聚合的用法吧。</p>
<p>切实需要的东西才能在我们的记忆中保留一席之地，过多实际用不到的，或者近期用不到的信息，只会让记忆系统趋于混沌。目前我们已经了解了足够的知识来使 MongoDB 为我们所用了。等到需求或者求知欲继续延伸，就是进一步学习的最好时机。</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>just notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>一个关于区块链概念的简单介绍</title>
    <url>/post/notes/just%20notes/What-is-the-Blockchain/</url>
    <content><![CDATA[<p>说到区块链就不得不提到比特币。</p>
<p>2008 年爆发全球经济危机，当年 11 月 1 日，一个化名为中本聪的人发表了比特币白皮书，《比特币：一个点对点的电子现金系统》。次年 1 月，比特币创世区块诞生。</p>
<p>比特币是一种数字货币，在白皮书中，比特币被设计为一种去中心化的电子记账系统。去中心化和记账是比特币的重点。</p>
<p>对于传统货币来说，记账行为是由银行来完成的。比如说当我们向别人转账时，银行会首先检查我们的账户余额是否足够支付这笔转账，然后记录转账结束后我们的账户中各自还有多少余额，这个过程就是记账。在生活中我们无论是使用银行卡、信用卡进行交易，还是使用支付宝、微信进行转账，记账行为始终是由银行来完成的，这是因为我们信任银行背后的国家的信用，所以将记账交给银行完成。</p>
<p>而在白皮书中，比特币被设计为一种去中心化的货币，记账行为不再经由第三方来完成，我们所有人都是参与记账的对象，并且账本是透明的，每个人随时都可以查看目前为止的所有交易记录。一笔交易从传统的第三方公证的模式转变成点对点模式，不再需要第三方进行公证，因为所有人都可以帮你证明这笔交易的有效性。</p>
<span id="more"></span>

<p>举例来说，有甲、乙、丙、丁四个人，现在甲要支付给乙 1 个比特币，那么甲要做的就是向乙支付 1 个比特币，并且将这条信息广播出去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">甲 --- 1 BTC ---&gt; 乙</span><br><span class="line">甲 --- 广播 ---&gt; 丙</span><br><span class="line">甲 --- 广播 ---&gt; 丁</span><br></pre></td></tr></table></figure>

<p>过了一会，乙又向丙支付 2 个比特币，同时也将信息广播出去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">乙 --- 2 BTC ---&gt; 丙</span><br><span class="line">乙 --- 广播 ---&gt; 甲</span><br><span class="line">乙 --- 广播 ---&gt; 丁</span><br></pre></td></tr></table></figure>

<p>再接着丙向丁支付来 5 个比特币，同时也进行广播。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">丙 --- 5 BTC ---&gt; 丁</span><br><span class="line">丙 --- 广播 ---&gt; 甲</span><br><span class="line">丙 --- 广播 ---&gt; 乙</span><br></pre></td></tr></table></figure>

<p>现在甲乙丙丁的账本是下面这样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">甲 --- 1 BTC ---&gt; 乙</span><br><span class="line">乙 --- 2 BTC ---&gt; 丙</span><br><span class="line">丙 --- 5 BTC ---&gt; 丁</span><br></pre></td></tr></table></figure>

<p>这个账本会被打包成一个块，打包出来的这个块就是我们所说的区块（Block）。一个区块的大小是 1MB，里面储存的记录根据每条记录的大小不同，大概在 4000 条左右浮动。这个区块打包完成之后，我们就把它链接到以前的交易记录上，过一段时间之后后续的区块也会被连接到这个区块上，这样就形成了一条链，就是所谓的区块链（Block Chain）。</p>
<p>不过要实现这样一个去中心化的电子记账系统，要解决非常多的问题，比如：</p>
<ul>
<li>为什么我要帮你记账/打包区块？<br>打包会消耗系统资源，而我为什么要消耗系统资源给与己无关的交易记录打包成区块？</li>
<li>该相信谁？<br>每个人都可以有自己的账本，那么以谁的账本为准呢？</li>
<li>如何认证和防伪？<br>假如有人想要伪装成另一个人进行支付，需要如何证伪呢？</li>
<li>如何防止双重支付？<br>比如一个人只有 10 个比特币，但是他同时向两个人支付 10 比特币，结果会怎么样？</li>
<li>如何防止篡改？<br>区块链上的交易记录如何防止别人篡改？</li>
</ul>
<p>其他还有很多问题，但是现在我们就对这些问题进行说明。</p>
<h2 id="为什么我要帮你记账-打包区块？"><a href="#为什么我要帮你记账-打包区块？" class="headerlink" title="为什么我要帮你记账/打包区块？"></a>为什么我要帮你记账/打包区块？</h2><p>因为记账是有奖励的，奖励分为两方面。</p>
<ul>
<li>记账获得手续费；</li>
<li>打包区块获得奖励。</li>
</ul>
<p>记账可以获得手续费，这个手续费由交易的发起者支付，比如甲要支付给乙 10 个比特币，那么甲需要多出一点作为手续费奖励给记账的人。</p>
<p>成功打包区块还会获得奖励，根据中本聪的比特币白皮书提出的方案，比特币将在每个十分钟里出现一个新的区块，每个区块奖励打包者 50 个比特币，这样持续四年时间。四年后，奖励减半，每个区块奖励打包者 25 个比特币。以此类推，再四年后每个区块奖励 12.5 比特币。这样计算到最后可以计算出比特币的最终发行量在 2100 万左右。</p>
<p>由此可以看出来比特币主要是靠打包奖励的形式扩散。这样奖励多了，竞争打包区块的人也就多了，每个人又因为网络不同，收集的交易记录也可能是不一样的，那么到底以谁的账本为准就成为了下一个问题。</p>
<h2 id="该相信谁？"><a href="#该相信谁？" class="headerlink" title="该相信谁？"></a>该相信谁？</h2><p>打包区块奖励丰厚，竞争者也越来越多，每个人所处的区域不同，收集到的交易记录可能也不尽相同，但是每个区块只能由某一个幸运儿打包成功，这个幸运儿将获得奖励，并且他的账本也将被其他人接受，成为公认的账本。但是到底如何决定谁能获得打包的权利？</p>
<p>为了解决这个问题，中本聪提出了一个方法——工作量证明。</p>
<p>简单来说，就是让每个参与打包区块的人都去做一道很复杂的数学题，第一个完成这个数学题的人将有权利进行打包，获得手续费和奖励。</p>
<p>这道数学题是非常复杂的，其复杂到根本无法通过常规的计算方式得到答案，只能通过计算机一次次尝试、碰撞出结果，运气好几次就尝试出答案，运气不好算了无数次都可能无法得出答案。这个过程其实就是我们所谓的“挖矿”——矿工消耗系统资源无数次的去尝试计算这道数学题，如果某一次刚好碰撞出了答案，获得奖励，这就是挖到矿了。</p>
<p>接下来我们说说这个数学题具体是什么。首先我们要来从什么是哈希函数说起。哈希函数，或者说数字摘要，其实指的是一种算法。这种算法根据特定的运算方式将数据转化成一份摘要的形式，并且这份摘要具有唯一性，这意味着如果你想要计算出完全一样的摘要，你必须保证输入数据也是完全一致的，从这个角度来看，哈希函数其实就是计算出某个数据的唯一身份码的算法。</p>
<p>这份摘要还有另外一个很重要的特性，那就是正向计算容易，反向计算几乎是不可能做到的。这意味着源数据将是安全的，你可以快速的计算出它的摘要，但是如果想要从一份摘要里还原出原本的数据？对不起做不到。</p>
<p>比特币的数学题其实就是利用了哈希函数的这个特性。</p>
<p>比特币使用了哈希函数中著名的 SHA256 算法。这是一个由美国国家安全局发明的一个算法，它的功能是将任何数据计算为一个长度为 256 位的二进制数字。无论你输入一段文字、输入一个视频还是输入一张图片，SHA256 的结果都将是一个 256 位的 0 或者 1 的数字。并且 SHA256 还有一个特点，如果你对源数据做出了一点改动，哪怕是加一个标点，删除一个空格这样微小的改动，都将导致 SHA256 的结果发生大幅度的变化，结果无规律可寻。</p>
<p>了解了 SHA256 算法，我们再来说比特币的数学题到底是什么。</p>
<p>首先我们知道区块链上面的每一个区块都储存了一份账本，但是除了账本之外每个区块还有一个头部信息。现在有很多打包者在参与打包，每个打包者会收集周围的交易记录作为自己的账本，拿着这份账本准备接块，首先打包者要做的是准备一个字符串，这个字符串包含很多信息，其中主要包括下面这些：</p>
<ul>
<li>前面区块的头部信息；</li>
<li>自己的账本信息；</li>
<li>时间戳；</li>
<li>其他信息；</li>
<li>随机数。</li>
</ul>
<p>准备好字符串之后，比特币要求打包者对其进行两次 SHA256 运算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sha256(sha256(<span class="string">&quot;字符串&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>第一次对字符串计算摘要获得一个 256 位的二进制数字，第二次对这个数字计算摘要，获得另外一份 256 位的二进制数字。比特币要求这个数字的前 n 位必须为 0 才能获得打包的权利，也就是说，如果比特币要求前 9 位为 0 才能获得打包权利的话，你计算两次 SHA256 的结果要像下面这样才行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000101010101010...</span><br></pre></td></tr></table></figure>

<p>如果计算出的结果不满足怎么办？上面说了 SHA256 反向推导是不可能实现的，源数据又大部分都是固定信息，能改的地方不多，所以我们只能在随机数上面动动手脚了。如果计算的结果不满足要求，那么就修改一个随机数继续计算，一直到计算出满足条件的结果为止。</p>
<p>如果这个过程中别人计算出了结果怎么办？那么这个幸运儿就接块成功获得奖励，他的账本将被链接在区块链的末尾，他计算出来的摘要将作为这个区块的头部信息保存。而其他人一看有新的块出现了，只能放弃手里的数据重新计算新的账本，拿到最新的区块的头部信息重新拼出一个字符串，继续挖矿。</p>
<p>解答这到数学题虽然有一定的运气成分在里面，但是随着计算次数增加，成功率是趋于概率的。由于结果是一份二进制数字，每一位数字除了 0 就是 1，结果中到底出现哪一个是 1/2 的概率。如果比特币要求前两位是 0，那就是 <code>1/2 * 1/2 = 1/4</code> 的概率，这意味着计算四次里面可能有一次能成功。在多要求一位为 0 就是 1/8 的概率，计算 8 次可能有一次会成功。由此可知每多增加一位要求为 0，平均计算的次数就要乘以 2，最终要求位数和计算次数的关系将是 2 的 n 次方，即如果要求前 n 位为 0，那么平均计算 2 的 n 次方词就能得到一次满足条件的结果。所以对于矿工来说，越短的时间内能计算越多的次数，挖到矿的概率就越大。这比拼的是 CPU 的计算能力。</p>
<p>回顾上文说到比特币要求前 n 位为 0 才能获得打包的权利，这个 n 其实是一个变量，用来把控计算难度。前面我们说到白皮书设计全球每 10 分钟出一个新的区块，要保证这个机制，比特币会计算出当前全球矿机的计算能力，然后根据这个数据决定到底要求前多少位为 0 可以保证平均每十分钟才出现一个新的区块。</p>
<p>所以，如果你想要获得更多的比特币，你可以做的就是去购买更多的矿机，拼命的去挖矿，这样你才可能获得更多的比特币。</p>
<h2 id="如何保证交易真实？如何认证和防伪？"><a href="#如何保证交易真实？如何认证和防伪？" class="headerlink" title="如何保证交易真实？如何认证和防伪？"></a>如何保证交易真实？如何认证和防伪？</h2><p>传统认证方式中第三方银行来对交易双方的身份进行认证和防伪。比特币作为一个去中心化的虚拟货币，在没有第三方公证的情况下如何完成认证和防伪呢？</p>
<p>答案是使用电子签名。比特币账户在注册时会生成一个随机数，这个随机数用来产生一个私钥，私钥可以产生一个公钥，公钥最终产生一个地址。</p>
<p>私钥需要保持私有，它是账户持有者身份认证所需要的，遗失私钥就等于损失了账户上所有比特币，有些人为了保护私钥，会准备一台不联网的计算机，将其保存在上面，或者强行记在脑子里。</p>
<p>公钥和地址是公开的，如果别人要给你转账，只需要提供地址给对方就可以收到转账；如果你要给别人转账，你需要提供公钥和地址才行。</p>
<p>你的私钥可以生成公钥，但是别人通过公钥是无法还原你的私钥的。私钥的功能是对信息进行加密，而公钥则对加密的信息进行解密，这种不对称的加密方式被称作非对称加密。比特币也是使用非对称加密方式进行加密，只有持有私钥的你自己可以以你的身份加密信息，别人无法伪装成你，而所有人都可以通过公钥解密你的信息。</p>
<p>所以如果甲要想向乙支付 1 个比特币，那么甲要做的就是写一条交易记录，然后对这条记录进行 SHA256 运算得出一份数字摘要，使用自己的私钥对摘要进行加密，然后将交易记录、自己的公钥和加密后的密码广播出去。</p>
<p>别人收到甲的广播之后，首先对交易记录进行 SHA256 运算得到一份数字摘要，然后使用甲的公钥对加密后的密码进行解密也得到一份数字摘要，最后对两份摘要进行比对，如果一致则认可这个交易确实是 A 的广播。而如果两份摘要不一致，则表明交易记录是伪造的，所有用户都会拒绝这份交易记录，来保证交易记录的有效性。</p>
<p>到此为止解决了第一个问题，那就是证明甲的交易记录是甲自己发出来的而不是被伪造的。现在我们可以识别甲发出的广播确实是甲发出来的了，但是接下来我们还要确认甲广播的交易是否有效，比如甲交易给乙 10 个比特币，但是甲的余额只有 5 个，显然这样的交易是无效的，那么我们如何甄别呢？</p>
<p>比特币通过追溯账本来做余额检查。每个人在使用比特币时都会下载区块链上从创世区块到当前区块的所有信息，然后做账本追溯，计算到当前区块甲还有多少余额，是否能够支付广播的数额。如果甲的余额足够，那么这条交易有效，会被记入接受广播者的账本中。反之，接收广播的人就会拒绝这条交易记录，这条信息就不会被打包到区块链上。</p>
<h2 id="如何防止双重支付？"><a href="#如何防止双重支付？" class="headerlink" title="如何防止双重支付？"></a>如何防止双重支付？</h2><p>假如甲只有 10 个比特币，但是甲几乎同时发出两个广播，一个广播内容是甲支付给乙 10 个比特币，第二个广播内容是甲支付给丙 10 个比特币，那么结果会如何？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">甲 --- 10 BTC ---&gt; 乙</span><br><span class="line">甲 --- 10 BTC ---&gt; 丙</span><br></pre></td></tr></table></figure>

<p>由于网络的关系，可能会有两拨人以不同的顺序收到甲的广播。第一波人先收到甲支付给乙 10 个比特币这条广播，然后从区块链上追溯得知甲的余额是 10 个比特币，这条广播会被接受并写入他们的账本中，然后当接收到第二天甲支付给丙 10 个比特币的广播时，由于检查到甲余额不足，这条广播会被拒绝。</p>
<p>另外一波人则相反，由于网络延迟它们可能先收到甲支付给丙 10 个比特币的广播，然后同样追溯余额发现甲的余额足够，所以接受了这条广播，然后接收到甲支付给乙 10 个比特币的广播时检查到余额不足就会拒绝。</p>
<p>不过目前这笔交易还仅在每个人的本地账本中存在，最终只有被链接到区块链上才会最终被承认。这意味着所有参与打包的人中赢得打包权利的人可以决定甲到底是给乙支付了 10 个比特币，还是给丙支付了 10 个比特币。而一旦区块链上生成了记录这笔交易的一个区块，那么所有参与打包的人就会放弃自己本地的账本，转而重新收集交易记录，并参与打包的竞争。</p>
<p>所以在比特币交易中，交易并不是立刻完成的，发生交易后我们需要等待交易记录最终被记录到区块链上才能证明我们最终收到了这笔转账。这也防止了双重支付的出现。</p>
<h2 id="如何防止他人篡改？"><a href="#如何防止他人篡改？" class="headerlink" title="如何防止他人篡改？"></a>如何防止他人篡改？</h2><p>到目前我们知道，只有被链接到区块上的交易记录才是被认可的，而且每个人使用私钥和公钥进行不对称加密来广播交易记录，这个交易记录是几乎不可能被伪造的。这样如果有人想要篡改区块链上的交易记录，其实能做的事情很少，他只能删除某个交易记录。那么如何防止他人篡改删除记录呢？</p>
<p>我们先回到上面的例子，甲同时广播两条交易，然后两拨人以不同顺序收到了广播，这两拨人里面有两个幸运儿几乎同时算出了数学题的解，那么区块链上可能就出现了分歧，末尾有两个不同分支的区块存在！</p>
<p>比特币通过最长链原则解决这个问题。如果区块链上出现了分支存在，没关系，后续参与打包者会随机拿到其中一个区块，然后继续打包，等到下面一个区块出现时，两个分支的长度就发生了变化，比特币会自动选择最长的链作为主链，并且所有打包者会重新在主链后面继续打包，因为这条链最有希望成为公认最长链的。</p>
<p>你可能看出来了，实际上如果一个人想要篡改某一个区块的交易记录的话，还是有可能做到的。比如说下面这个情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A   B   C   D   E</span><br><span class="line">□ → □ → □ → □ → □</span><br></pre></td></tr></table></figure>

<p>这里有区块链上从 A 到 E 五个区块，最后一个区块是 E，无数打包者都在 E 后面拼命的想要拿到打包权利赢得奖励。此时有一个人想要删除 C 块上的一个交易记录，他可以做到吗？答案是可能的。</p>
<p>他需要做的是删除指定的交易记录后重新打包 C 的账本，然后从 B 块开始重新做数学题，然后打包新的区块链接到 B 的后面，也就是新的 C 块，新的 D 块，新的 E 块。</p>
<p>但是要注意，比特币自动调整难度控制每十分钟出一个区块，在这个人打包新的 C 块、D 块、E 块的时候，全球的矿工都在 E 块后面拼命打包新的区块。要保证他打包的区块最终能成为主链然后被接受，他必须在全球矿工打包出更多新的区块之前把这条分支打包的更长，这样比特币根据最长链原则就会选择他的链作为主链，其他打包者也会自动选择他的链打包新的块，这样他删除某条记录的目的就打到链。不过要做到这一点，他必须掌握足够的计算力，至少他要掌控全球矿工计算力的 50% 以上才有可能达成目的。但是这里就有一个悖论出现了。</p>
<p>这个悖论就是要达到删除某一个交易记录的目的，需要消耗无数倍的成本来推动这件事情。如果这个人掌握了全球矿机的 50% 以上的计算力，那么他也没有必要为了删除某一个记录来对区块重新打包，他用自己掌握的计算力在主链后面继续打包不是赚的更多吗？所以，篡改记录是非常不划算的。比特币通过这样的机制来防止篡改的发生，也由于篡改记录的成本非常之高，所以发生篡改的可能性是非常非常低的。</p>
<p>发生篡改的可能性低也并不是没有可能发生，但是由于篡改的代价随着新的区块增加是指数增长的，所以对大型的交易来说，一般等 6 个区块左右才能最终确定交易成功，基本没有可能被篡改了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比特币作为一种技术手段实现的去中心化的虚拟货币，十分新颖。它发行量固定，没有滥发风险；它去中心化，交易成本低，手续费低；它安全，可追溯，且匿名，透明。</p>
<p>但是另一方面由于比特币是匿名货币，它给犯罪、贩毒、洗钱等违法行为也带来了同等便利。每个地区的政府对其态度不一，有支持也有打压。也有投机者参与导致比特币价格暴涨暴跌，有人一夜暴富也有人倾家荡产。</p>
<p>技术本身并没有错，区块链作为支撑比特币的技术手段，还是非常有前景的。比如区块链在物流、食品安全方面的应用，也比如智能合约等。</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>just notes</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>20.Swift Initialization and Deinitialization</title>
    <url>/post/notes/swift/20-InitializationAndDeinitialization/</url>
    <content><![CDATA[<p>干货满满的一篇内容，虽然我记录的可能有点意识流了。</p>
<p>先说说简单的卸载器（<code>deinitializer</code>），只有类有，自动继承，在对象被销毁前执行，和之前 Basics 的内容一般无二，很好理解。</p>
<p>然后是初始化器（<code>initializer</code>），内容多了很多。首先是提到了值类型引用的结构体和枚举类型，它们由于没有继承关系，所以初始化器相对简单。它们可以定义委派初始化器，其意思是一个初始化器中调用另一个初始化器，减少代码重复，让每个初始化器专注自己的功能。委派初始化器没有关键字。</p>
<p>另一边，类由于存在继承关系，所以相对复杂一些，类有指定初始化器和便利初始化器的定义。</p>
<ul>
<li>指定初始化器：初始化类的所有属性，并调用父类的指定初始化器；</li>
<li>便利初始化器：调用同类的指定初始化器，并对其中一部分值给予默认值。</li>
</ul>
<span id="more"></span>

<p>其实看来类的便利初始化器就是结构体和枚举类型的委派初始化器。但是由于类有继承关系，要保证初始化完整执行的复杂度提升了一个维度。</p>
<p>Swift 为了保证类进行正确的初始化，会执行两个阶段的初始化任务。在第一个阶段类会完成自己的属性的初始化，并且向上完成父类链上所有父类的属性的初始化，此时属性的初始化一步一步攀登到了父类链顶端；第二个阶段，从父类链顶端开始执行顶级父类的自定义操作，执行完成后接力给次级父类，一步一步回归到当前类，最终当前类完成自定义操作。</p>
<p>官方文档花了很大的篇幅介绍这个过程，但看明白了之后就知道了，实际上就是一个递归，保证属性的初始化是从当前类出发一直到父类链顶层，然后自定义操作从父类顶级一直回归到当前类。当前类先初始化属性，最后完成初始化操作，这在其他语言中应该也是同样的，但是 Swift 可能做了更多的保护措施。</p>
<p>此外，对于父类的指定初始化器来说，子类的覆写需要 <code>override</code> 关键字，但是对父类的便利初始化器来说子类覆写不需要关键字。理由是，对于父类便利初始化器的覆写，实际上对子类来说父类的便利初始化器不会有机会再被调用了，所以这实际上不是一个覆写操作，而是子类创建了一个新的初始化器。</p>
<p>子类对于父类初始化器的继承也有一定的限制。默认情况下是不会自动继承父类初始化器的，但是当子类满足下面两个条件时，父类的所有初始化器都会被子类继承。</p>
<ul>
<li>子类没有自定义属性也没有自己的初始化器：此时子类完全继承父类的所有初始化器，包括指定初始化器和便利初始化器；</li>
<li>子类覆写了所有父类的指定初始化器时：此时子类将继承父类的所有便利初始化器。</li>
</ul>
<p>一个类中，除了可以定义上面所说的初始化器之外，还可以定义一种允许失败的特殊初始化器。官方称之为“Failable Initializers”，实际上它只是一个附带安全检查的初始化器，它会在初始化对象时进行自定义的检查，如果条件不满足的情况——通常是参数值不符合要求，或者根据某个全局变量进行判断——初始化会立刻失败，并且返回 <code>nil</code>。它其实是可选型变量的高级版，可返回 <code>nil</code> 的初始化器。它的定义方式是在 <code>init</code> 后加上问号，也就是 <code>init?</code>。对于这种类型的初始化器，子类可以继承它，并且根据需要将其变成不允许失败的初始化器，这一操作往往通过提供一个默认值来实现。另一方面，子类是不能将父类的一个非允许失败初始化器改写成允许失败初始化器的。</p>
<p>另外，这种可以允许失败的初始化器在结构体和枚举类型中也是适用的。</p>
<blockquote>
<p>R：内容满满，光小结就将近 1，500 字，全篇内容更是超过了 18，000 字。(˚ ˃̣̣̥ω˂̣̣̥ )</p>
</blockquote>
<h2 id="初始化器和卸载器"><a href="#初始化器和卸载器" class="headerlink" title="初始化器和卸载器"></a>初始化器和卸载器</h2><h3 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h3><p>初始化器提供一定灵活性，在实例化对象时做一些操作。一般用来接收变量赋值，做一些特殊的初始化操作。先做个复习。</p>
<blockquote>
<p>R：就是 Java 的构造函数。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fahrenheit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperature: <span class="type">Double</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        temperature <span class="operator">=</span> <span class="number">32.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f <span class="operator">=</span> <span class="type">Fahrenheit</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The default temperature is <span class="subst">\(f.temperature)</span>° Fahrenheit&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The default temperature is 32.0° Fahrenheit&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以存在多个初始化器，可以接收参数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Celsius</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">fromFahrenheit</span> <span class="params">fahrenheit</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> (fahrenheit <span class="operator">-</span> <span class="number">32.0</span>) <span class="operator">/</span> <span class="number">1.8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">fromKelvin</span> <span class="params">kelvin</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> kelvin <span class="operator">-</span> <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> boilingPointOfWater <span class="operator">=</span> <span class="type">Celsius</span>(fromFahrenheit: <span class="number">212.0</span>)</span><br><span class="line"><span class="comment">// boilingPointOfWater.temperatureInCelsius is 100.0</span></span><br><span class="line"><span class="keyword">let</span> freezingPointOfWater <span class="operator">=</span> <span class="type">Celsius</span>(fromKelvin: <span class="number">273.15</span>)</span><br><span class="line"><span class="comment">// freezingPointOfWater.temperatureInCelsius is 0.0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> red, green, blue: <span class="type">Double</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">red</span>: <span class="type">Double</span>, <span class="params">green</span>: <span class="type">Double</span>, <span class="params">blue</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.red   <span class="operator">=</span> red</span><br><span class="line">        <span class="keyword">self</span>.green <span class="operator">=</span> green</span><br><span class="line">        <span class="keyword">self</span>.blue  <span class="operator">=</span> blue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">white</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        red   <span class="operator">=</span> white</span><br><span class="line">        green <span class="operator">=</span> white</span><br><span class="line">        blue  <span class="operator">=</span> white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> magenta <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">1.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">let</span> halfGray <span class="operator">=</span> <span class="type">Color</span>(white: <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p>也可以不使用标签。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Celsius</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">fromFahrenheit</span> <span class="params">fahrenheit</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> (fahrenheit <span class="operator">-</span> <span class="number">32.0</span>) <span class="operator">/</span> <span class="number">1.8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">fromKelvin</span> <span class="params">kelvin</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> kelvin <span class="operator">-</span> <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">celsius</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> celsius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bodyTemperature <span class="operator">=</span> <span class="type">Celsius</span>(<span class="number">37.0</span>)</span><br><span class="line"><span class="comment">// bodyTemperature.temperatureInCelsius is 37.0</span></span><br></pre></td></tr></table></figure>

<p>可以不初始化可选类型的属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurveyQuestion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String</span>?</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">text</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">ask</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cheeseQuestion <span class="operator">=</span> <span class="type">SurveyQuestion</span>(text: <span class="string">&quot;Do you like cheese?&quot;</span>)</span><br><span class="line">cheeseQuestion.ask()</span><br><span class="line"><span class="comment">// Prints &quot;Do you like cheese?&quot;</span></span><br><span class="line">cheeseQuestion.response <span class="operator">=</span> <span class="string">&quot;Yes, I do like cheese.&quot;</span></span><br></pre></td></tr></table></figure>

<p>类有默认的初始化器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingListItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> quantity <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> purchased <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> item <span class="operator">=</span> <span class="type">ShoppingListItem</span>()</span><br></pre></td></tr></table></figure>

<p>结构体也有默认的初始化器，初始化所有属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingListItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> quantity <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> purchased <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> item <span class="operator">=</span> <span class="type">ShoppingListItem</span>()</span><br></pre></td></tr></table></figure>

<p>值类型的委派初始化器，名字不好理解，但是指的是为了减少重复代码，在一个初始化器中调用另一个初始化器完成一部分工作这一动作。</p>
<p>委派初始化器对类、结构体&amp;枚举类型采取不同的工作模式和形式。因为枚举类型和结构体不支持继承，所以相对简单，只需要处理它们声明的其他初始化器就足够了。类可以继承其他的类，这导致类需要额外保证它继承的类的所有属性是否正确的初始化。</p>
<p>另外如果值类型，也就是枚举类型或结构体定义了一个初始化器，那么它本身默认自动生成的初始化器将无法访问。</p>
<p>下面定义一个四边形结构体，储存一个起点和尺寸信息。四边形结构体有两个初始化器，一个接收起点和尺寸，另一个接收中点和尺寸，后者通过中点计算出起点，并且调用前者进行真正的赋值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">origin</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.origin <span class="operator">=</span> origin</span><br><span class="line">        <span class="keyword">self</span>.size <span class="operator">=</span> size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">center</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> originX <span class="operator">=</span> center.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY <span class="operator">=</span> center.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意由于定义了新的初始化器，默认的初始化器将被失效，为了保证默认初始化方法，需要手动添加空的 <code>init()</code> 初始化器，这能保证下面的实例化能正常执行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> basicRect <span class="operator">=</span> <span class="type">Rect</span>()</span><br><span class="line"><span class="comment">// basicRect&#x27;s origin is (0.0, 0.0) and its size is (0.0, 0.0)</span></span><br></pre></td></tr></table></figure>

<p>剩余两个初始化器调用实例。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> originRect <span class="operator">=</span> <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">2.0</span>, y: <span class="number">2.0</span>),</span><br><span class="line">                      size: <span class="type">Size</span>(width: <span class="number">5.0</span>, height: <span class="number">5.0</span>))</span><br><span class="line"><span class="comment">// originRect&#x27;s origin is (2.0, 2.0) and its size is (5.0, 5.0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> centerRect <span class="operator">=</span> <span class="type">Rect</span>(center: <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">4.0</span>),</span><br><span class="line">                      size: <span class="type">Size</span>(width: <span class="number">3.0</span>, height: <span class="number">3.0</span>))</span><br><span class="line"><span class="comment">// centerRect&#x27;s origin is (2.5, 2.5) and its size is (3.0, 3.0)</span></span><br></pre></td></tr></table></figure>

<p>类的继承和初始化。</p>
<p>类的所有属性，包括从父类继承来的属性，在初始化期间都需要进行赋值。Swift 提供两种方式保证类的属性都正确初始化，分别是 <code>designated initializers</code> 指定初始化器和 <code>convenience initializers</code> 便利初始化器。</p>
<p>指定初始化器是类的主要的初始化器。一个指定的初始化器会初始化所有属性，并且调用父类的初始化器一步步调用继承链上所有父类的初始化器。</p>
<p>类通常不会有很多指定初始化器，实践来说通常一个类仅有一个指定初始化器。一个类至少需要一个指定初始化器，通常这可能是通过继承父类的初始化器。</p>
<p>便利初始化器是类支持的次级初始化器。你可以用便利初始化器调用指定初始化器，并对其部分值设定默认值。这可以应对指定场合或输入值类型的情况。但便利初始化器是可选的。便利初始化器需要关键字 <code>convenience</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">init</span>(parameters)</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">convenience</span> <span class="function"><span class="keyword">init</span>(parameters)</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了整清楚指定初始化器和便利初始化器直接的关系，Swift 设定了下面三个规则用于相会委派初始化器。</p>
<ul>
<li>Rule 1：指定初始化器必须调用直属父类的指定初始化器。</li>
<li>Rule 2：一个便利初始化器中必须调用同类下的另一个初始化器。</li>
<li>Rule 3：一个便利初始化器必须调用一个指定初始化器。</li>
</ul>
<p>一个速记方法：</p>
<ul>
<li>指定初始化器必须向上委派；</li>
<li>便利初始化器必须同级委派。</li>
</ul>
<p>初始化的两个阶段。第一个阶段初始化每一个字段，第二个阶段对属性做自定义操作，之后实例化完成，对象可以正常访问。以此来保证属性初始化之后才能访问，防止属性赋值顺序导致预料外的覆盖。</p>
<p>Swift 编译器会做 4 步安全检查保证初始化的安全性。</p>
<ul>
<li>安全检查 1: 指定初始化器必须保证所在类的所有属性初始化完成，并且向上委派父类的初始化器。</li>
<li>安全检查 2: 在对继承的属性进行赋值时指定初始化器必须先委派父类的初始化器初始化该属性，否则在父类初始化的过程中会将新的值覆盖。</li>
<li>安全检查 3: 便利初始化器在操作属性之前必须调用本身类的指定初始化器，否则新的值会在自身的指定初始化器的初始化过程中被覆盖。</li>
<li>安全检查 4: 在第一步阶段完成之前初始化器无法操作方法和变量，或访问 <code>self</code> 属性。</li>
</ul>
<p>下面是两步初始化的过程。</p>
<p>第一步：</p>
<ul>
<li>类的指定初始化器或者便利初始化器被调用；</li>
<li>分配内存给类的新实例，内存尚未初始化；</li>
<li>指定初始化器给类的所有属性初始化，此时这些属性的内存已被初始化；</li>
<li>指定初始化器调用父类初始化器，接力完成父类的属性初始化；</li>
<li>父类初始化器持续调用父类链上所有父类的初始化器，直到最后一个父类完成初始化；</li>
<li>一旦到达父类链顶端，且顶级父类完成初始化，则认为实例内存完全初始化完毕，第一阶段结束。</li>
</ul>
<p>第二步：</p>
<ul>
<li>从顶级父类向下一步步执行指定初始化器中属性初始化以外的自定义任务，此时已经可以访问 <code>self</code>，可以读写属性，可以调用方法；</li>
<li>最后，便利初始化器可以定制实例，操作 <code>self</code> 变量。</li>
</ul>
<p>初始化器的继承和覆盖（Override）。在 Swift 中子类默认不继承父类的初始化器，这可以防止父类的某个简单的初始化器被一个特化的子类继承并用来实例化而导致子类的属性没有被完全初始化完成的情况。</p>
<p>如果你想定义一个和父类相同的初始化器，你可以提供一个定制化的实现给父类的初始化器，这实际上是对父类初始化器的覆盖，而覆盖父类的指定初始化器必须写 <code>override</code> 关键字，即使是默认生成的初始化器。反之，便利初始化器可以不用写，因为如果你覆盖了一个父类的便利初始化器，实际上父类的便利初始化器就不会在被调用了，所以这严格来说你并没有覆盖它。</p>
<blockquote>
<p>R：你干掉了一个便利初始化器，并提供了一个新的，所以你没有“覆盖”它，所以你不用写 <code>override</code> 关键字。对于指定初始化器来说，你需要调用父类的指定初始化器，所以实际上你“覆盖”了它，或者说扩展了它？</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfWheels <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(numberOfWheels)</span> wheel(s)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 Vehicle 没有定义初始化器，但是它会有一个默认的初始化器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vehicle <span class="operator">=</span> <span class="type">Vehicle</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Vehicle: <span class="subst">\(vehicle.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Vehicle: 0 wheel(s)</span></span><br></pre></td></tr></table></figure>

<p>下面子类继承了 Vehicle，它修改了父类的默认初始化器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        numberOfWheels <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bicycle 的初始化器中先执行了 <code>super.init()</code>，保证了父类属性初始化完成后，才对属性进行操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hoverboard</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">color</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.color <span class="operator">=</span> color</span><br><span class="line">        <span class="comment">// super.init() implicitly called here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(<span class="keyword">super</span>.description)</span> in a beautiful <span class="subst">\(color)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vehicle 另一个子类 Hoverboard 没有覆盖父类的默认初始化器，而且它在初始化器中只初始化了自身的属性，而父类的初始化会隐式地被调用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hoverboard <span class="operator">=</span> <span class="type">Hoverboard</span>(color: <span class="string">&quot;silver&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hoverboard: <span class="subst">\(hoverboard.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Hoverboard: 0 wheel(s) in a beautiful silver</span></span><br></pre></td></tr></table></figure>

<p>初始化器自动继承。初始化器不会默认继承，但是当满足某些条件时，初始化器会自动继承。这意味着在大多场景你不需要覆写初始化器，当父类的初始化器是安全的时候，你可以直接继承它。</p>
<p>假设你的子类的所有属性都初始化完成了，下面两个规则会被应用：</p>
<ul>
<li>如果子类没有指定初始化器，父类的所有初始化器将被继承；</li>
<li>如果父类的指定初始化器全都得到实现，可以是覆盖，或者根据第一条规则继承，则父类的所有便利初始化器也将被继承。</li>
</ul>
<p>例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: <span class="string">&quot;[Unnamed]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> namedMeat <span class="operator">=</span> <span class="type">Food</span>(name: <span class="string">&quot;Bacon&quot;</span>)</span><br><span class="line"><span class="comment">// namedMeat&#x27;s name is &quot;Bacon&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mysteryMeat <span class="operator">=</span> <span class="type">Food</span>()</span><br><span class="line"><span class="comment">// mysteryMeat&#x27;s name is &quot;[Unnamed]&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipeIngredient</span>: <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> quantity: <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">quantity</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.quantity <span class="operator">=</span> quantity</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">convenience</span> <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, quantity: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：RecipeIngredient 的 init(name) 前面的 <code>override</code> 是因为它覆盖了父类的指定初始化器，看来需不需要 <code>override</code> 是看是否覆盖了父类的指定初始化器。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oneMysteryItem <span class="operator">=</span> <span class="type">RecipeIngredient</span>()</span><br><span class="line"><span class="keyword">let</span> oneBacon <span class="operator">=</span> <span class="type">RecipeIngredient</span>(name: <span class="string">&quot;Bacon&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> sixEggs <span class="operator">=</span> <span class="type">RecipeIngredient</span>(name: <span class="string">&quot;Eggs&quot;</span>, quantity: <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>RecipeIngredient 实现了父类的所有指定初始化器，所以它继承了父类所有的便利初始化器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingListItem</span>: <span class="title">RecipeIngredient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> purchased <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(quantity)</span> x <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">        output <span class="operator">+=</span> purchased <span class="operator">?</span> <span class="string">&quot; ✔&quot;</span> : <span class="string">&quot; ✘&quot;</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 SHoppingListItem 虽然没有定义任何初始化器，但是它对自身所有属性进行了初始化，所以它自定继承了父类的指定初始化器和便利初始化器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> breakfastList <span class="operator">=</span> [</span><br><span class="line">    <span class="type">ShoppingListItem</span>(),</span><br><span class="line">    <span class="type">ShoppingListItem</span>(name: <span class="string">&quot;Bacon&quot;</span>),</span><br><span class="line">    <span class="type">ShoppingListItem</span>(name: <span class="string">&quot;Eggs&quot;</span>, quantity: <span class="number">6</span>),</span><br><span class="line">]</span><br><span class="line">breakfastList[<span class="number">0</span>].name <span class="operator">=</span> <span class="string">&quot;Orange juice&quot;</span></span><br><span class="line">breakfastList[<span class="number">0</span>].purchased <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> breakfastList &#123;</span><br><span class="line">    <span class="built_in">print</span>(item.description)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 x Orange juice ✔</span></span><br><span class="line"><span class="comment">// 1 x Bacon ✘</span></span><br><span class="line"><span class="comment">// 6 x Eggs ✘</span></span><br></pre></td></tr></table></figure>

<p>允许失败的初始化器。由于参数值、外部资源或者其他的条件不被满足等情况可能会造成初始化过程失败，你可以通过 <code>init?</code> 的形式定义允许失败的初始化器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> species: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init?</span>(<span class="params">species</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> species.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.species <span class="operator">=</span> species</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someCreature <span class="operator">=</span> <span class="type">Animal</span>(species: <span class="string">&quot;Giraffe&quot;</span>)</span><br><span class="line"><span class="comment">// someCreature is of type Animal?, not Animal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> giraffe <span class="operator">=</span> someCreature &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;An animal was initialized with a species of <span class="subst">\(giraffe.species)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;An animal was initialized with a species of Giraffe&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anonymousCreature <span class="operator">=</span> <span class="type">Animal</span>(species: <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">// anonymousCreature is of type Animal?, not Animal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> anonymousCreature <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The anonymous creature could not be initialized&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The anonymous creature could not be initialized&quot;</span></span><br></pre></td></tr></table></figure>

<p>枚举类型的允许失败的初始化器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TemperatureUnit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> kelvin, celsius, fahrenheit</span><br><span class="line">    <span class="function"><span class="keyword">init?</span>(<span class="params">symbol</span>: <span class="type">Character</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> symbol &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;K&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .kelvin</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .celsius</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;F&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .fahrenheit</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fahrenheitUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(symbol: <span class="string">&quot;F&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> fahrenheitUnit <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is a defined temperature unit, so initialization succeeded.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;This is a defined temperature unit, so initialization succeeded.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unknownUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(symbol: <span class="string">&quot;X&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> unknownUnit <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is not a defined temperature unit, so initialization failed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;This is not a defined temperature unit, so initialization failed.&quot;</span></span><br></pre></td></tr></table></figure>

<p>关于 rawType 的使用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TemperatureUnit</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> kelvin <span class="operator">=</span> <span class="string">&quot;K&quot;</span>, celsius <span class="operator">=</span> <span class="string">&quot;C&quot;</span>, fahrenheit <span class="operator">=</span> <span class="string">&quot;F&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fahrenheitUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(rawValue: <span class="string">&quot;F&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> fahrenheitUnit <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is a defined temperature unit, so initialization succeeded.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;This is a defined temperature unit, so initialization succeeded.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unknownUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(rawValue: <span class="string">&quot;X&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> unknownUnit <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is not a defined temperature unit, so initialization failed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;This is not a defined temperature unit, so initialization failed.&quot;</span></span><br></pre></td></tr></table></figure>

<p>初始化失败的传播（Propagation）。一个允许失败的初始化器可能会调用同级的其他初始化器，如果是类的话，还可能调用父类的初始化器。而一个允许失败的初始化器执行过程中失败了，那么整个初始化过程会立即失败，后续的代码不会再被执行。</p>
<p>下面是一个例子，父类 Product 检查 name 属性为空的情况下初始化失败，而它的子类 CartItem 则检查 quantity 属性至少不能小于 1，否则初始化失败。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItem</span>: <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> quantity: <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">quantity</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> quantity <span class="operator">&lt;</span> <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.quantity <span class="operator">=</span> quantity</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样按照顺序，如果 quantity 不符合要求，初始化过程立刻结束，程序不会执行后面的 name 检查。而如果 quantity 没问题，程序会继续检查 name 属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> twoSocks <span class="operator">=</span> <span class="type">CartItem</span>(name: <span class="string">&quot;sock&quot;</span>, quantity: <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Item: <span class="subst">\(twoSocks.name)</span>, quantity: <span class="subst">\(twoSocks.quantity)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Item: sock, quantity: 2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> zeroShirts <span class="operator">=</span> <span class="type">CartItem</span>(name: <span class="string">&quot;shirt&quot;</span>, quantity: <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Item: <span class="subst">\(zeroShirts.name)</span>, quantity: <span class="subst">\(zeroShirts.quantity)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to initialize zero shirts&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Unable to initialize zero shirts&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> oneUnnamed <span class="operator">=</span> <span class="type">CartItem</span>(name: <span class="string">&quot;&quot;</span>, quantity: <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Item: <span class="subst">\(oneUnnamed.name)</span>, quantity: <span class="subst">\(oneUnnamed.quantity)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to initialize one unnamed product&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Unable to initialize one unnamed product&quot;</span></span><br></pre></td></tr></table></figure>

<p>关于覆写父类的允许失败的初始化器。子类可以复写父类的允许失败的初始化器，有点绕口。子类还可以控制是否让其继续允许失败。但是反之是不行的，你不可以让父类的一般初始化器覆写为允许失败的初始化器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="comment">// this initializer creates a document with a nil name value</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// this initializer creates a document with a nonempty name value</span></span><br><span class="line">    <span class="function"><span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面定义了一个类 Document，下面定义另一个类继承它，并复写它的允许失败的初始化器，并让其保证不会出现返回 <code>nil</code> 的情况。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticallyNamedDocument</span>: <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;[Untitled]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123;</span><br><span class="line">            <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;[Untitled]&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外你可以用感叹号替代问好，<code>init?</code> = <code>init!</code>。你也可以在正常的初始化器中调用 <code>init!</code>，虽然这样做会在初始化失败时触发一个断言。</p>
<p>父类可以用 <code>required</code> 关键字定义一个初始化器，这样所有继承它的子类都必须实现这个初始化器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// initializer implementation goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你的子类也需要 <code>required</code> 关键字保证它的子类也要实现这个初始化器，但是这里覆写不需要 <code>override</code> 关键字。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubclass</span>: <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// subclass implementation of the required initializer goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：官网文档备注了一点，就是如果子类满足父类的必须初始化器的执行条件的话，可以不用实现这个初始化器，因为父类的初始化器可以被继承来。</p>
</blockquote>
<p>用闭包或函数给类的属性设置默认值。</p>
<p>如果某个属性需要定制或者设定，你可以使用闭包或者某个全局函数来给它提供一个默认的值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> someProperty: <span class="type">SomeType</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="comment">// create a default value for someProperty inside this closure</span></span><br><span class="line">        <span class="comment">// someValue must be of the same type as SomeType</span></span><br><span class="line">        <span class="keyword">return</span> someValue</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意属性大括号后的小括号，这表示立刻执行闭包，如果没有这个括号，则表示你在将这个闭包赋值给该属性。</p>
<p>下面的结构体用闭包创建了一个 8x8 的国际象棋棋盘。用布尔值表示黑白。每次新的棋盘被创建时都会执行闭包，初始化创建一个新的棋盘。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chessboard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> boardColors: [<span class="type">Bool</span>] <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> temporaryBoard <span class="operator">=</span> [<span class="type">Bool</span>]()</span><br><span class="line">        <span class="keyword">var</span> isBlack <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">8</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">8</span> &#123;</span><br><span class="line">                temporaryBoard.append(isBlack)</span><br><span class="line">                isBlack <span class="operator">=</span> <span class="operator">!</span>isBlack</span><br><span class="line">            &#125;</span><br><span class="line">            isBlack <span class="operator">=</span> <span class="operator">!</span>isBlack</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temporaryBoard</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">squareIsBlackAt</span>(<span class="params">row</span>: <span class="type">Int</span>, <span class="params">column</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boardColors[(row <span class="operator">*</span> <span class="number">8</span>) <span class="operator">+</span> column]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> board <span class="operator">=</span> <span class="type">Chessboard</span>()</span><br><span class="line"><span class="built_in">print</span>(board.squareIsBlackAt(row: <span class="number">0</span>, column: <span class="number">1</span>))</span><br><span class="line"><span class="comment">// Prints &quot;true&quot;</span></span><br><span class="line"><span class="built_in">print</span>(board.squareIsBlackAt(row: <span class="number">7</span>, column: <span class="number">7</span>))</span><br><span class="line"><span class="comment">// Prints &quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="卸载器（deinitializer）"><a href="#卸载器（deinitializer）" class="headerlink" title="卸载器（deinitializer）"></a>卸载器（deinitializer）</h3><p>卸载器用来在实例将被释放内存之前做一些操作。只有类才能定义卸载器。</p>
<p>Swift 会自动在一个实例不再需要的时候回收它来释放资源。内存管理基于自动引用计算（ARC）实现，你不需要手动去释放一个对象。但是当你操作你自己的资源时，有时你需要手动做一些清洁操作。例如你创建一个类打开一个文件写一些数据，你需要在实例被释放之前关闭文件释放资源。</p>
<p>一个类最多一个卸载器，而且不需要参数，不需要括号。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="comment">// perform the deinitialization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>卸载器在实例被释放前自动调用，不允许手动调用。父类的卸载器自动被子类继承，并且在子类的卸载器执行完成之后被执行。父类的卸载器一定会被执行，即使子类没有提供一个卸载器。</p>
<p>下面是卸载器的一个实例。首先我们定义一局游戏，游戏中有 Bank 和 Player 两个类。</p>
<p>Bank 储存 coins，并保证市场上最多流通有 1 万枚硬币。它有发布和收集两个方法用来分发个回收硬币。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> coinsInBank <span class="operator">=</span> <span class="number">10_000</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">distribute</span>(<span class="params">coins</span> <span class="params">numberOfCoinsRequested</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> numberOfCoinsToVend <span class="operator">=</span> <span class="built_in">min</span>(numberOfCoinsRequested, coinsInBank)</span><br><span class="line">        coinsInBank <span class="operator">-=</span> numberOfCoinsToVend</span><br><span class="line">        <span class="keyword">return</span> numberOfCoinsToVend</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">receive</span>(<span class="params">coins</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        coinsInBank <span class="operator">+=</span> coins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>distribute(coins:)</code> 方法最多发行出 1 万枚硬币，如果要求的数量大于银行剩余的量，则会返回银行当前剩余的硬币。<code>receive(coins:)</code> 方法用来回收硬币。</p>
<p>Player 类描述这局游戏的玩家角色。每个玩家都有一个钱包，储存一定的硬币，使用 <code>coinsInPurse</code> 属性表示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coinsInPurse: <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">coins</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        coinsInPurse <span class="operator">=</span> <span class="type">Bank</span>.distribute(coins: coins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">win</span>(<span class="params">coins</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        coinsInPurse <span class="operator">+=</span> <span class="type">Bank</span>.distribute(coins: coins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="type">Bank</span>.receive(coins: coinsInPurse)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个玩家被实例化时都会收到一份初始资金，当然如果银行硬币余量不够时可能回收到比预期少的资金。玩家有一个 <code>win(coins:)</code> 方法可以从银行那边赢取一定的硬币。Player 类还有一个卸载器，用来在玩家离开游戏后保证资金回转到银行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> playerOne: <span class="type">Player</span>? <span class="operator">=</span> <span class="type">Player</span>(coins: <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A new player has joined the game with <span class="subst">\(playerOne<span class="operator">!</span>.coinsInPurse)</span> coins&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;A new player has joined the game with 100 coins&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;There are now <span class="subst">\(Bank.coinsInBank)</span> coins left in the bank&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;There are now 9900 coins left in the bank&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中我们用可选型变量创建了一个 Player 对象，因为玩家可能在任何时候退出游戏。而因为使用了可选型类型，每次访问 Player 类的属性和方法时都需要加上感叹号(<code>!</code>) 来断言其一定存在。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">playerOne<span class="operator">!</span>.win(coins: <span class="number">2_000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PlayerOne won 2000 coins &amp; now has <span class="subst">\(playerOne<span class="operator">!</span>.coinsInPurse)</span> coins&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;PlayerOne won 2000 coins &amp; now has 2100 coins&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The bank now only has <span class="subst">\(Bank.coinsInBank)</span> coins left&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The bank now only has 7900 coins left&quot;</span></span><br></pre></td></tr></table></figure>

<p>你看，这名玩家又赢得了 2，000 硬币，现在他有 2，100 枚硬币了。而银行还剩下 7，900 枚硬币。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">playerOne <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PlayerOne has left the game&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;PlayerOne has left the game&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The bank now has <span class="subst">\(Bank.coinsInBank)</span> coins&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The bank now has 10000 coins&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在玩家退出游戏，我们可以看到银行回收了这笔资金，余量又恢复到了 1 万枚硬币。</p>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>19.<a href="https://github.com/zfanli/notes/blob/master/swift/19.SubscriptsAndInheritance.md">Swift Subscripts and Inheritance</a></p>
<p>21.<a href="https://github.com/zfanli/notes/blob/master/swift/21.OptionalChaining.md">Swift Optional Chaining</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>25.Swift Protocols</title>
    <url>/post/notes/swift/25-Protocols/</url>
    <content><![CDATA[<p>关于协议的篇幅还是很足的。协议在其他语言中能找到对应的机制，比如 Java 中的接口。相应的，一些与之相关的设计模式也很类似，Java 中的面向接口编程，Swift 中也有被戏称为面向协议编程的模式。</p>
<p>一个协议可以由类、结构体、枚举类型来实现。但是类的情况会复杂很多，有时我们可能需要声明一个面向类的协议，而不希望结构体或者枚举类型来实现它，这时可以让协议继承 <code>AnyObject</code> 达到这一目的。而继承类该对象的协议被称作 <code>Class-Only</code> 协议。</p>
<p>声明实现协议的语法和类继承父类的语法是一样的，但是这里有一个复杂度存在。对于结构体和枚举类型来说，它们不存在继承关系，声明自身名称之后接冒号之后全都是协议（如果你声明协议了的话）。但是类可以继承其他的类，所以 Swift 约定，父类要写在最前面，声明完父类之后才是协议。</p>
<p>协议可以对属性、方法甚至初始化器进行声明要求。而所有声明实现该协议的类型都要对该协议中所有声明对要求进行满足，否则将会在编译时报错。</p>
<span id="more"></span>

<p>在协议中声明对属性和方法的要求时，就如前文提到过的，有实例属性/方法和类型属性/方法的区分。实例属性/方法是实例自身的属性/操作实例的方法，而类型属性/方法则是一个类型持有的属性/方法，这点和 Java 的静态属性和静态工具方法一致。操作上最大的区别在于，访问/调用实例属性/方法时是对实例进行操作，而访问/调用类型属性/方法时则是对类型进行操作。这反映到协议声明时，对于类型属性/方法要使用 <code>static</code> 修饰符标注。前文也提到对于类的场合，可能会使用 <code>static</code> 关键字或者 <code>class</code> 关键字修饰类型属性/方法，区别在于后者可以允许子类对父类的类型属性/方法进行 <code>override</code> 操作，但是在协议声明时始终使用 <code>static</code> 关键字表示一个类型属性/方法。</p>
<p>在声明方法时还有一个特殊之处，在声明指定一个方法会对实例自身进行修改时，需要对方法使用 <code>mutating</code> 修饰符。前文说明过，对于结构体和枚举类型来说，我们可以定义一个方法对其自身的属性进行修改，不过这些方法需要标注 <code>mutating</code> 修饰符声明允许修改操作，这里也是类似的。不过由于 <code>mutating</code> 修饰符是结构体和枚举类型专用的修饰符，当由类实现该协议的时候是不需要写 <code>mutating</code> 修饰符的。</p>
<p>协议中另外一个特殊的声明要求是初始化器。其特殊之处在于如果是由类来实现一个初始化器的要求，则必须给其标注 <code>required</code> 修饰符。这个修饰符的作用在于保证给初始化器要求提供一个显式实现或者继承实现，这样其所有子类都将实现该协议。因此，如果你的类是 final 的，你就可以不必写 <code>required</code> 修饰符，因为它不允许有子类。</p>
<p>协议本身属于一种类型，你可以在任何使用类型的地方使用协议，比如声明一个协议类型参数，那么所有实现该协议的类型都可以满足参数类型的需求。用协议做类型时，表示要求实现了该协议的任意类型。</p>
<p>委派模式是一个和协议相关的设计模式。其核心思想在于，拆分一个类或者结构体，将部分职责通过封装成协议的形式委派出去，简化主体的逻辑。这样的好处在于类或者结构体主体更倾向于一个流程控制，具体实现部分通过声明协议委派出去，本体只需要知道调用什么操作得到什么结果就够了，具体如何实现，由实现了委派协议的类型负责。这里提到一个弱引用的话题，由于篇幅限制本文没有展开，可以在后续研究一下。</p>
<p>此外，使用扩展机制可以给协议添加默认的实现。如果一个类型以及满足了一个协议的所有要求，这个类型只是没有声明实现这个协议，此时要声明这个类型实现了该协议，只需要用一个空的扩展进行协议实现的声明即可。</p>
<p>最后，还谈到了协议中声明可选要求，检查协议一致性等操作，详细还是往后细看，或者看看官方文档。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>协议相当于一张蓝图，在其中可以声明方法、属性以及其他用来完成特殊任务的要求或是功能。协议可以被类、结构体和枚举类型实现。任何一个类型只要满足了一个协议中所有声明的要求，则可以称之为符合该协议。</p>
<blockquote>
<p>R：说“实现了该协议”或许更符合我们的语言习惯。</p>
</blockquote>
<p>你可以使用扩展机制对协议的部分声明要求提供实现，或者提供额外的功能让实现该协议的类型可以利用。</p>
<h3 id="协议语法"><a href="#协议语法" class="headerlink" title="协议语法"></a>协议语法</h3><p>使用下面的语法定义一个协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// protocol definition goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体、枚举类型、类实现协议通过列举协议在类名之后，通过冒号隔开。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span>: <span class="title">FirstProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// structure definition goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要继承父类，将父类名写在所有协议的前面，用逗号隔开。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>: <span class="title">SomeSuperclass</span>, <span class="title">FirstProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class definition goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性要求"><a href="#属性要求" class="headerlink" title="属性要求"></a>属性要求</h3><p>协议可以声明属性要求，指定要求的属性名称和类型，但是协议对要求属性可以限定的信息仅限于此，协议不能指定这个属性是否是一个计算属性。但是协议可以指定属性是否是可读取（gettable）或者可读写（gettable and settable）。</p>
<p>如果协议声明一个属性要求其是可读写的（gettable and settable），那么一个常量属性或是一个只读的计算属性是无法满足要求的。如果协议仅要求一个属性是可读取的（gettable），那么任何类型的属性都可以满足需求，你还可以根据需求决定这个属性是否可写入（settable）。</p>
<p>协议中定义要求的属性必须要用 <code>var</code> 关键字。指定其是否可读写使用 <code>&#123; get set &#125;</code> 的方式。例子如下。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mustBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> doesNotNeedToBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在协议中定义静态类型属性要求时必须要加上 <code>static</code> 关键字前缀。即使当一个类在实现这个协议时可能会给属性添加上 <code>class</code> 或者 <code>static</code> 关键字前缀，在协议中也要用 <code>static</code> 关键字声明。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AnotherProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> someTypeProperty: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：实例属性和类型属性是两种作用域不同的属性。前者每个实例独立且互不影响，后者每个实例通用。类似与 Java 的类的静态属性。</p>
</blockquote>
<p>下面是一个例子，展示了一个协议只要求一个实例属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">FullyNamed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个结构体实现了这个协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">FullyNamed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> john <span class="operator">=</span> <span class="type">Person</span>(fullName: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line"><span class="comment">// john.fullName is &quot;John Appleseed&quot;</span></span><br></pre></td></tr></table></figure>

<p>一个类也实现了这个协议，这个实现更复杂一点。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Starship</span>: <span class="title">FullyNamed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">prefix</span>: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">prefix</span>: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.prefix <span class="operator">=</span> <span class="keyword">prefix</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">prefix</span> <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">?</span> <span class="keyword">prefix</span><span class="operator">!</span> <span class="operator">+</span> <span class="string">&quot; &quot;</span> : <span class="string">&quot;&quot;</span>) <span class="operator">+</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ncc1701 <span class="operator">=</span> <span class="type">Starship</span>(name: <span class="string">&quot;Enterprise&quot;</span>, prefix: <span class="string">&quot;USS&quot;</span>)</span><br><span class="line"><span class="comment">// ncc1701.fullName is &quot;USS Enterprise&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="方法要求"><a href="#方法要求" class="headerlink" title="方法要求"></a>方法要求</h3><p>协议也可以声明实例方法要求或者类型方法要求。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">someTypeMethod</span>()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个协议要求实现一个方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RandomNumberGenerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">random</span>()</span> -&gt; <span class="type">Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面一个类实现了它。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearCongruentialGenerator</span>: <span class="title">RandomNumberGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lastRandom <span class="operator">=</span> <span class="number">42.0</span></span><br><span class="line">    <span class="keyword">let</span> m <span class="operator">=</span> <span class="number">139968.0</span></span><br><span class="line">    <span class="keyword">let</span> a <span class="operator">=</span> <span class="number">3877.0</span></span><br><span class="line">    <span class="keyword">let</span> c <span class="operator">=</span> <span class="number">29573.0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">random</span>()</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        lastRandom <span class="operator">=</span> ((lastRandom <span class="operator">*</span> a <span class="operator">+</span> c).truncatingRemainder(dividingBy:m))</span><br><span class="line">        <span class="keyword">return</span> lastRandom <span class="operator">/</span> m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator <span class="operator">=</span> <span class="type">LinearCongruentialGenerator</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here&#x27;s a random number: <span class="subst">\(generator.random())</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Here&#x27;s a random number: 0.3746499199817101&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;And another one: <span class="subst">\(generator.random())</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;And another one: 0.729023776863283&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Mutating-方法要求"><a href="#Mutating-方法要求" class="headerlink" title="Mutating 方法要求"></a>Mutating 方法要求</h3><p>在协议中声明一个对自身实例进行修改的方法需要关键字 <code>mutating</code>。结构体和枚举类型实现这个方法时也需要这个关键字，但是类的方法不需要 <code>mutating</code> 关键字。</p>
<p>下面定义类一个 Togglable 协议，有一个 <code>toggle()</code> 方法，就如其名，要求触发一个状态对转换。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Togglable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">toggle</span>()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面对枚举类型对其进行类实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OnOffSwitch</span>: <span class="title">Togglable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> off, on</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">toggle</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .off:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .on</span><br><span class="line">        <span class="keyword">case</span> .on:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lightSwitch <span class="operator">=</span> <span class="type">OnOffSwitch</span>.off</span><br><span class="line">lightSwitch.toggle()</span><br><span class="line"><span class="comment">// lightSwitch is now equal to .on</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化器要求"><a href="#初始化器要求" class="headerlink" title="初始化器要求"></a>初始化器要求</h3><p>下面的例子声明要求一个初始化器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">someParameter</span>: <span class="type">Int</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同于结构体和枚举类型，类存在继承关系，所以在满足协议中的初始化器要求时存在特殊之处，即需要 <code>required</code> 修饰符。除此之外你可以决定将要求的初始化器定义为指定初始化器或者是便利初始化器，取决于你的需求。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>: <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="function"><span class="keyword">init</span>(<span class="params">someParameter</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// initializer implementation goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>required</code> 修饰符的作用在于保证你提供一个显式的，或者继承的初始化器实现，使得其子类默认是实现类该协议的。</p>
<blockquote>
<p>R；文档提示当一个类是 final 时你不需要 <code>required</code> 修饰符。因为它没有子类。</p>
</blockquote>
<p>如果父类有同名的指定初始化器，并且子类要覆盖这个特殊的初始化器，则需要 <code>required</code> 和 <code>override</code> 两个关键字。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSuperClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// initializer implementation goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubClass</span>: <span class="title">SomeSuperClass</span>, <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &quot;required&quot; from SomeProtocol conformance; &quot;override&quot; from SomeSuperClass</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">override</span> <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// initializer implementation goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协议作为类型"><a href="#协议作为类型" class="headerlink" title="协议作为类型"></a>协议作为类型</h3><p>即使协议本身不实现任何功能，但是它还可以作为一个类型使用。使用协议作为类型时常被称为存在类型（existential type），所有实现了这个协议的类型都是符合条件的类型。</p>
<p>你可以像使用类型一样使用协议，包括：</p>
<ul>
<li>作为一个函数、方法、初始化器的参数类型或返回值类型；</li>
<li>作为常量、变量或者属性的类型；</li>
<li>作为数组、字典或者其他容器的类型。</li>
</ul>
<p>下面是一个例子。Dice 类代表一个多面骰子，它有两个属性，一个是面数 sides，一个是随机数生成器 generator。generator 使用上文的随机数生成器的协议作为类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sides: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> generator: <span class="type">RandomNumberGenerator</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">sides</span>: <span class="type">Int</span>, <span class="params">generator</span>: <span class="type">RandomNumberGenerator</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.sides <span class="operator">=</span> sides</span><br><span class="line">        <span class="keyword">self</span>.generator <span class="operator">=</span> generator</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">roll</span>()</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>(generator.random() <span class="operator">*</span> <span class="type">Double</span>(sides)) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d6 <span class="operator">=</span> <span class="type">Dice</span>(sides: <span class="number">6</span>, generator: <span class="type">LinearCongruentialGenerator</span>())</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Random dice roll is <span class="subst">\(d6.roll())</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Random dice roll is 3</span></span><br><span class="line"><span class="comment">// Random dice roll is 5</span></span><br><span class="line"><span class="comment">// Random dice roll is 4</span></span><br><span class="line"><span class="comment">// Random dice roll is 5</span></span><br><span class="line"><span class="comment">// Random dice roll is 4</span></span><br></pre></td></tr></table></figure>

<h3 id="委派"><a href="#委派" class="headerlink" title="委派"></a>委派</h3><p>委派是一个设计模式。委派模式允许一个类或结构体将自身部分指责委派给另一个类型的实例。要实现委派模式，先定一个协议封装需要委派出去的指责，而实现了这个协议的类型保证提供委派所需的功能性。委派可以用来相应特定的动作，或者从外部资源中恢复数据而不需要知道这个资源的基本类型。</p>
<p>下面的例子定义了两个协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DiceGame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dice: <span class="type">Dice</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">play</span>()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DiceGameDelegate</span>: <span class="title">AnyObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">gameDidStart</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">game</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>, <span class="params">didStartNewTurnWithDiceRoll</span> <span class="params">diceRoll</span>: <span class="type">Int</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">gameDidEnd</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DiceGame 协议可以由任何使用骰子的游戏实现。</p>
<p>DiceGameDelegate 协议可以实现追踪一个 DiceGame 的进度。为了避免强引用循环，委派被声明为弱引用。DiceGameDelegate 继承 AnyObject，这一操作让其只能被类实现，这样的协议称为 Class-Only Protocols。</p>
<blockquote>
<p>R：关于强类型引用循环参考资料：<a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID51">https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID51</a></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnakesAndLadders</span>: <span class="title">DiceGame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> finalSquare <span class="operator">=</span> <span class="number">25</span></span><br><span class="line">    <span class="keyword">let</span> dice <span class="operator">=</span> <span class="type">Dice</span>(sides: <span class="number">6</span>, generator: <span class="type">LinearCongruentialGenerator</span>())</span><br><span class="line">    <span class="keyword">var</span> square <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> board: [<span class="type">Int</span>]</span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        board <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">0</span>, count: finalSquare <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">        board[<span class="number">03</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">08</span>; board[<span class="number">06</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">11</span>; board[<span class="number">09</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">09</span>; board[<span class="number">10</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">02</span></span><br><span class="line">        board[<span class="number">14</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">10</span>; board[<span class="number">19</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">11</span>; board[<span class="number">22</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">02</span>; board[<span class="number">24</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">08</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">DiceGameDelegate</span>?</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">play</span>()</span> &#123;</span><br><span class="line">        square <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        delegate<span class="operator">?</span>.gameDidStart(<span class="keyword">self</span>)</span><br><span class="line">        gameLoop: <span class="keyword">while</span> square <span class="operator">!=</span> finalSquare &#123;</span><br><span class="line">            <span class="keyword">let</span> diceRoll <span class="operator">=</span> dice.roll()</span><br><span class="line">            delegate<span class="operator">?</span>.game(<span class="keyword">self</span>, didStartNewTurnWithDiceRoll: diceRoll)</span><br><span class="line">            <span class="keyword">switch</span> square <span class="operator">+</span> diceRoll &#123;</span><br><span class="line">            <span class="keyword">case</span> finalSquare:</span><br><span class="line">                <span class="keyword">break</span> gameLoop</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> newSquare <span class="keyword">where</span> newSquare <span class="operator">&gt;</span> finalSquare:</span><br><span class="line">                <span class="keyword">continue</span> gameLoop</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                square <span class="operator">+=</span> diceRoll</span><br><span class="line">                square <span class="operator">+=</span> board[square]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        delegate<span class="operator">?</span>.gameDidEnd(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SnakesAndLadders 类初始化时创建了一个棋盘，并定义了一些数值在其中。游戏执行时，骰子生成随机数，然后 square 属性添加随机数，并加上棋盘上相应位置的数值，最终结果超过 finialSquare 则游戏结束。</p>
<p>下面是骰子游戏委派的实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiceGameTracker</span>: <span class="title">DiceGameDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfTurns <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">gameDidStart</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>)</span> &#123;</span><br><span class="line">        numberOfTurns <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> game <span class="keyword">is</span> <span class="type">SnakesAndLadders</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Started a new game of Snakes and Ladders&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The game is using a <span class="subst">\(game.dice.sides)</span>-sided dice&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">game</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>, <span class="params">didStartNewTurnWithDiceRoll</span> <span class="params">diceRoll</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        numberOfTurns <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Rolled a <span class="subst">\(diceRoll)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">gameDidEnd</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The game lasted for <span class="subst">\(numberOfTurns)</span> turns&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上它们是这样组合的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tracker <span class="operator">=</span> <span class="type">DiceGameTracker</span>()</span><br><span class="line"><span class="keyword">let</span> game <span class="operator">=</span> <span class="type">SnakesAndLadders</span>()</span><br><span class="line">game.delegate <span class="operator">=</span> tracker</span><br><span class="line">game.play()</span><br><span class="line"><span class="comment">// Started a new game of Snakes and Ladders</span></span><br><span class="line"><span class="comment">// The game is using a 6-sided dice</span></span><br><span class="line"><span class="comment">// Rolled a 3</span></span><br><span class="line"><span class="comment">// Rolled a 5</span></span><br><span class="line"><span class="comment">// Rolled a 4</span></span><br><span class="line"><span class="comment">// Rolled a 5</span></span><br><span class="line"><span class="comment">// The game lasted for 4 turns</span></span><br></pre></td></tr></table></figure>

<h3 id="用扩展添加新的协议"><a href="#用扩展添加新的协议" class="headerlink" title="用扩展添加新的协议"></a>用扩展添加新的协议</h3><p>你可以使用扩展语法给现有的类型实现新的协议，甚至你不需要访问现有类型的源代码。关于扩展可以参考上一节。</p>
<blockquote>
<p>R：文档提示当存在现有实例时，将自动获得扩展后的内容。听上去很酷炫的热扩展。</p>
</blockquote>
<p>例如下面的协议定义了一个属性用文本表述自身。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展 Dice 类让其实现这个协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dice</span>: <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A <span class="subst">\(sides)</span>-sided dice&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 Dice 的实例都实现了 TextRepresentable 协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> d12 <span class="operator">=</span> <span class="type">Dice</span>(sides: <span class="number">12</span>, generator: <span class="type">LinearCongruentialGenerator</span>())</span><br><span class="line"><span class="built_in">print</span>(d12.textualDescription)</span><br><span class="line"><span class="comment">// Prints &quot;A 12-sided dice&quot;</span></span><br></pre></td></tr></table></figure>

<p>类似的，SnakesAndLadders 类也可以实现这个协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SnakesAndLadders</span>: <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A game of Snakes and Ladders with <span class="subst">\(finalSquare)</span> squares&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(game.textualDescription)</span><br><span class="line"><span class="comment">// Prints &quot;A game of Snakes and Ladders with 25 squares&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="按条件实现协议"><a href="#按条件实现协议" class="headerlink" title="按条件实现协议"></a>按条件实现协议</h3><p>泛型类型可能仅在某些条件下满足协议的要求，例如当类型的通用参数符合协议时。你可以在扩展一个类型的时候列出制约，可以使泛型有条件地实现某个协议。通过泛型 where 小句将制约写在协议名称之后。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">TextRepresentable</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> itemsAsText <span class="operator">=</span> <span class="keyword">self</span>.map &#123; <span class="variable">$0</span>.textualDescription &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> <span class="operator">+</span> itemsAsText.joined(separator: <span class="string">&quot;, &quot;</span>) <span class="operator">+</span> <span class="string">&quot;]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myDice <span class="operator">=</span> [d6, d12]</span><br><span class="line"><span class="built_in">print</span>(myDice.textualDescription)</span><br><span class="line"><span class="comment">// Prints &quot;[A 6-sided dice, A 12-sided dice]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="用扩展声明协议实现"><a href="#用扩展声明协议实现" class="headerlink" title="用扩展声明协议实现"></a>用扩展声明协议实现</h3><p>如果一个类型已经满足了一个协议的要求，但是其没有实现这个协议，可以使用一个空的扩展来声明这个类型实现了这个协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hamster</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A hamster named <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Hamster</span>: <span class="title">TextRepresentable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> simonTheHamster <span class="operator">=</span> <span class="type">Hamster</span>(name: <span class="string">&quot;Simon&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> somethingTextRepresentable: <span class="type">TextRepresentable</span> <span class="operator">=</span> simonTheHamster</span><br><span class="line"><span class="built_in">print</span>(somethingTextRepresentable.textualDescription)</span><br><span class="line"><span class="comment">// Prints &quot;A hamster named Simon&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="协议类型集合"><a href="#协议类型集合" class="headerlink" title="协议类型集合"></a>协议类型集合</h3><p>协议可以作为集合的类型，比如数组和字典类型。下面是一个例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> things: [<span class="type">TextRepresentable</span>] <span class="operator">=</span> [game, d12, simonTheHamster]</span><br></pre></td></tr></table></figure>

<p>可以遍历数组打印文字描述。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> things &#123;</span><br><span class="line">    <span class="built_in">print</span>(thing.textualDescription)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A game of Snakes and Ladders with 25 squares</span></span><br><span class="line"><span class="comment">// A 12-sided dice</span></span><br><span class="line"><span class="comment">// A hamster named Simon</span></span><br></pre></td></tr></table></figure>

<h3 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h3><p>协议可以继承。下面是继承语法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">InheritingProtocol</span>: <span class="title">SomeProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// protocol definition goes here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PrettyTextRepresentable</span>: <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子定义了一个新的协议 PrettyTextRepresentable 继承与 TextRepresentable。</p>
<p>下面是一个实现。用扩展的方式让 SnakesAndLadders 实现该协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SnakesAndLadders</span>: <span class="title">PrettyTextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output <span class="operator">=</span> textualDescription <span class="operator">+</span> <span class="string">&quot;:<span class="subst">\n</span>&quot;</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span>finalSquare &#123;</span><br><span class="line">            <span class="keyword">switch</span> board[index] &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> ladder <span class="keyword">where</span> ladder <span class="operator">&gt;</span> <span class="number">0</span>:</span><br><span class="line">                output <span class="operator">+=</span> <span class="string">&quot;▲ &quot;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> snake <span class="keyword">where</span> snake <span class="operator">&lt;</span> <span class="number">0</span>:</span><br><span class="line">                output <span class="operator">+=</span> <span class="string">&quot;▼ &quot;</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                output <span class="operator">+=</span> <span class="string">&quot;○ &quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(game.prettyTextualDescription)</span><br><span class="line"><span class="comment">// A game of Snakes and Ladders with 25 squares:</span></span><br><span class="line"><span class="comment">// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</span></span><br></pre></td></tr></table></figure>

<h3 id="Class-Only-协议"><a href="#Class-Only-协议" class="headerlink" title="Class-Only 协议"></a>Class-Only 协议</h3><p>你可以让协议继承 <code>AnyObject</code> 限制只有类可以实现这个协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeClassOnlyProtocol</span>: <span class="title">AnyObject</span>, <span class="title">SomeInheritedProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class-only protocol definition goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了类以外，结构体或枚举类型实现这个协议时会报出编译错误。</p>
<h3 id="协议组合"><a href="#协议组合" class="headerlink" title="协议组合"></a>协议组合</h3><p>有时要求一个类型同时实现两个协议是很有用的。你可以使用协议组合让多个协议变成一个单独的要求。协议组合不会定义新的协议，它就是一个临时本地协议一样把组合中的所有协议的要求都联合到一起。</p>
<p>协议组合的格式是 <code>SomeProtocol &amp; AnotherProtocol</code>。可以列举多个协议并用(&amp;)将他们链接。除了它列出来的一串协议，一个协议组合还允许包含一个类，用来指定一个要求的父类。</p>
<p>下面是一个例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Named</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Aged</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">Named</span>, <span class="title">Aged</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wishHappyBirthday</span>(<span class="params">to</span> <span class="params">celebrator</span>: <span class="type">Named</span> &amp; <span class="type">Aged</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Happy birthday, <span class="subst">\(celebrator.name)</span>, you&#x27;re <span class="subst">\(celebrator.age)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> birthdayPerson <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Malcolm&quot;</span>, age: <span class="number">21</span>)</span><br><span class="line">wishHappyBirthday(to: birthdayPerson)</span><br><span class="line"><span class="comment">// Prints &quot;Happy birthday, Malcolm, you&#x27;re 21!&quot;</span></span><br></pre></td></tr></table></figure>

<p>下面是包含一个类名的例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> latitude: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> longitude: <span class="type">Double</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">latitude</span>: <span class="type">Double</span>, <span class="params">longitude</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.latitude <span class="operator">=</span> latitude</span><br><span class="line">        <span class="keyword">self</span>.longitude <span class="operator">=</span> longitude</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span>: <span class="title">Location</span>, <span class="title">Named</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">latitude</span>: <span class="type">Double</span>, <span class="params">longitude</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(latitude: latitude, longitude: longitude)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">beginConcert</span>(<span class="params">in</span> <span class="params">location</span>: <span class="type">Location</span> &amp; <span class="type">Named</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(location.name)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> seattle <span class="operator">=</span> <span class="type">City</span>(name: <span class="string">&quot;Seattle&quot;</span>, latitude: <span class="number">47.6</span>, longitude: <span class="operator">-</span><span class="number">122.3</span>)</span><br><span class="line">beginConcert(in: seattle)</span><br><span class="line"><span class="comment">// Prints &quot;Hello, Seattle!&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="检查协议的一致性"><a href="#检查协议的一致性" class="headerlink" title="检查协议的一致性"></a>检查协议的一致性</h3><p>你可以使用 <code>is</code> 和 <code>as</code> 操作符检查协议实现的一致性和转换到指定协议。语法相同。</p>
<p>下面定义一个例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HasArea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义两个类实现这个协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>: <span class="title">HasArea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pi <span class="operator">=</span> <span class="number">3.1415927</span></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">return</span> pi <span class="operator">*</span> radius <span class="operator">*</span> radius &#125;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">radius</span>: <span class="type">Double</span>)</span> &#123; <span class="keyword">self</span>.radius <span class="operator">=</span> radius &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span>: <span class="title">HasArea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">area</span>: <span class="type">Double</span>)</span> &#123; <span class="keyword">self</span>.area <span class="operator">=</span> area &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个类不实现这个协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> legs: <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">legs</span>: <span class="type">Int</span>)</span> &#123; <span class="keyword">self</span>.legs <span class="operator">=</span> legs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把它们装到一起。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> objects: [<span class="type">AnyObject</span>] <span class="operator">=</span> [</span><br><span class="line">    <span class="type">Circle</span>(radius: <span class="number">2.0</span>),</span><br><span class="line">    <span class="type">Country</span>(area: <span class="number">243_610</span>),</span><br><span class="line">    <span class="type">Animal</span>(legs: <span class="number">4</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>下面是一个检查类型的例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> object <span class="keyword">in</span> objects &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> objectWithArea <span class="operator">=</span> object <span class="keyword">as?</span> <span class="type">HasArea</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Area is <span class="subst">\(objectWithArea.area)</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something that doesn&#x27;t have an area&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Area is 12.5663708</span></span><br><span class="line"><span class="comment">// Area is 243610.0</span></span><br><span class="line"><span class="comment">// Something that doesn&#x27;t have an area</span></span><br></pre></td></tr></table></figure>

<h3 id="可选的协议要求"><a href="#可选的协议要求" class="headerlink" title="可选的协议要求"></a>可选的协议要求</h3><p>你可以给协议定义可选的要求。实现这个协议的类型不需要一定实现这个要求。通过 <code>optional</code> 修饰符来定义一个可选要求。</p>
<p>可选要求有效，你可以写代码与 Objective-C 交互操作。协议和可选要求都需要用 @objc 标注。标注了 @objc 的协议只能被继承自 Objective-C 的类或其他 @objc 类实现。无法由结构体和枚举类型实现。</p>
<p>当你使用可选要求的方法或者属性时，它的类型自动变为可选，而且是整个函数类型变成可选而非其返回值。例如一个方法 (Int) -&gt; String 将变成 ((Int) -&gt; String)?。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">CounterDataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">increment</span>(<span class="params">forCount</span> <span class="params">count</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">optional</span> <span class="keyword">var</span> fixedIncrement: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> dataSource: <span class="type">CounterDataSource</span>?</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">increment</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> amount <span class="operator">=</span> dataSource<span class="operator">?</span>.increment<span class="operator">?</span>(forCount: count) &#123;</span><br><span class="line">            count <span class="operator">+=</span> amount</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> amount <span class="operator">=</span> dataSource<span class="operator">?</span>.fixedIncrement &#123;</span><br><span class="line">            count <span class="operator">+=</span> amount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面几个示例。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeSource</span>: <span class="title">NSObject</span>, <span class="title">CounterDataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fixedIncrement <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter <span class="operator">=</span> <span class="type">Counter</span>()</span><br><span class="line">counter.dataSource <span class="operator">=</span> <span class="type">ThreeSource</span>()</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">4</span> &#123;</span><br><span class="line">    counter.increment()</span><br><span class="line">    <span class="built_in">print</span>(counter.count)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TowardsZeroSource</span>: <span class="title">NSObject</span>, <span class="title">CounterDataSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">increment</span>(<span class="params">forCount</span> <span class="params">count</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> count <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">counter.count <span class="operator">=</span> <span class="operator">-</span><span class="number">4</span></span><br><span class="line">counter.dataSource <span class="operator">=</span> <span class="type">TowardsZeroSource</span>()</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">    counter.increment()</span><br><span class="line">    <span class="built_in">print</span>(counter.count)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -3</span></span><br><span class="line"><span class="comment">// -2</span></span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h3><p>协议可以直接被扩展。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RandomNumberGenerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">randomBool</span>()</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random() <span class="operator">&gt;</span> <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generator <span class="operator">=</span> <span class="type">LinearCongruentialGenerator</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here&#x27;s a random number: <span class="subst">\(generator.random())</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Here&#x27;s a random number: 0.3746499199817101&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;And here&#x27;s a random Boolean: <span class="subst">\(generator.randomBool())</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;And here&#x27;s a random Boolean: true&quot;</span></span><br></pre></td></tr></table></figure>

<p>协议扩展可以用来提供一个默认的实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PrettyTextRepresentable</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> textualDescription</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>协议扩展也可以用来添加约束。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">allEqual</span>()</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> element <span class="operator">!=</span> <span class="keyword">self</span>.first &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> equalNumbers <span class="operator">=</span> [<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>]</span><br><span class="line"><span class="keyword">let</span> differentNumbers <span class="operator">=</span> [<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(equalNumbers.allEqual())</span><br><span class="line"><span class="comment">// Prints &quot;true&quot;</span></span><br><span class="line"><span class="built_in">print</span>(differentNumbers.allEqual())</span><br><span class="line"><span class="comment">// Prints &quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>24.<a href="https://github.com/zfanli/notes/blob/master/swift/24.Extensions.md">Swift Extensions</a></p>
<p>26.<a href="https://github.com/zfanli/notes/blob/master/swift/26.Generics.md">Swift Generics</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>26.Swift Generics</title>
    <url>/post/notes/swift/26-Generics/</url>
    <content><![CDATA[<p>看完这篇主题只觉得：</p>
<ul>
<li>泛型可以为所欲为；</li>
<li>where 语句可以为所欲为。</li>
</ul>
<p>开个玩笑。</p>
<p>泛型是这门语言的核心内容之一。它可以减少重复代码，拓宽相同逻辑能处理的类型。总结一下其基本思想就是，只要你满足我预期的要求，我就能帮你完成你预期的任务。</p>
<span id="more"></span>

<p>泛型最简单的应用就是直接在函数或类型上使用，这样的泛型函数或泛型类型的优势是对能处理的参数类型不设限制或者用类型限制语法设定一定的限制，但是和传统函数和类型相比，泛型函数和类型最大程度利用了相同逻辑，你不必因为类型不同而将相同逻辑复制一遍又一遍。</p>
<p>泛型的进阶用法是泛型协议。泛型协议更为灵活，在协议中使用 <code>associatedtype</code> 关键字定义一个关联类型的名称，然后对这个类型进行操作。灵活之处在于协议不去限定这个关联类型实际上是哪种类型，而实现这个协议对时候，你还可以选择直接指定关联类型是某个类型，或者仍然定义其为泛型类型，在被调用时才最终决定这个关联类型的实际类型。</p>
<p>泛型的话题大概就是这些。此外为了配合泛型的使用，where 语句提供了泛型的另外一部分强大能力。where 语句几乎能用于任何定义类型的地方，对声明类型进行一些限制，甚至配合扩展机制可以更灵活的根据条件对类型进行扩展。</p>
<p>相信用好泛型可以使代码质量上升不止一个层次。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型代码可以根据你所定义的需求让你写出更具有灵活性的、可复用的函数和类型，这些函数和类型可以和任何类型一起工作。能使你避免重复代码，并用更清晰和抽象的方式表达意图。</p>
<p>泛型是 Swift 最强大的功能之一，多数 Swift 标准库就是基于泛型建立的。实际上虽然你可能没有察觉到，在这片指南中你已经在使用泛型了。比如说 Swift 的数组和字典类型就是泛型集合。你可以创建整型数组，或者字符串数组，或者其他任何类型的数组。字典类型也是相同的，你可以创建储存任何指定类型的字典类型，实际上对字典类型能储存哪些类型是没有限制的。</p>
<h3 id="泛型解决的问题"><a href="#泛型解决的问题" class="headerlink" title="泛型解决的问题"></a>泛型解决的问题</h3><p>下面是一个标注的非泛型函数，包装了两个整型参数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数使用 <code>inout</code> 参数。它的功能是给参数 <code>a</code> 和 <code>b</code> 的值对调。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt <span class="operator">=</span> <span class="number">107</span></span><br><span class="line">swapTwoInts(<span class="operator">&amp;</span>someInt, <span class="operator">&amp;</span>anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;someInt is now 107, and anotherInt is now 3&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>swapTwoInts(_:_:)</code> 函数很有用，但却只能处理整型数据，如果你需要对调字符串，对调浮点数，你还得写更多的函数，比如下面的这些。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoStrings</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">String</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">String</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoDoubles</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Double</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Double</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能注意到了，这三个函数是完全一致的。唯一的区别在于它们能接受的参数类型。</p>
<p>如果能有一个函数可以对调任何类型的两个值将是非常有用的。泛型代码可以让你写出这个函数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoValues</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">T</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">T</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看出区别来了吗？没有？没关系我们将这个函数的第一行和上面的函数放在一起对比一下。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoValues</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">T</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">T</span>)</span></span><br></pre></td></tr></table></figure>

<p>没错，定义泛型的方法就是那个尖括号和里面的 T。T 在这里是 Types 的意思，它作为一个占位符在这里取代实际的类型名称。这个占位符不去声明类型 T 必须是什么类型，但在这里它说明了参数 <code>a</code> 和 <code>b</code> 必须是相同类型。具体 T 到底是什么类型是在每次调用这个函数时决定的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt <span class="operator">=</span> <span class="number">107</span></span><br><span class="line">swapTwoValues(<span class="operator">&amp;</span>someInt, <span class="operator">&amp;</span>anotherInt)</span><br><span class="line"><span class="comment">// someInt is now 107, and anotherInt is now 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someString <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> anotherString <span class="operator">=</span> <span class="string">&quot;world&quot;</span></span><br><span class="line">swapTwoValues(<span class="operator">&amp;</span>someString, <span class="operator">&amp;</span>anotherString)</span><br><span class="line"><span class="comment">// someString is now &quot;world&quot;, and anotherString is now &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：文档提示，Swift 标准库中存在一个函数 <code>swap(_:_:)</code> 提供上面例子中的函数功能，如果你真的需要，不需要自己去实现一个。</p>
</blockquote>
<h3 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h3><p>在上面的例子中，类型参数 T 就是一个很好的例子。类型参数指定并命名一个占位符类型，以 <code>&lt;T&gt;</code> 的形式写在函数名的后面。你只要指定了一个占位符类型，你就可以在参数上指定该类型，或者声明返回值类型，甚至在函数体中，你也可以用它标注类型。无论哪种场合，占位符类型 T 最终会在函数被调用时被确定。</p>
<p>你可以指定多个占位符类型，使用逗号隔开。</p>
<h3 id="命名类型参数"><a href="#命名类型参数" class="headerlink" title="命名类型参数"></a>命名类型参数</h3><p>大多数场合，泛型参数的名称是描述性的，比如在 <code>Dictionary&lt;Key, Value&gt;</code> 中的 <code>Key</code> 和 <code>Value</code>，以及 <code>Array&lt;Element&gt;</code> 中的 <code>Element</code>，这些名称可以告诉读者它与函数之间的关系。不过，当两者之前不存在有意义的关系时，通常的做法是使用 <code>T</code>、<code>U</code> 或 <code>V</code> 等字母来作为类型参数的名称。</p>
<h3 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h3><p>除了泛型函数，你还可以定义泛型类型。泛型类型是指可以处理任何类型的定制化类、结构体和枚举类型，就像字典类型和数组类型一样。</p>
<p>这一节告诉你如何写一个叫做 <code>Stack</code> 的泛型集合类型。一个 stack 是一组有序的值（Ordered set of values），它类似于数组，但在操作集上比 Swift 的数组有更多的限制。在数组中，新的元素可以从任何位置上加入/移除，但是一个 stack 只能将新元素加在末尾，同时只允许元素从末尾移除。</p>
<blockquote>
<p>R：如果你不好理解 <code>Stack</code> 对元素添加和删除的限制用意，请尝试思考以下网页上的面包屑导航元素，新的页面导航会加在后面，而返回前一个页面实际上就是删除最后一个页面元素，类似一个递归的流程。</p>
</blockquote>
<p>下面看一个图解来理解一下 <code>Stack</code> 的添加和移除行为。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ↓   ↑</span><br><span class="line">  □ ■ □</span><br><span class="line">■ ■ ■ ■ ■</span><br><span class="line">■ ■ ■ ■ ■</span><br><span class="line">■ ■ ■ ■ ■</span><br></pre></td></tr></table></figure>

<ol>
<li>当前三个值；</li>
<li>第四个值放在顶部；</li>
<li>现在四个值，最近的值在最上面；</li>
<li>最上面的值移除；</li>
<li>当前又变成三个值。</li>
</ol>
<p>下面是非泛型版本的实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span>()</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IntStack</code> 实现了对整型数据的先进先出功能。但是它只能处理整数，下面是泛型版本。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items <span class="operator">=</span> [<span class="type">Element</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>)</span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span>()</span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们基本都是一致是，但是一旦加上泛型之后，它的功能就被拓宽了。你现在可以创建任何类型的 <code>Stack</code> 了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stackOfStrings <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;uno&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;dos&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;tres&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;cuatro&quot;</span>)</span><br><span class="line"><span class="comment">// the stack now contains 4 strings</span></span><br></pre></td></tr></table></figure>

<p>移除一个值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fromTheTop <span class="operator">=</span> stackOfStrings.pop()</span><br><span class="line"><span class="comment">// fromTheTop is equal to &quot;cuatro&quot;, and the stack now contains 3 strings</span></span><br></pre></td></tr></table></figure>

<h3 id="扩展一个泛型类型"><a href="#扩展一个泛型类型" class="headerlink" title="扩展一个泛型类型"></a>扩展一个泛型类型</h3><p>扩展一个泛型类型不需要像定义时那样提供类型参数列表。但是定义过的泛型类型在扩展内部是可以直接使用的。</p>
<p>下面的例子扩展了 <code>Stack</code> 给其添加了一个只读属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> topItem: <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> items.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : items[items.count <span class="operator">-</span> <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看怎么访问这个属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> topItem <span class="operator">=</span> stackOfStrings.topItem &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The top item on the stack is <span class="subst">\(topItem)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The top item on the stack is tres.&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="类型限制"><a href="#类型限制" class="headerlink" title="类型限制"></a>类型限制</h3><p>目前为止定义的泛型类型都是可以处理任何类型的。但是有时对泛型类型进行一定的限制是非常有用的。类型限制指定类型参数必须继承自某个类，或者实现某个特殊的协议或是协议组合。</p>
<p>比如 Swift 的字典类型要求 Key 的值必须是可哈希的，也就是说，它必须提供一方式让其变得唯一。字典类型要求 Key 必须是可哈希的，这样它就可以检查一个 Key 是否有对应的值了。如果没有这个限制，那字典类型插值时就不能发现一个 Key 是否已经被赋值，也不能通过一个 Key 去找指定的值了。</p>
<p>Swift 中，<code>Dictionary</code> 的 key 声明了类型限制，强制要求 key 类型必须是实现了标准库中的特殊协议 <code>Hashable</code>。在 Swift 中所有基础类型都是默认实现了这个协议的。</p>
<p>你在声明自己的泛型类型时可以定义你需要的类型限制，这些限制给泛型编程提供了强大的能力。</p>
<p>像 <code>Hashable</code> 之类的抽象概念是用其概念上的特性来表述其类型的，而不是它的实际类型。</p>
<h3 id="类型限制语法"><a href="#类型限制语法" class="headerlink" title="类型限制语法"></a>类型限制语法</h3><p>声明一个泛型的类型限制，在其名称之后加冒号，接预期的类名或者协议名称即可。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>&lt;<span class="type">T</span>: <span class="type">SomeClass</span>, <span class="type">U</span>: <span class="type">SomeProtocol</span>&gt;(<span class="params">someT</span>: <span class="type">T</span>, <span class="params">someU</span>: <span class="type">U</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// function body goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中有两个泛型类型，<code>T</code> 和 <code>U</code>。其中 <code>T</code> 要求是指定类型 <code>SomeClass</code> 的子类，而 <code>U</code> 需要是实现了 <code>SomeProtocol</code> 协议的任何类型。</p>
<h3 id="类型限制实践"><a href="#类型限制实践" class="headerlink" title="类型限制实践"></a>类型限制实践</h3><p>下面的例子中定义了一个非泛型的函数，其功能是接受一个字符串和字符串数组，遍历这个数组然后匹配字符串，在找到相同的元素时返回数组的索引，否则返回 <code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findIndex</span>(<span class="params">ofString</span> <span class="params">valueToFind</span>: <span class="type">String</span>, <span class="params">in</span> <span class="params">array</span>: [<span class="type">String</span>])</span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是它的使用示例。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strings <span class="operator">=</span> [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;llama&quot;</span>, <span class="string">&quot;parakeet&quot;</span>, <span class="string">&quot;terrapin&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> foundIndex <span class="operator">=</span> findIndex(ofString: <span class="string">&quot;llama&quot;</span>, in: strings) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The index of llama is <span class="subst">\(foundIndex)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The index of llama is 2&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个原理不仅对字符串有用，你可以写一个泛型函数来处理任何类型，执行相同的操作。你可能预期下面这个函数来应对所有类型。它的返回值还是 <code>Int?</code> 因为其返回数组的索引，或者 <code>nil</code> 如果数组不存在这个元素。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findIndex</span>&lt;<span class="type">T</span>&gt;(<span class="params">of</span> <span class="params">valueToFind</span>: <span class="type">T</span>, <span class="params">in</span> <span class="params">array</span>:[<span class="type">T</span>])</span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但实际上上面这个函数无法编译，原因在于这一句：<code>if value == valueToFind</code>。Swift 中不是所有类型都可以使用双等号操作符进行比较。假如你自己定义了一个类或者结构体用来表述一个复杂的数据模型，Swift 无法猜测出这个类型的实例直接的”等于“的关系。因为这一点，无法保证所有类型都能让这段代码正常执行，所以在编译时会报出一个适当的错误。</p>
<p>不过还有机会。Swift 标准库定义了一个称作 <code>Equatable</code> 的协议，要求符合该协议的类型实现相等和不等比较操作符（== and !=）。Swift 中所有标准类型都实现了这个协议。</p>
<p>所有符合 <code>Equatable</code> 协议的类型都可以安全的执行上面这个函数，因为可以保证双等号操作是有效的。为了表达这一点，你需要给这个泛型函数添加类型限制。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findIndex</span>&lt;<span class="type">T</span>: <span class="type">Equatable</span>&gt;(<span class="params">of</span> <span class="params">valueToFind</span>: <span class="type">T</span>, <span class="params">in</span> <span class="params">array</span>:[<span class="type">T</span>])</span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这个函数可以和预期一样使用了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> doubleIndex <span class="operator">=</span> findIndex(of: <span class="number">9.3</span>, in: [<span class="number">3.14159</span>, <span class="number">0.1</span>, <span class="number">0.25</span>])</span><br><span class="line"><span class="comment">// doubleIndex is an optional Int with no value, because 9.3 isn&#x27;t in the array</span></span><br><span class="line"><span class="keyword">let</span> stringIndex <span class="operator">=</span> findIndex(of: <span class="string">&quot;Andrea&quot;</span>, in: [<span class="string">&quot;Mike&quot;</span>, <span class="string">&quot;Malcolm&quot;</span>, <span class="string">&quot;Andrea&quot;</span>])</span><br><span class="line"><span class="comment">// stringIndex is an optional Int containing a value of 2</span></span><br></pre></td></tr></table></figure>

<h3 id="关联类型（Associated-Types）"><a href="#关联类型（Associated-Types）" class="headerlink" title="关联类型（Associated Types）"></a>关联类型（Associated Types）</h3><p>在协议中声明关联类型是很有用的操作。协议中的关联类型是指一个类型名称的占位符。在协议中不指定具体类型，由实现这个协议的类型来指定。声明关联类型需要 <code>associatedtype</code> 关键字。</p>
<h3 id="关联类型实践"><a href="#关联类型实践" class="headerlink" title="关联类型实践"></a>关联类型实践</h3><p>看看下面的例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span></span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个协议要求实现它的类型提供三个能力：</p>
<ul>
<li>必须能使用 <code>append(_:)</code> 方法添加新的元素；</li>
<li>必须能提供 <code>count</code> 属性返回一个整数值；</li>
<li>必须能通过下标用整数值索引访问元素。</li>
</ul>
<p>但这个协议不指定所储存的类型，它只定义了一个类型名称的占位符 <code>Item</code>。</p>
<p>下面是一个非泛型版本的实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntStack</span>: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="comment">// original IntStack implementation</span></span><br><span class="line">    <span class="keyword">var</span> items <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span>()</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// conformance to the Container protocol</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Item</span> <span class="operator">=</span> <span class="type">Int</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IntStack</code> 实现了协议的三个要求。而且它还是用了类型别名，将 <code>Int</code> 类型定义别名 <code>Item</code>，将协议中的关联类型转换为了一个具体的类型。当然，Swift 可以自己推测关联类型的实际类型，所以 <code>typealias Item = Int</code> 这一句是可以省略的。</p>
<p>下面是一个泛型版本的实现，它能应对的类型更多。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="comment">// original Stack&lt;Element&gt; implementation</span></span><br><span class="line">    <span class="keyword">var</span> items <span class="operator">=</span> [<span class="type">Element</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>)</span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span>()</span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// conformance to the Container protocol</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift 可以推测出泛型 Element 是关联类型的实际类型，虽然此时依旧没有确定下来，但是在实例化的时候会最终被确定。</p>
<h3 id="扩展现有类型指定关联类型"><a href="#扩展现有类型指定关联类型" class="headerlink" title="扩展现有类型指定关联类型"></a>扩展现有类型指定关联类型</h3><p>你可以使用扩展机制给现有的类型添加某个协议的实现，这包括关联类型。</p>
<p>Swift 的 Array 类型已经满足了 <code>Container</code> 协议的三个要求，你可以用一个空的扩展直接声明 Array 实现该协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Container</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="给关联类型添加类型限制"><a href="#给关联类型添加类型限制" class="headerlink" title="给关联类型添加类型限制"></a>给关联类型添加类型限制</h3><p>类型限制适用于关联类型，看看下面的例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span>: <span class="type">Equatable</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span></span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在类型限制中使用协议本身"><a href="#在类型限制中使用协议本身" class="headerlink" title="在类型限制中使用协议本身"></a>在类型限制中使用协议本身</h3><p>协议本身可以作为自身要求的一部分。例如这里有一个协议改善了 <code>Container</code> 协议。它添加了一个 <code>suffix(_:)</code> 方法，功能是指定一个长度，从容器最后往前数，返回这个长度的元素。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SuffixableContainer</span>: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Suffix</span>: <span class="type">SuffixableContainer</span> <span class="keyword">where</span> <span class="type">Suffix</span>.<span class="type">Item</span> <span class="operator">==</span> <span class="type">Item</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">suffix</span>(<span class="keyword">_</span> <span class="params">size</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Suffix</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Suffix</code> 是一个关联类型，有两个限制：它必须实现本身协议（在这里是 <code>SuffixableContainer</code>）；并且它的 <code>Item</code> 类型必须和当前容器的 <code>Item</code> 类型相同。</p>
<p>下面对 Stack 进行扩展使其符合 <code>SuffixableContainer</code> 协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span>: <span class="title">SuffixableContainer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">suffix</span>(<span class="keyword">_</span> <span class="params">size</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Stack</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="operator">=</span> <span class="type">Stack</span>()</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> (count<span class="operator">-</span>size)<span class="operator">..&lt;</span>count &#123;</span><br><span class="line">            result.append(<span class="keyword">self</span>[index])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Inferred that Suffix is Stack.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stackOfInts <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">stackOfInts.append(<span class="number">10</span>)</span><br><span class="line">stackOfInts.append(<span class="number">20</span>)</span><br><span class="line">stackOfInts.append(<span class="number">30</span>)</span><br><span class="line"><span class="keyword">let</span> suffix <span class="operator">=</span> stackOfInts.suffix(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// suffix contains 20 and 30</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中关联类型 <code>Suffix</code> 的类型同样是 Stack，所以用 suffix 操作返回的对象类型依旧是 Stack。</p>
<p>或者 <code>Suffix</code> 类型其实并不需要一定是其本身，只要符合 <code>SuffixableContainer</code> 协议就可以。比如下面的例子，suffix 操作返回的是 Stack<Int> 而并不是 IntStack 类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">IntStack</span>: <span class="title">SuffixableContainer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">suffix</span>(<span class="keyword">_</span> <span class="params">size</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> (count<span class="operator">-</span>size)<span class="operator">..&lt;</span>count &#123;</span><br><span class="line">            result.append(<span class="keyword">self</span>[index])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Inferred that Suffix is Stack&lt;Int&gt;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型-Where-语句"><a href="#泛型-Where-语句" class="headerlink" title="泛型 Where 语句"></a>泛型 Where 语句</h3><p>对关联类型进行类型限制也是很实用的。下面的例子中使用 where 语句对参数中两个容器的关联类型 Item 进行了类型限制。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allItemsMatch</span>&lt;<span class="type">C1</span>: <span class="type">Container</span>, <span class="type">C2</span>: <span class="type">Container</span>&gt;</span></span><br><span class="line"><span class="function">    (<span class="keyword">_</span> <span class="params">someContainer</span>: <span class="type">C1</span>, <span class="keyword">_</span> <span class="params">anotherContainer</span>: <span class="type">C2</span>)</span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">where</span> <span class="type">C1</span>.<span class="type">Item</span> <span class="operator">==</span> <span class="type">C2</span>.<span class="type">Item</span>, <span class="type">C1</span>.<span class="type">Item</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check that both containers contain the same number of items.</span></span><br><span class="line">        <span class="keyword">if</span> someContainer.count <span class="operator">!=</span> anotherContainer.count &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check each pair of items to see if they&#x27;re equivalent.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>someContainer.count &#123;</span><br><span class="line">            <span class="keyword">if</span> someContainer[i] <span class="operator">!=</span> anotherContainer[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// All items match, so return true.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以这样用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stackOfStrings <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;uno&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;dos&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;tres&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrayOfStrings <span class="operator">=</span> [<span class="string">&quot;uno&quot;</span>, <span class="string">&quot;dos&quot;</span>, <span class="string">&quot;tres&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> allItemsMatch(stackOfStrings, arrayOfStrings) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All items match.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not all items match.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;All items match.&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：文档对其解释了一大堆，实际上我觉得看代码一看就懂。只是好像没说到如果 where 语句的条件不满足会怎么样，但是想想也能知道，肯定编译报错了呗，(・ω&lt;)。</p>
</blockquote>
<h3 id="扩展使用泛型-Where-语句"><a href="#扩展使用泛型-Where-语句" class="headerlink" title="扩展使用泛型 Where 语句"></a>扩展使用泛型 Where 语句</h3><p>这个就是按条件进行扩展了，但是条件是一个泛型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isTop</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> topItem <span class="operator">=</span> items.last <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> topItem <span class="operator">==</span> item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际使用起来。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> stackOfStrings.isTop(<span class="string">&quot;tres&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Top element is tres.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Top element is something else.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Top element is tres.&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果这个 Stack 的 Element 类型没有实现 Equatable 呢？会报错。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NotEquatable</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> notEquatableStack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">NotEquatable</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> notEquatableValue <span class="operator">=</span> <span class="type">NotEquatable</span>()</span><br><span class="line">notEquatableStack.push(notEquatableValue)</span><br><span class="line">notEquatableStack.isTop(notEquatableValue)  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>再换一个例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Container</span> <span class="title">where</span> <span class="title">Item</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startsWith</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count <span class="operator">&gt;=</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> <span class="keyword">self</span>[<span class="number">0</span>] <span class="operator">==</span> item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再用一用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>].startsWith(<span class="number">42</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starts with 42.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starts with something else.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Starts with something else.&quot;</span></span><br></pre></td></tr></table></figure>

<p>例子三连。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Container</span> <span class="title">where</span> <span class="title">Item</span> == <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">average</span>()</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sum <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>count &#123;</span><br><span class="line">            sum <span class="operator">+=</span> <span class="keyword">self</span>[index]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum <span class="operator">/</span> <span class="type">Double</span>(count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>([<span class="number">1260.0</span>, <span class="number">1200.0</span>, <span class="number">98.6</span>, <span class="number">37.0</span>].average())</span><br><span class="line"><span class="comment">// Prints &quot;648.9&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="关联类型和泛型-Where-语句"><a href="#关联类型和泛型-Where-语句" class="headerlink" title="关联类型和泛型 Where 语句"></a>关联类型和泛型 Where 语句</h3><blockquote>
<p>R：这几个小节连续下来只告诉了我什么叫啰嗦，还有 where 是只要指定类型就是能用的。咱啥也不多说了，看例子吧。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span></span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Iterator</span>: <span class="type">IteratorProtocol</span> <span class="keyword">where</span> <span class="type">Iterator</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Item</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span>()</span> -&gt; <span class="type">Iterator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>协议继承也能用 Where 对关联类型进行点什么要求。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ComparableContainer</span>: <span class="title">Container</span> <span class="title">where</span> <span class="title">Item</span>: <span class="title">Comparable</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型下标"><a href="#泛型下标" class="headerlink" title="泛型下标"></a>泛型下标</h3><blockquote>
<p>R：没想到吧，下表也能泛型，还用上了 where 呢！</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">subscript</span>&lt;<span class="type">Indices</span>: <span class="type">Sequence</span>&gt;(<span class="params">indices</span>: <span class="type">Indices</span>)</span> -&gt; [<span class="type">Item</span>]</span><br><span class="line">        <span class="keyword">where</span> <span class="type">Indices</span>.<span class="type">Iterator</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Int</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> result <span class="operator">=</span> [<span class="type">Item</span>]()</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> indices &#123;</span><br><span class="line">                result.append(<span class="keyword">self</span>[index])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 Indices 其实可以理解成一个数组，传递这个对象给下标，可以得到一个 Item 数组，包含 Indices 中所有索引对应的元素。</p>
<blockquote>
<p>R：泛型真的是可以为所欲为！</p>
</blockquote>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>25.<a href="https://github.com/zfanli/notes/blob/master/swift/25.Protocols.md">Swift Protocols</a></p>
<p>27.<a href="https://github.com/zfanli/notes/blob/master/swift/27.OpaqueTypes.md">Swift Opaque Types</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>28.Swift Automatic Reference Counting</title>
    <url>/post/notes/swift/28-AutomaticReferenceCounting/</url>
    <content><![CDATA[<p>没想到这篇主题内容也是这么丰富。</p>
<p>Swift 中使用一个叫做自动引用计数的机制来决定什么时候销毁一个对象释放资源。简称 ARC。</p>
<p>ARC 只对强引用计数。预期是你不需要操心任何内存释放的问题，但实际上会有一种情况导致 ARC 不能有效的释放内存。强引用循环。</p>
<p>出于 ARC 的原理，只有强引用计数归零才能触发 ARC 对对象实例的释放操作。但是如果有两个实例相互进行强引用，那么就会陷入一个强引用的死循环。两者相互保持对方还活着，那么两个实例就永远不会被销毁，这会造成内存泄露或溢出。</p>
<span id="more"></span>

<p>解决方法很简单，不要让两个实例保持相互强引用即可。Swift 提供了 <code>weak</code> 标记弱引用，<code>unowned</code> 标注非持有引用来解决这个问题。两者都不算一个强引用，不会被 ARC 计数，区别在于前者相当于一个可选类型的引用，而后者不是。使用这两个关键字，则表示这个实例对引用对象没有强引用存在，那么引用对象就可能会被销毁，即使该实例仍然引用对方。但是在 <code>weak</code> 引用时，引用对象被销毁会触发 ARC 将其设置为 <code>nil</code>，我们可以据此检测引用对象是否被销毁了。但是对于 <code>unowned</code> 来说，引用对象被销毁之后再访问会造成一个运行时错误。</p>
<p>所以非持有引用仅在保证引用对象不会先于自己被销毁时使用。</p>
<p>除了类的实例，闭包也是引用类型，所以其也可能造成强引用循环。使用捕获列表定义闭包捕获的每一个引用的引用类型，可以是弱引用或者非持有引用之一。对于和闭包生命周期相同的引用使用非持有引用，对于生命周期短于闭包的引用使用弱引用。弱引用的对象被销毁后同样触发 ARC 将其设置为 <code>nil</code>。</p>
<h2 id="自动引用计算"><a href="#自动引用计算" class="headerlink" title="自动引用计算"></a>自动引用计算</h2><p>Swift 使用自动引用计算（简称 ARC）管理你的 App 的内存使用。在绝大多数情况下这意味着 Swift 的内存管理是自动的，你不需要对内存管理投入太多思考。ARC 会自动对不再使用的实例进行垃圾回收，释放内存。</p>
<p>然而，ARC 在一些场景下为了帮你管理内存需要你提供部分代码的更多关系信息。这篇主题描述这些场景并像你展示 ARC 如何管理你的 App 使用内存。</p>
<p>引用计算只针对类的示例有效。结构体和枚举类型是值类型而非引用类型，不是以引用方式储存和传递的。</p>
<h3 id="ARC-如何工作"><a href="#ARC-如何工作" class="headerlink" title="ARC 如何工作"></a>ARC 如何工作</h3><p>每次当你创建一个类的实例时，ARC 都会分配一块内存用来储存和这个实例相关的信息。这个内存储存关于这个实例的所有类型信息和所有关联的属性值。</p>
<p>另外，当一个实例不再需要时，ARC 会释放这个实例使用的内存资源。这保证类的实例在不使用后不再占据内存。</p>
<p>然而如果 ARC 释放了一个仍然在使用中的实例，其后果是这个实例的属性和方法都将不能访问。实际上，这种情况下如果你尝试访问这个实例，你的应用应该会崩溃掉。</p>
<p>为了保证一个实例在仍然被需要的时候不会突然消失，ARC 会追踪有多少属性、常量、变量当前正在引用实例。只要还有一个引用存在，ARC 就不会对实例释放内存。</p>
<p>为了让这变成可能，当你赋值一个实例给属性、变量或常量时，这些属性、变量或常量会对实例进行强引用。之所以称之为“强”引用，是因为它将稳定的保持住实例，只要强引用还存在就不允许该实例被释放内存。</p>
<h3 id="ARC-实战"><a href="#ARC-实战" class="headerlink" title="ARC 实战"></a>ARC 实战</h3><p>下面是一个例子展示了 ARC 是如何工作的。首先定义一个简单的类 <code>Person</code>，它有一个常量 <code>name</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being initialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：就不一行一行解释这个类了，相信都能看懂，文档真啰嗦。</p>
</blockquote>
<p>下面定义三个 <code>Person?</code> 类型的变量，用来对之后的 <code>Person</code> 实例设置多个引用关系。它们是可选类型，所以它们会在没有赋值 <code>Person</code> 类型的值之前被初始化为 <code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reference1: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference2: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference3: <span class="type">Person</span>?</span><br></pre></td></tr></table></figure>

<p>先给一个变量赋值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">reference1 <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;John Appleseed is being initialized&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意初始化器中的信息被打印出来了，这确认了初始化器被执行了。</p>
<p>因为 <code>reference1</code> 变量被赋值了新的 <code>Person</code> 对象，这个对象有了一个强引用。而因为存在至少一个强引用存在，ARC 就会保持其存在内存之中而不去释放它。</p>
<p>如果你将其赋值给另外两个变量，则该对象就多了两个强引用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">reference2 <span class="operator">=</span> reference1</span><br><span class="line">reference3 <span class="operator">=</span> reference1</span><br></pre></td></tr></table></figure>

<p>现在这个实例有三个强引用。</p>
<p>通过给变量赋值为 <code>nil</code> 可以移除对实例的强引用。下面移除两个强引用，但是因为还存在一个强引用存在，它还不会被释放掉。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">reference1 <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">reference2 <span class="operator">=</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>在第三个强引用被移除之前 ARC 都不会释放它。现在我们移除最后一个强引用，你可以看到卸载器中的消息被打印出来，表明这个实例以及被释放掉了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">reference3 <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Prints &quot;John Appleseed is being deinitialized&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="类实例之间的强引用循环"><a href="#类实例之间的强引用循环" class="headerlink" title="类实例之间的强引用循环"></a>类实例之间的强引用循环</h3><p>上面的例子中，ARC 可以计算你所创建的 <code>Person</code> 实例的强引用数量，并且在不需要该实例的时候进行释放。</p>
<p>但是，也可能出现一个实例的强引用数量永远也不会为零的情况。这种情况一般是两个实例都保持对方的强引用，因此它们相互保持不被释放。这就是所谓的强引用循环。</p>
<p>要解决强引用循环，你可以将两个类的关系定义为弱引用，或者是非持有引用。这个处理在后文还会解释。但是在你尝试解决这个问题之前，先了解一下造成这个问题的原因吧。</p>
<p>下面是一个偶尔造成强引用循环的例子。这个例子定义了 <code>Person</code> 和 <code>Apartment</code> 类，用来表示一个公寓和其住户。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123; <span class="keyword">self</span>.name <span class="operator">=</span> name &#125;</span><br><span class="line">    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apartment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> unit: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">unit</span>: <span class="type">String</span>)</span> &#123; <span class="keyword">self</span>.unit <span class="operator">=</span> unit &#125;</span><br><span class="line">    <span class="keyword">var</span> tenant: <span class="type">Person</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;Apartment <span class="subst">\(unit)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个 <code>Person</code> 实例都有一个 name 属性和一个 apartment 属性。apartment 属性是可选的，因为可能这个人可能没有公寓。</p>
<p>相同的，每个 <code>Apartment</code> 实例会有一个 unit 属性和一个 tenant 属性。tenant 也是可选的，因为一个公寓可能也会没人住。</p>
<p>这两个类都定义了卸载器，在不需要这些实例的时候打印一些提示信息。这可以让你看看实例是否如你预期的一样被释放。</p>
<p>下面定义两个变量准备创建新的实例。它们的类型都是可选的，目前它们被初始化为 <code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> unit4A: <span class="type">Apartment</span>?</span><br></pre></td></tr></table></figure>

<p>现在我们来创建各自的实例。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">john <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line">unit4A <span class="operator">=</span> <span class="type">Apartment</span>(unit: <span class="string">&quot;4A&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>现在，这两个变量拥有各自实例的强引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john                                unit4A</span><br><span class="line"></span><br><span class="line">↓强引用                             ↓强引用</span><br><span class="line"></span><br><span class="line">Person 实例                         Apartment 实例</span><br><span class="line">name: &quot;John Appleseed&quot;              unit: &quot;4A&quot;</span><br><span class="line">apartment: nil                      tenant: nil</span><br></pre></td></tr></table></figure>

<p>接下来将这两个实例关联起来，让 John 住进公寓，让公寓又一个住户。注意这里使用感叹号强制解包类型来赋值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">john<span class="operator">!</span>.apartment <span class="operator">=</span> unit4A</span><br><span class="line">unit4A<span class="operator">!</span>.tenant <span class="operator">=</span> john</span><br></pre></td></tr></table></figure>

<p>现在这两个实例直接相互持有对方的强引用关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john                                        unit4A</span><br><span class="line"></span><br><span class="line">↓强引用                                     ↓强引用</span><br><span class="line"></span><br><span class="line">Person 实例                 ←强引用         Apartment 实例</span><br><span class="line">name: &quot;John Appleseed&quot;      强引用→         unit: &quot;4A&quot;</span><br><span class="line">apartment: &lt;Apartment 实例&gt;                 tenant: &lt;Person 实例&gt;</span><br></pre></td></tr></table></figure>

<p>不幸的是，将这两个实例连接起来会造成强引用循环。两者互相持有对方的强引用，就算我们将两个变量设为 <code>nil</code>，它们的强引用计数也不会归零，ARC 无法释放它们。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">john <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">unit4A <span class="operator">=</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>注意卸载器并没有执行。强引用循环阻止两个实例被 ARC 释放。这会造成你的 APP 内存泄露。</p>
<p>两个实例的关系如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john                                        unit4A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person 实例                 ←强引用         Apartment 实例</span><br><span class="line">name: &quot;John Appleseed&quot;      强引用→         unit: &quot;4A&quot;</span><br><span class="line">apartment: &lt;Apartment 实例&gt;                 tenant: &lt;Person 实例&gt;</span><br></pre></td></tr></table></figure>

<p>两个实例之前的强引用仍然存在，且无法分隔。</p>
<h3 id="解决两个类型之间的强引用循环"><a href="#解决两个类型之间的强引用循环" class="headerlink" title="解决两个类型之间的强引用循环"></a>解决两个类型之间的强引用循环</h3><p>Swift 提供 2 种方式解决类型之间的强引用循环：弱引用和非持有引用（unowned references）。</p>
<p>这两种方式都可以让两者相互引用但不保持对方的强引用，这样就不会进入一个强引用循环了。</p>
<p>在另一个实例生命周期较短时使用弱引用，因为另一个实例可能会先一步被释放掉。在上面的例子中，Apartment 的生命周期中可能有部分时间是没有住户的，所以这里住户属性可以是一个弱引用，这样就不会造成一个强引用循环了。相反，在另一个实例有类似或者更长的生命周期时使用非持有引用。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用不保持类型的强引用关系，ARC 不会将其作为引用计数的一个，弱引用也就不会阻止 ARC 释放实例。这个行为可以阻止陷入一个强引用循环中。要使用弱引用，在属性声明前加上 <code>weak</code> 关键字。</p>
<p>由于不保持引用类型的强引用关系，所以有可能会出现所引用的类型已经被 ARC 释放的情况，对于这种情况，ARC 会自动将其设为 <code>nil</code>，也因此弱引用类型必须是一个可选的类型，因为在运行时它可能被设置为 <code>nil</code>。</p>
<p>你可以像处理可选类型那样检查弱引用的类型是否还存在。</p>
<blockquote>
<p>R：文档提示，属性监视会在弱引用类型被设置为 <code>nil</code> 时触发。</p>
</blockquote>
<p>下面的示例和之前一样，不同之处在于这次 Apartment 的属性 tenant 是弱引用的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123; <span class="keyword">self</span>.name <span class="operator">=</span> name &#125;</span><br><span class="line">    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apartment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> unit: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">unit</span>: <span class="type">String</span>)</span> &#123; <span class="keyword">self</span>.unit <span class="operator">=</span> unit &#125;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> tenant: <span class="type">Person</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;Apartment <span class="subst">\(unit)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当变量关联到两个实例时，由变量保持它们的强引用，就如之前一样。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> unit4A: <span class="type">Apartment</span>?</span><br><span class="line"></span><br><span class="line">john <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line">unit4A <span class="operator">=</span> <span class="type">Apartment</span>(unit: <span class="string">&quot;4A&quot;</span>)</span><br><span class="line"></span><br><span class="line">john<span class="operator">!</span>.apartment <span class="operator">=</span> unit4A</span><br><span class="line">unit4A<span class="operator">!</span>.tenant <span class="operator">=</span> john</span><br></pre></td></tr></table></figure>

<p>下面是变量与实例的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john                                        unit4A</span><br><span class="line"></span><br><span class="line">↓强引用                                     ↓强引用</span><br><span class="line"></span><br><span class="line">Person 实例                 ←弱引用         Apartment 实例</span><br><span class="line">name: &quot;John Appleseed&quot;      强引用→         unit: &quot;4A&quot;</span><br><span class="line">apartment: &lt;Apartment 实例&gt;                 tenant: &lt;Person 实例&gt;</span><br></pre></td></tr></table></figure>

<p>与之前的不同之处在于 Apartment 对 Person 现在是弱引用了。这意味着当你不需要了 john 时，将变量设置为 <code>nil</code>，实例就没有其他强引用了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">john <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Prints &quot;John Appleseed is being deinitialized&quot;</span></span><br></pre></td></tr></table></figure>

<p>结果就是，Person 实例被释放了，Apartment 实例对其的引用被设置为 <code>nil</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john                                        unit4A</span><br><span class="line"></span><br><span class="line">                                            ↓强引用</span><br><span class="line"></span><br><span class="line">Person 实例                                 Apartment 实例</span><br><span class="line">name: &quot;John Appleseed&quot;                      unit: &quot;4A&quot;</span><br><span class="line">apartment: &lt;Apartment 实例&gt;                 tenant: nil</span><br></pre></td></tr></table></figure>

<p>Apartment 实例剩下的唯一一个强引用就是变量 unit4A。如果你移除这个强引用，Apartment 实例就没有强引用了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">unit4A <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Prints &quot;Apartment 4A is being deinitialized&quot;</span></span><br></pre></td></tr></table></figure>

<p>两个实例都被释放了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john                                        unit4A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person 实例                                 Apartment 实例</span><br><span class="line">name: &quot;John Appleseed&quot;                      unit: &quot;4A&quot;</span><br><span class="line">apartment: &lt;Apartment 实例&gt;                 tenant: nil</span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：文档提示。在系统中使用垃圾回收机制时，弱引用有时被用来实现一个简单的缓存机制，因为没有强引用的对象只有在被内存压力触发垃圾回收时才会被释放。但是 ARC 会在强引用归零时立即释放对象，弱引用在这里不适合用于此目的。</p>
</blockquote>
<h3 id="非持有引用（Unowned-References）"><a href="#非持有引用（Unowned-References）" class="headerlink" title="非持有引用（Unowned References）"></a>非持有引用（Unowned References）</h3><p>非持有引用和弱引用相同，都不保持实例的强引用。与弱引用不同，非持有引用用于其他实例生命周期相同或长于自己的情况。指定非持有引用，在声明变量和属性前添加 <code>unowned</code> 关键字。</p>
<p>非持有引用预期引用的实例会一直存在。所以其结果是 ARC 不会像处理弱引用那样在引用被释放时给其设置 <code>nil</code>。这也导致非持有引用要使用非可选类型进行声明。</p>
<blockquote>
<p>重要 ⚠️</p>
<p>仅在你确定直到实例生命周期结束其所引用的对象始终不会被释放时才使用非持有引用。</p>
<p>不然，你会得到一个运行时错误。</p>
</blockquote>
<p>下面定义两个类，Customer 和 CreditCard，用来模拟银行客户和一张客户可以使用的信用卡。两者互相将对方的实例作为自己的属性。它们有潜在的可能造成强引用循环。</p>
<p>Customer 和 CreditCard 之间的关系和上面公寓和住户的关系有些许不同。用户可能有也可能没有信用卡，但是信用卡肯定会被用户持有。没有哪张信用卡会抛弃用户独活。为了表达这一点，对用户来说信用卡属性是可选类型的，但是对于信用卡来说，客户属性是非持有引用的。</p>
<p>此外，CreditCard 实例还需要通过传递一个数字和一个用户实例才可以创建。这可以保证 CreditCard 实例创建时始终关联着某个用户。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> card: <span class="type">CreditCard</span>?</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> number: <span class="type">UInt64</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> customer: <span class="type">Customer</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">number</span>: <span class="type">UInt64</span>, <span class="params">customer</span>: <span class="type">Customer</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.number <span class="operator">=</span> number</span><br><span class="line">        <span class="keyword">self</span>.customer <span class="operator">=</span> customer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;Card #<span class="subst">\(number)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：文档提示，这里信用卡的 number 属性声明为 <code>UInt64</code> 是为了保证不管在 32 位系统或 64 位系统上，这个属性都有足够的空间储存一个 16 位的信用卡号。</p>
</blockquote>
<p>下面声明一个变量将要用来创建一个顾客。这是个可选类型，现在它被初始化为 <code>nil</code> 了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Customer</span>?</span><br></pre></td></tr></table></figure>

<p>现在可以创建一个顾客实例了，然后再发一张信用卡给它。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">john <span class="operator">=</span> <span class="type">Customer</span>(name: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line">john<span class="operator">!</span>.card <span class="operator">=</span> <span class="type">CreditCard</span>(number: <span class="number">1234_5678_9012_3456</span>, customer: john<span class="operator">!</span>)</span><br></pre></td></tr></table></figure>

<p>现在实例之间的关系是这样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">john</span><br><span class="line"></span><br><span class="line">↓强引用</span><br><span class="line"></span><br><span class="line">Customer                    强引用→         CreditCard</span><br><span class="line">name: &quot;John Appleseed&quot;      ←非持有引用     number: 123..6</span><br><span class="line">card: &lt;CreditCard 实例&gt;                     customer: &lt;Customer 实例&gt;</span><br></pre></td></tr></table></figure>

<p>两者之间的关系：顾客实例对信用卡实例持有强引用；信用卡实例对顾客实例是非持有引用关系。</p>
<p>此时如果移除 john 变量对顾客实例的引用，顾客实例的强引用就归零了，ARC 会对其进行释放，同时也导致信用卡实例的强引用归零，ARC 再对信用卡实例进行释放。</p>
<blockquote>
<p>R：一尸两命！(๑✧◡✧๑)</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">john <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Prints &quot;John Appleseed is being deinitialized&quot;</span></span><br><span class="line"><span class="comment">// Prints &quot;Card #1234567890123456 is being deinitialized&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R：文档提示上面已经告诉你如何正确使用非持有引用了，之后使用非持有引用的安全性问题你要自己负责了，反之你用错了你的 App 就会崩溃。＼＼\\ ٩( ‘ω’ )و //／／</p>
</blockquote>
<h3 id="非持有引用和隐式的可选类型属性解包"><a href="#非持有引用和隐式的可选类型属性解包" class="headerlink" title="非持有引用和隐式的可选类型属性解包"></a>非持有引用和隐式的可选类型属性解包</h3><p>上面关于弱引用和非持有引用的两个例子刚好完美解决了问题。但是有时问题不会这么简单，比如下面这个例子。</p>
<p>定义一个 Country 和 City 类。这两个类型都持有对方的实例作为自己的属性。对于 City 来说它必须属于一个国家，而对于 Country 来说它必须有一个首都城市。于是，City 的初始化器需要关联一个 Country 实例，而 Country 被创建时会自动创建一个 City 实例作为首都城市。但是矛盾是，在 Country 的属性没有初始化完成是它还不能使用 <code>self</code>。但是要创建一个 City 实例则必须提供一个 Country 实例。</p>
<blockquote>
<p>R：根据初始化器章节的描述，实例初始化过程分两步进行，第一步保证所有属性初始化完成，第二步才能访问 <code>self</code>。这里 City 作为其属性没有完成初始化，所以无法将 <code>self</code> 作为参数传递给 City 的初始化器。</p>
</blockquote>
<p>为了解决这个问题，使用感叹号对属性进行隐式解包。这样声明的属性是可选类型属性，在初始化时会分配 <code>nil</code> 保证完成初始化步骤的第一步，于是在第二步中可以将 <code>self</code> 传递给 City 的初始化器创建一个 City 实例，赋值给 Country 实例作为首都城市属性。而外部访问 Country 的首都城市属性可以正常访问，而不用像处理可选类型那样添加感叹号。</p>
<p>先捋一下关系，首先 Country 存在，它必须有一个 capitalCity 属性，所以其对 City 类型是强引用。City 类型则必须属于某个 Country，没有 Country 的话 City 不应该存在，City 的 country 属性应该是非持有引用。</p>
<p>然后为了先完成初始化再给 capitalCity 属性具体赋值，Country 类型需要先将其声明为可选类型，但是在初始化器中完成属性初始化后在第二步为其赋值，所以对外部来说其 capitalCity 属性是始终存在的，并不是一个可选类型。为了做到这一点，Country 在定义属性类型后添加感叹号对其进行隐式解包。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> capitalCity: <span class="type">City</span>!</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">capitalName</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.capitalCity <span class="operator">=</span> <span class="type">City</span>(name: capitalName, country: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> country: <span class="type">Country</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">country</span>: <span class="type">Country</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.country <span class="operator">=</span> country</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> country <span class="operator">=</span> <span class="type">Country</span>(name: <span class="string">&quot;Canada&quot;</span>, capitalName: <span class="string">&quot;Ottawa&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(country.name)</span>&#x27;s capital city is called <span class="subst">\(country.capitalCity.name)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Canada&#x27;s capital city is called Ottawa&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="闭包的强引用循环"><a href="#闭包的强引用循环" class="headerlink" title="闭包的强引用循环"></a>闭包的强引用循环</h3><p>闭包同样是一个引用类型，所以闭包也可能会造成一个强引用循环。来看下面的例子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> asHTML: () -&gt; <span class="type">String</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text <span class="operator">=</span> <span class="keyword">self</span>.text &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;<span class="subst">\(text)</span>&lt;/<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span> /&gt;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">text</span>: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里定义了一个 HTMLElement 类，用来描述一个 HTML 元素。它有一个卸载器在被释放时打印一些信息。它的属性 <code>asHTML</code> 是一个闭包，在闭包中调用了 <code>self</code> 的属性。这里 <code>asHTML</code> 属性被声明为 lazy，因为其在初始化阶段是无法访问 <code>self</code> 的。这里的问题是 <code>asHTML</code> 是一个闭包，因为在里面使用了 <code>self</code>，所以实际上这个闭包对实例的 <code>self</code> 保持了一个强引用，同时它是实例的属性，实例对其也保持了强引用，这就造成了一个强引用循环。</p>
<p><code>asHTML</code> 实际上是一个方法，将其定义为闭包的好处在于你可以随时更换这个方法的实现。比如下面这样。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> heading <span class="operator">=</span> <span class="type">HTMLElement</span>(name: <span class="string">&quot;h1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> defaultText <span class="operator">=</span> <span class="string">&quot;some default text&quot;</span></span><br><span class="line">heading.asHTML <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;<span class="subst">\(heading.name)</span>&gt;<span class="subst">\(heading.text <span class="operator">??</span> defaultText)</span>&lt;/<span class="subst">\(heading.name)</span>&gt;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(heading.asHTML())</span><br><span class="line"><span class="comment">// Prints &quot;&lt;h1&gt;some default text&lt;/h1&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在我们定义一个变量。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> paragraph: <span class="type">HTMLElement</span>? <span class="operator">=</span> <span class="type">HTMLElement</span>(name: <span class="string">&quot;p&quot;</span>, text: <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(paragraph<span class="operator">!</span>.asHTML())</span><br><span class="line"><span class="comment">// Prints &quot;&lt;p&gt;hello, world&lt;/p&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>再尝试销毁它。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">paragraph <span class="operator">=</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>卸载器没有被调用，完蛋！它陷入了一个和自己的闭包属性之间的强引用循环，并且无法自拔！</p>
<h3 id="解决闭包的强引用循环"><a href="#解决闭包的强引用循环" class="headerlink" title="解决闭包的强引用循环"></a>解决闭包的强引用循环</h3><p>解决闭包和实例之间的强引用循环，使用一个捕获列表来定义闭包对其捕获的引用是属于弱引用或者非持有引用。这个捕获列表写在闭包里面。</p>
<p>注意捕获列表中的引用是弱引用或者非持有引用，只能二选一。写法是放在闭包参数和返回值类型的前面。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> someClosure: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="operator">=</span> &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>, <span class="keyword">weak</span> delegate <span class="operator">=</span> <span class="keyword">self</span>.delegate<span class="operator">!</span>] (index: <span class="type">Int</span>, stringToProcess: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// closure body goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果闭包没有参数并且返回值类型可以被推测，则将捕获列表写在闭包体前。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> someClosure: () -&gt; <span class="type">String</span> <span class="operator">=</span> &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>, <span class="keyword">weak</span> delegate <span class="operator">=</span> <span class="keyword">self</span>.delegate<span class="operator">!</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// closure body goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果如例子中的 HTMLElement 和其闭包属性 <code>asHTML</code> 这样的关系，应该在闭包中使用非持有引用捕获实例的 <code>self</code>，原因是它们将在同时被销毁释放，它们本身就是同一个生命周期。</p>
<p>相反，如果引用类型生命周期比闭包短则定义一个弱引用，引用对象被销毁时 ARC 会将其设置为 <code>nil</code>，你可以据此检查这个引用是否还存在。</p>
<p>原则上，如果这个引用始终不会变成 <code>nil</code> 则应该始终使用非持有引用。</p>
<p>下面用捕获列表定义实例的 <code>self</code> 为闭包的非持有引用，解决实例和闭包之间的强引用循环问题。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> asHTML: () -&gt; <span class="type">String</span> <span class="operator">=</span> &#123;</span><br><span class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text <span class="operator">=</span> <span class="keyword">self</span>.text &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;<span class="subst">\(text)</span>&lt;/<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span> /&gt;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">text</span>: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> paragraph: <span class="type">HTMLElement</span>? <span class="operator">=</span> <span class="type">HTMLElement</span>(name: <span class="string">&quot;p&quot;</span>, text: <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(paragraph<span class="operator">!</span>.asHTML())</span><br><span class="line"><span class="comment">// Prints &quot;&lt;p&gt;hello, world&lt;/p&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">paragraph <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Prints &quot;p is being deinitialized&quot;</span></span><br></pre></td></tr></table></figure>

<p>看，它正常销毁了。</p>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote>
<p>27.<a href="https://github.com/zfanli/notes/blob/master/swift/27.OpaqueTypes.md">Swift Opaque Types</a></p>
<p>29.<a href="https://github.com/zfanli/notes/blob/master/swift/29.MemorySafety.md">Swift Memory Safety</a></p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Using CSS Transitions and Transforms</title>
    <url>/post/study/css/Using-CSS-Transitions-and-Transforms/</url>
    <content><![CDATA[<p>CSS 过渡属性提供了一种方式给 CSS 属性变化添加过渡动画，过程中属性值的变化是由浏览器所决定，所以其过程也被叫做<code>隐式过渡（implicit transitions）</code>。也因其由浏览器原生实现，所以通常有更好的性能，但是在灵活性上有其局限。</p>
<p>使用场景上，单纯的鼠标悬浮、选中和失去焦点等情况的过渡动画中 CSS 过渡属性是首选；但是当涉及到时间轴动画、稍复杂的补间动画时，应该选择 GSAP 之类的成熟的 JavaScript 动画库才合适。</p>
<blockquote>
<p>这里有一个<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties">可以使用过渡效果的属性列表</a>，对于可添加过渡效果的属性有 2 点需要注意：</p>
<ol>
<li>可以使用过渡效果的属性列表会发生变化，因为 transitions 的规格还没有定版；</li>
<li>对于变化前，或变化后的属性为 <code>auto</code> 的情况，规格建议不做过渡效果，但是每个浏览器对其采取不同处理，所以为了保证效果一致性，我们应该避免对 <code>auto</code> 添加过渡效果。</li>
</ol>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.25s</span> ease;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>) <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="过渡-transitions"><a href="#过渡-transitions" class="headerlink" title="过渡 transitions"></a>过渡 transitions</h2><blockquote>
<p>对于动画效果需要注意！</p>
<p>网页上的缩放动画效果是常见的特定偏头痛症状的触发因素，所以如果你希望在网页上加入这样的动画效果，你应该提供一个开关让用户可以选择关闭动画。</p>
<p>CSS 媒体查询有一个 <code>prefers-reduced-motion</code> 属性表示用户系统偏好设置了减少动画效果，你可以考虑使用这个媒体查询来关闭动画效果。</p>
</blockquote>
<h3 id="定义过渡属性"><a href="#定义过渡属性" class="headerlink" title="定义过渡属性"></a>定义过渡属性</h3><p>CSS 过渡属性可以轻易实现很出效果的动画。</p>
<blockquote>
<p>避免产生不适，点击 <code>start</code> 开始演示动画。</p>
</blockquote>
<div class="example-container" style="height: 150px">
  <div class="example-def transition radius-hover" style="height: 50px; width: 50px; background-color: rgb(25,135,84)"></div>
  <span class="toggle position-absolute top-0 end-0 m-3 hover-pointer">start</span>
</div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.25s</span> ease;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transition"><a href="#transition" class="headerlink" title="transition"></a><code>transition</code></h4><p>简写属性，定义过渡效果最常用的属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: &lt;property&gt; &lt;duration&gt; &lt;timing-function&gt; &lt;delay&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transition-property"><a href="#transition-property" class="headerlink" title="transition-property"></a><code>transition-property</code></h4><p>指定应用过渡效果的属性。</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>没有属性会添加过渡动画</td>
</tr>
<tr>
<td><code>all</code></td>
<td>默认值，所有支持的属性会添加过渡动画</td>
</tr>
<tr>
<td><code>&lt;property&gt;</code></td>
<td>如果属性支持过渡动画，指定的属性会添加过渡动画</td>
</tr>
</tbody></table>
<h4 id="transition-duration"><a href="#transition-duration" class="headerlink" title="transition-duration"></a><code>transition-duration</code></h4><p>指定过度效果的持续时间。</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>有效单位为 <code>ms</code>，<code>s</code></td>
<td>时间值，默认为 <code>0s</code></td>
</tr>
</tbody></table>
<h4 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a><code>transition-timing-function</code></h4><p>指定过度效果的缓动函数，一个描述数值变动速率的数学函数，视觉表现为我们熟知的贝塞尔曲线。</p>
<p><img src="/images/study/css/TimingFunction.png" alt="timing-function"></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>ease</code></td>
<td>默认值，相当于 <code>cubic-bezier(0.25, 0.1, 0.25, 1.0)</code></td>
</tr>
<tr>
<td><code>linear</code></td>
<td>相当于 <code>cubic-bezier(0.0, 0.0, 1.0, 1.0)</code></td>
</tr>
<tr>
<td><code>ease-in</code></td>
<td>相当于 <code>cubic-bezier(0.42, 0, 1.0, 1.0)</code></td>
</tr>
<tr>
<td><code>ease-out</code></td>
<td>相当于 <code>cubic-bezier(0, 0, 0.58, 1.0)</code></td>
</tr>
<tr>
<td><code>ease-in-out</code></td>
<td>相当于 <code>cubic-bezier(0.42, 0, 0.58, 1.0)</code></td>
</tr>
<tr>
<td><code>cubic-bezier(p1, p2, p3, p4)</code></td>
<td>自定义的贝塞尔曲线，<code>p1</code> 和 <code>p3</code> 的值需要在 <code>[0, 1]</code> 区间内</td>
</tr>
<tr>
<td><code>steps( n, &lt;jumpterm&gt;)</code></td>
<td>按步长应用过渡效果，不常用，略</td>
</tr>
</tbody></table>
<blockquote>
<p>步长值定义的参考资料：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function#values">https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function#values</a></li>
</ul>
</blockquote>
<h4 id="transition-delay"><a href="#transition-delay" class="headerlink" title="transition-delay"></a><code>transition-delay</code></h4><p>指定过度效果的延迟时间。</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>有效单位为 <code>ms</code>，<code>s</code></td>
<td>时间值，默认为 <code>0s</code></td>
</tr>
</tbody></table>
<h3 id="定义多个过渡属性"><a href="#定义多个过渡属性" class="headerlink" title="定义多个过渡属性"></a>定义多个过渡属性</h3><h4 id="使用-transition-时"><a href="#使用-transition-时" class="headerlink" title="使用 transition 时"></a>使用 <code>transition</code> 时</h4><p>CSS 过渡可以针对不同属性分别设置持续时间、缓动函数和延迟时间。使用 <code>transition</code> 时，多个过渡设置用逗号分隔。</p>
<blockquote>
<p>避免产生不适，点击 <code>start</code> 开始演示动画。</p>
</blockquote>
<div class="example-container justify-content-evenly" style="height: 150px">
  <div id="example-def" class="example-def transition radius-hover text-white text-nowrap fs-6 d-flex align-items-center justify-content-center" style="height: 50px; width: 50px; background-color: rgb(25,135,84)"><small>指定 all</small></div>
  <div id="example-def" class="example-def transition transition-multiple radius-hover text-white text-nowrap fs-6 d-flex align-items-center justify-content-center" style="height: 50px; width: 50px; background-color: rgb(25,135,84)"><small>分别指定</small></div>
  <span class="toggle position-absolute top-0 end-0 m-3 hover-pointer">start</span>
</div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.25s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.transition-multiple</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: background-color <span class="number">1s</span> ease, width <span class="number">0.25s</span> ease, height <span class="number">0.25s</span> ease, border-radius</span><br><span class="line">      <span class="number">1s</span> ease, transform <span class="number">0.25s</span> ease-in-out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-transition-分别定义时"><a href="#使用-transition-分别定义时" class="headerlink" title="使用 transition-* 分别定义时"></a>使用 <code>transition-*</code> 分别定义时</h4><p>在每个 <code>transition-*</code> 属性中使用逗号分隔值，由位置相互匹配属性，比如上面的简写转换成单独的属性将变成下面的定义。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition-multiple</span> &#123;</span><br><span class="line">  <span class="attribute">transition-property</span>: background-color, width, height, border-radius, transform;</span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">1s</span>, <span class="number">0.25s</span>, <span class="number">0.25s</span>, <span class="number">1s</span>, <span class="number">0.25s</span>;</span><br><span class="line">  <span class="attribute">transition-timing-function</span>: ease, ease, ease, ease, ease-in-out;</span><br><span class="line">  <span class="attribute">transition-delay</span>: <span class="number">0s</span>, <span class="number">0s</span>, <span class="number">0s</span>, <span class="number">0s</span>, <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别定义各过渡属性时，如果遇到值的长度不匹配的情况，将按照下面规则处理：</p>
<ul>
<li>如果 <code>transition-property</code> 长度比其他属性<strong>短</strong>时，无视其他属性多出来的值；</li>
<li>如果 <code>transition-property</code> 长度比其他属性<strong>长</strong>时，其他属性进行循环重复匹配。</li>
</ul>
<p>比如如果有下面的定义。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition-test1</span> &#123;</span><br><span class="line">  <span class="comment">/* the length of property is shorter than the duration */</span></span><br><span class="line">  <span class="attribute">transition-property</span>: background-color, width;</span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">1s</span>, <span class="number">0.25s</span>, <span class="number">0.25s</span>, <span class="number">1s</span>, <span class="number">0.25s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.transition-test2</span> &#123;</span><br><span class="line">  <span class="comment">/* the length of duration is shorter than the property */</span></span><br><span class="line">  <span class="attribute">transition-property</span>: background-color, width, height, border-radius, transform;</span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">1s</span>, <span class="number">0.25s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终将转换成以下的设置起效。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition-test1</span> &#123;</span><br><span class="line">  <span class="attribute">transition-property</span>: background-color, width;</span><br><span class="line">  <span class="comment">/* the parts that longer than property are truncated */</span></span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">1s</span>, <span class="number">0.25s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.transition-test2</span> &#123;</span><br><span class="line">  <span class="attribute">transition-property</span>: background-color, width, height, border-radius, transform;</span><br><span class="line">  <span class="comment">/* values are repeated to match the length */</span></span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">1s</span>, <span class="number">0.25s</span>, <span class="number">1s</span>, <span class="number">0.25s</span>, <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-JavaScript-时需要注意"><a href="#使用-JavaScript-时需要注意" class="headerlink" title="使用 JavaScript 时需要注意"></a>使用 JavaScript 时需要注意</h3><p>在下面操作之后<strong>立即</strong>修改过渡属性时，可能<strong>不会触发</strong>过渡动画：</p>
<ul>
<li>使用 <code>.appendChild()</code> 将元素添加到 DOM；</li>
<li>修改 <code>display: none;</code> 属性让元素显示时。</li>
</ul>
<p>原因在于修改过渡属性时元素的样式属性可能还未计算出来，这导致元素显示出来时已经是过渡结束的状态，其初始状态未被触发，所以也就不会发生过渡效果。规避这个限制的最简单方法是使用 <code>setTimeout()</code> 函数让过渡属性的修改延迟几毫秒，元素的初始状态将在这期间进行计算。</p>
<h3 id="检测-CSS-过渡效果的开始和结束"><a href="#检测-CSS-过渡效果的开始和结束" class="headerlink" title="检测 CSS 过渡效果的开始和结束"></a>检测 CSS 过渡效果的开始和结束</h3><p><code>TransitionEvent</code> 用来判断过渡动画的进行状态，浏览器会在过渡动画的执行阶段触发下面事件：</p>
<table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>transitioncancel</code></td>
<td>当 CSS 过渡动画被取消时触发</td>
</tr>
<tr>
<td><code>transitionend</code></td>
<td>当 CSS 过渡动画结束时触发</td>
</tr>
<tr>
<td><code>transitionrun</code></td>
<td>当 CSS 过渡动画被创建，并被放入执行队列时触发，此时动画可能尚未开始</td>
</tr>
<tr>
<td><code>transitionstart</code></td>
<td>当 CSS 过渡动画开始时触发</td>
</tr>
</tbody></table>
<p>同时 <code>TransitionEvent</code> 拥有下面属性：</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>.propertyName</code></td>
<td>包含过渡动画关联属性名称的 <code>DOMString</code></td>
</tr>
<tr>
<td><code>.elapsedTime</code></td>
<td>一个 <code>float</code> 表达过渡动画执行了多长时间，以秒为单位，不受延迟时间影响</td>
</tr>
<tr>
<td><code>.pseudoElement</code></td>
<td>如果过渡动画执行对象是一个伪类元素，则为 <code>::</code> 开头的伪类元素名称的 <code>DOMString</code>，否则为空字符串</td>
</tr>
</tbody></table>
<blockquote>
<p>鼠标悬停，或者点击 <code>start</code> 开始统计事件数据。</p>
</blockquote>
<div class="example-container flex-column">
  <div class="w-100 p-3 d-flex align-items-center justify-content-center position-relative" style="height: 150px">
    <div id="transitionTarget" class="example-def transition radius-hover" style="height: 50px; width: 50px; background-color: rgb(25,135,84)"></div>
    <span class="toggle position-absolute top-0 end-0 m-3 hover-pointer">start</span>
  </div>
  <div class="w-100 mb-3 d-flex flex-column align-items-center justify-content-center text-nowrap">
    <div>
      <div class="text-center fw-bold">Event Status</div>
      <span class="me-3">Transition State: <code id="transitionState">Unknown</code></span>
      <span>Elapsed Time: <code id="elapsedTime">Unknown</code></span>
    </div>
    <div>
      <div class="text-center fw-bold">Event Count</div>
      <code>transitioncancel: <span id="countCancel">0</span></code>
      <code>transitionend: <span id="countEnd">0</span></code><br>
      <code>transitionrun: <span id="countRun">0</span></code>
      <code>transitionstart: <span id="countStart">0</span></code>
    </div>
  </div>
</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#transitionTarget&quot;</span>);</span><br><span class="line">target.addEventListener(<span class="string">&quot;transitioncancel&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">target.addEventListener(<span class="string">&quot;transitionend&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">target.addEventListener(<span class="string">&quot;transitionrun&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">target.addEventListener(<span class="string">&quot;transitionstart&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="变换-transforms"><a href="#变换-transforms" class="headerlink" title="变换 transforms"></a>变换 transforms</h2><p>用下面的 Demo 尝试各种变换的效果，下面的设定可以修改，结果会实时反应到绿色方块上。你可以按 <code>reset</code> 按钮到默认状态。</p>
<style id="example-transform-style"></style>
<div class="example-container example-transform flex-wrap" style="min-height: 240px">
  <div class="control-panel d-flex flex-column highlight css my-3">
    <pre class="bg-transparent m-0"
      ><span class="line hover-pointer" contentEditable="true"
        ><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">120px</span>, <span class="hljs-number">50px</span>);</span
      ><span class="line hover-pointer" contentEditable="true"
        ><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0.5turn</span>);</span
      ><span class="line hover-pointer" contentEditable="true"
        ><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.3</span>);</span
      ><span class="line hover-pointer" contentEditable="true"
        ><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">skew</span>(<span class="hljs-number">30deg</span>, <span class="hljs-number">20deg</span>);</span
      ><span class="line hover-pointer" contentEditable="true"
        ><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">perspective</span>(<span class="hljs-number">500px</span>);</span
    ></pre>
  </div>
  <div class="demo-panel flex-grow-1 d-flex align-items-center justify-content-center mb-3">
    <div id="demo-transform" class="" style="height: 100px; width: 100px; background-color: rgb(25,135,84)"></div>
  </div>
  <span class="reset position-absolute top-0 end-0 m-3 mt-1 hover-pointer">reset</span>
</div>

<h3 id="定义变换属性"><a href="#定义变换属性" class="headerlink" title="定义变换属性"></a>定义变换属性</h3><p>用于定义变换效果的属性主要有 2 个。</p>
<h4 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a><code>transform-origin</code></h4><p>指定原点的位置，默认的位置是元素的中心点。这个属性对旋转、缩放和歪曲等变换效果有效果，因为这些效果需要基于一个点作为参数。</p>
<style id="example-transform-origin-style"></style>
<div class="example-container example-transform-origin flex-wrap" style="min-height: 240px">
  <div class="control-panel d-flex flex-column highlight css my-3">
    <pre class="bg-transparent m-0"
      ><span class="line hover-pointer" contentEditable="true" data-transform="rotate(30deg)" data-origin="top: 50%; left: 50%;"
        ><span class="hljs-attribute">transform-origin</span>: center;</span
      ><span class="line hover-pointer" contentEditable="true" data-transform="rotate(30deg)" data-origin="top: 0; left: 0;"
        ><span class="hljs-attribute">transform-origin</span>: top left;</span
      ><span class="line hover-pointer" contentEditable="true" data-transform="rotate(30deg)" data-origin="top: 20px; left: 50px;"
        ><span class="hljs-attribute">transform-origin</span>: 50px 20px;</span
      ><span class="line hover-pointer" contentEditable="true" data-transform="rotate3d(1, 2, 0, 60deg)" data-origin="top: 100%; left: 100%;"
        ><span class="hljs-attribute">transform-origin</span>: bottom right 60px;</span
      ><span class="line hover-pointer" contentEditable="true" data-transform="rotate(30deg)" data-origin="top: 100%; left: 0;"
        ><span class="hljs-attribute">transform-origin</span>: bottom left;</span
    ></pre>
  </div>
  <div class="demo-panel flex-grow-1 d-flex align-items-center justify-content-center mb-3">
    <div id="demo-transform-origin" class="" style=""></div>
  </div>
  <span class="reset position-absolute top-0 end-0 m-3 mt-1 hover-pointer">reset</span>
</div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* One value */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform-origin</span>: &lt;length&gt;|&lt;percentage&gt;|&lt;keyword&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Two values */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform-origin</span>: &lt;length&gt;|&lt;percentage&gt;|&lt;x-offset-keyword&gt;</span><br><span class="line">    &lt;length&gt;|&lt;percentage&gt;|&lt;y-offset-keyword&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Three values, the third value represents the z offset */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform-origin</span>: &lt;length&gt;|&lt;percentage&gt;|&lt;x-offset-keyword&gt;</span><br><span class="line">    &lt;length&gt;|&lt;percentage&gt;|&lt;y-offset-keyword&gt; &lt;length&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Keyword</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>0%</td>
<td>x-offset-keyword</td>
</tr>
<tr>
<td>center</td>
<td>50%</td>
<td>x-offset-keyword, y-offset-keyword</td>
</tr>
<tr>
<td>right</td>
<td>100%</td>
<td>x-offset-keyword</td>
</tr>
<tr>
<td>top</td>
<td>0%</td>
<td>y-offset-keyword</td>
</tr>
<tr>
<td>bottom</td>
<td>100%</td>
<td>y-offset-keyword</td>
</tr>
</tbody></table>
<h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a><code>transform</code></h4><p>变换属性让你旋转、缩放、歪曲或平移元素。变换属性只能应用在由 CSS 盒子模型控制的可变换元素。你可以只指定一个变换函数，也可以用空格分隔同时指定多个变换函数。</p>
<p>当你指定多个变换函数时构成组合变换 <code>Composition Transforms</code>，每个变换效果将根据<strong>从右到左</strong>的顺序依次应用。</p>
<p>指定多个变换函数时，你可以重复指定同一种函数，这些函数会按照上述顺序执行。请注意有些函数交换位置后不影响结果，但是其他的函数执行顺序至关重要。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Single function */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: &lt;transform-function&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiple functions */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: &lt;transform-function&gt; [&lt;transform-function&gt; ...];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-matrix"><a href="#transform-matrix" class="headerlink" title="transform: matrix"></a><code>transform: matrix</code></h4><p>均匀的 2D 变换矩阵。还有一个 3d 版本 <code>matrix3d</code> 在下文介绍。</p>
<blockquote>
<p><strong>NOTE! 注意！</strong></p>
<p>演示代码中定义了多个 <code>transform</code> 属性，但是实际使用中最后一个定义的变换效果会覆盖之前的定义，如果需要定义多个变换效果，请定义一个 <code>transform</code> 属性，用<strong>空格分隔变换函数</strong>赋值给它。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">matrix</span>(a, b, c, d, tx, ty);</span><br><span class="line">  <span class="comment">/* For each parameters the function at the same position will be applied */</span></span><br><span class="line">  <span class="comment">/* matrix(scaleX(), skewY(), skewX(), scaleY(), translateX(), translateY()) */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Equivalent to the below */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">matrix3d</span>(a, b, <span class="number">0</span>, <span class="number">0</span>, c, d, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, tx, ty, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This line will take effect */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">matrix</span>(<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">80</span>, <span class="number">80</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-translate"><a href="#transform-translate" class="headerlink" title="transform: translate"></a><code>transform: translate</code></h4><p>在 2d 平面平移元素。这个变换函数有几个变种函数。</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Parameters</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>translate()</code></td>
<td><code>&lt;length&gt;[, &lt;length&gt;]</code></td>
<td>在 2d 平面平移元素，如果纵轴没有给值则使用横轴的值</td>
</tr>
<tr>
<td><code>translate3d()</code></td>
<td><code>tx, ty, tz</code></td>
<td>在 3d 空间平移元素，3d 版本具体在下文介绍</td>
</tr>
<tr>
<td><code>translateX()</code></td>
<td><code>tx</code></td>
<td>在水平方向平移元素，等同 <code>translate(tx, 0)</code> 或 <code>translate3d(tx, 0, 0)</code></td>
</tr>
<tr>
<td><code>translateY()</code></td>
<td><code>ty</code></td>
<td>在垂直方向平移元素，等同 <code>translate(0, ty)</code> 或 <code>translate3d(0, ty, 0)</code></td>
</tr>
<tr>
<td><code>translateZ()</code></td>
<td><code>tz</code></td>
<td>围绕 z 轴平移元素，等同 <code>translate3d(0, 0, tz)</code></td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50%</span>);</span><br><span class="line">  <span class="comment">/* This line will take effect */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-scale"><a href="#transform-scale" class="headerlink" title="transform: scale"></a><code>transform: scale</code></h4><p>在 2d 平面缩放元素。这个变换函数有几个变种存在。</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Parameters</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>scale()</code></td>
<td><code>sx[, xy]</code></td>
<td>在 2d 平面缩放元素，如果纵轴没有给值则使用横轴的值</td>
</tr>
<tr>
<td><code>scale3d()</code></td>
<td><code>sx, sy, sz</code></td>
<td>在 3d 空间缩放元素，3d 版本具体在下文介绍</td>
</tr>
<tr>
<td><code>scaleX()</code></td>
<td><code>s</code></td>
<td>调整水平方向元素大小，等同 <code>scale(sx, 1)</code> 或 <code>scale3d(sx, 1, 1)</code></td>
</tr>
<tr>
<td><code>scaleY()</code></td>
<td><code>s</code></td>
<td>调整垂直方向元素大小，等同 <code>scale(1, sy)</code> 或 <code>scale3d(1, sy, 1)</code></td>
</tr>
<tr>
<td><code>scaleZ()</code></td>
<td><code>s</code></td>
<td>围绕 z 轴调整元素大小，等同 <code>scale3d(1, 1, sz)</code></td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">  <span class="comment">/* This line will take effect */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(-<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-rotate"><a href="#transform-rotate" class="headerlink" title="transform: rotate"></a><code>transform: rotate</code></h4><p>在 2d 平面围绕一个固定点旋转元素。这个变换函数有几个变种函数。</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Parameters</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>rotate()</code></td>
<td><code>&lt;angle&gt;</code></td>
<td>在 2d 平面围绕一个<strong>固定点</strong>旋转元素，固定点坐标由 <code>transform-origin</code> 定义</td>
</tr>
<tr>
<td><code>rotate3d()</code></td>
<td><code>x, y, z, &lt;angle&gt;</code></td>
<td>在 3d 空间围绕一个<strong>固定轴</strong>旋转元素，3d 版本具体在下文介绍</td>
</tr>
<tr>
<td><code>rotateX()</code></td>
<td><code>&lt;angle&gt;</code></td>
<td>围绕水平坐标轴旋转元素，等同 <code>rotate3d(1, 0, 0, a)</code></td>
</tr>
<tr>
<td><code>rotateY()</code></td>
<td><code>&lt;angle&gt;</code></td>
<td>围绕垂直坐标轴旋转元素，等同 <code>rotate3d(0, 1, 0, a)</code></td>
</tr>
<tr>
<td><code>rotateZ()</code></td>
<td><code>&lt;angle&gt;</code></td>
<td>围绕 z 轴旋转元素，等同 <code>rotate3d(0, 0, 1, a)</code></td>
</tr>
</tbody></table>
<p><code>&lt;angle&gt;</code> 单位定义。</p>
<table>
<thead>
<tr>
<th>Unit</th>
<th>Definition</th>
</tr>
</thead>
<tbody><tr>
<td><code>deg</code></td>
<td>单位 <code>度</code>，一整圈为 <code>360deg</code></td>
</tr>
<tr>
<td><code>grad</code></td>
<td>单位 <code>梯度</code>，一整圈为 <code>400grad</code></td>
</tr>
<tr>
<td><code>rad</code></td>
<td>单位 <code>弧度</code>，弧度一整圈为 2π，表示接近 <code>6.2832rad</code></td>
</tr>
<tr>
<td><code>turn</code></td>
<td>单位 <code>转</code>，一整圈为 <code>1turn</code></td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0.5turn</span>);</span><br><span class="line">  <span class="comment">/* This line will take effect */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">200grad</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-skew"><a href="#transform-skew" class="headerlink" title="transform: skew"></a><code>transform: skew</code></h4><p>在 2d 平面歪曲元素。这个变换函数有几个变种存在。歪曲函数的参数使用角度单位，与 <code>rotate</code> 一致。</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Parameters</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>skew()</code></td>
<td><code>ax[, ay]</code></td>
<td>在 2d 平面缩放元素，如果纵轴没有给值则使用横轴的值</td>
</tr>
<tr>
<td><code>skewX()</code></td>
<td><code>&lt;angle&gt;</code></td>
<td>在水平方向歪曲元素，等同 <code>skew(a)</code></td>
</tr>
<tr>
<td><code>skewY()</code></td>
<td><code>&lt;angle&gt;</code></td>
<td>在垂直方向歪曲元素</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>);</span><br><span class="line">  <span class="comment">/* This line will take effect */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>, <span class="number">60deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3D-变换属性"><a href="#3D-变换属性" class="headerlink" title="3D 变换属性"></a>3D 变换属性</h3><p>3d 空间的变换效果相对 2d 平面来说参数和概念上复杂很多，并且使用场景差别较大，这一部分我们单独拿出来讨论。</p>
<h4 id="transform-matrix3d"><a href="#transform-matrix3d" class="headerlink" title="transform: matrix3d"></a><code>transform: matrix3d</code></h4><p>均匀的 <code>4 x 4</code> 的 3d 变换矩阵。矩阵变换是 <code>transform</code> 属性实现的基础，所有其他变换函数都是在计算完结果之后应用矩阵变换实现的。</p>
<p>换言之，所有变换效果都有一个与之对应的矩阵变换的写法。对于一般效果而言，使用对应的变换函数是最方便的，但是对于组合变换也难以实现的变换效果来说，就需要用到矩阵变换来实现。</p>
<p>下面是 3d 矩阵变换的参数定义，详细探索以后有机会再具体探讨。</p>
<!-- prettier-ignore-start -->
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">matrix3d</span>(</span><br><span class="line">    a1, b1, c1, d1,</span><br><span class="line">    a2, b2, c2, d2,</span><br><span class="line">    a3, b3, c3, d3,</span><br><span class="line">    a4, b4, c4, d4</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- prettier-ignore-end -->

<h4 id="transform-translate3d"><a href="#transform-translate3d" class="headerlink" title="transform: translate3d"></a><code>transform: translate3d</code></h4><p>在 3d 空间平移元素。3d 的元素平移变换相对 2d 版本并没有复杂多少，接受 3 个向量作为横轴、纵轴和 z 轴方向上的移动量。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">/* This line will take effect */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">42px</span>, -<span class="number">662px</span>, -<span class="number">125px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-scale3d"><a href="#transform-scale3d" class="headerlink" title="transform: scale3d"></a><code>transform: scale3d</code></h4><p>在 3d 空间缩放元素。这个变换也接收 3 个向量，分别作为横轴、纵轴和 z 轴的缩放量。如果 3 个向量的值相等，则元素将按照等比在 3d 空间缩放。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="comment">/* 这两个定义将等比缩放 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(<span class="number">1.3</span>, <span class="number">1.3</span>, <span class="number">1.3</span>);</span><br><span class="line">  <span class="comment">/* 下面的定义不是等比缩放 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(<span class="number">0.5</span>, <span class="number">1.4</span>, <span class="number">0.8</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(-<span class="number">1.4</span>, <span class="number">0.5</span>, <span class="number">0.7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-rotate3d"><a href="#transform-rotate3d" class="headerlink" title="transform: rotate3d"></a><code>transform: rotate3d</code></h4><p>在 3d 空间围绕一个<strong>固定轴</strong>旋转元素。3d 空间的旋转相比复杂一点。</p>
<p>在 3d 空间旋转一个元素存在 3 个方向的自由度，由三个向量组成的 3d 坐标 <code>[x, y, z]</code> 和 <code>transform-origin</code> 原点连成一条直线构成 3d 旋转的转轴。</p>
<blockquote>
<p>如果指定的向量未<strong>标准化</strong>（<code>normalized</code>，比如 3 个坐标值的平方和为 <code>1</code>），浏览器会代为进行标准化。但是如果指定的值无法进行标准化，比如指定了 <code>[0, 0, 0]</code>，则旋转会被无视，但是不会导致整个 CSS 属性失效。</p>
<p>另外，2d 平面上的元素旋转应用的顺序不会影响其效果，但是通常 3d 空间的旋转不同，其会根据应用的顺序不同，从而产生不同的效果。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate3d</span>(x, y, z, a);</span><br><span class="line">  <span class="comment">/* Examples */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate3d</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">30deg</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate3d</span>(<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0.5turn</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transform-perspective"><a href="#transform-perspective" class="headerlink" title="transform: perspective"></a><code>transform: perspective</code></h4><p>透视变换，设定用户与 <code>z=0</code> 平面的距离。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> perspective demo with CSS cube */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">800px</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">23rem</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions">Using CSS transitions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transforms/Using_CSS_transforms">Using CSS transforms</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transition">transition</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform">transform</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent">TransitionEvent</a></li>
</ul>
<!-- Resources used by only this post -->
<style>
.transition {
  cursor: pointer;
  transition: all .25s ease;
  border-radius: 0;
}
.transition-multiple {
  transition: background-color 1s ease, width .25s ease, height .25s ease, border-radius 1s ease, transform .25s ease-in-out;
}
.radius-hover:hover {
  border-radius: 50%!important;
}
.hover-pointer {
  cursor: pointer;
}
.example-container .line {
  display: block;
  margin: 2px 0;
  padding: 5px;
  width: 370px;
  border-left: 4px transparent solid;
  border-bottom: 1px transparent solid;
  overflow: auto;
}
.example-container .line.active {
  border-color: #198754;
}
.example-container .line:focus {
  outline: none;
}

#demo-transform-multiple,
#demo-transform {
  transition: all .25s ease;
}
#demo-transform-origin {
  position: relative;
  border: 3px dashed #dc3545;
  height: 106px;
  width: 106px;
  border-radius: 2px;
}
#demo-transform-origin::before {
  transform: rotate(0);
  content: 'ROTATE ME';
  color: white;
  line-height: 100px;
  text-align: center;
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 100%;
  background-color: rgb(25, 135, 84);
  z-index: -1;
}
#demo-transform-origin::after {
  content: ' ';
  width: 5px;
  height: 5px;
  position: absolute;
  background-color: white;
  border-radius: 50%;
  padding: 3px;
  border: 3px solid #dc3545;
  transform: translate(-50%, -50%);
}
</style>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
<script>
$(function(){
  // example-def start
  const $def = $('.example-def')
  let states = [
    {'background-color': '#d63384',
     'width': '50px', 'height': '100px',
     'transform': 'rotate(.1turn)', 'border-radius': '100%'},
    {'background-color': '#0d6efd',
     'width': '45px', 'height': '45px',
     'transform': 'rotate(.5turn)', 'border-radius': '50%'},
    {'background-color': '#ffc107',
     'width': '100px', 'height': '60px',
     'transform': 'rotate(.6turn)', 'border-radius': '50%'},
    {'background-color': 'rgb(25,135,84)',
     'width': '50px', 'height': '50px',
     'transform': 'rotate(1turn)', 'border-radius': '0%'},
  ]
  let state = 0
  const anime = () => setInterval(() => {
    const curr = states[state++ % 4]
    Object.keys(curr).forEach(key => {
      $def.css(key, curr[key])
    })
  }, 1000)
  let timer = null
  // let timer = anime()
  const toggle = $('.example-container .toggle')
  toggle.click(function () {
    if ($(this).text() === "stop") {
      clearInterval(timer)
      toggle.text('start')
    } else {
      timer = anime()
      toggle.text('stop')
    }
  })
  // example-def end
  // example-event start
  let cancel = 0, run = 0, end = 0, start = 0
  const target = $('#transitionTarget'),
    transitionState = $('#transitionState'),
    elapsedTime = $('#elapsedTime'),
    countCancel = $('#countCancel'),
    countEnd = $('#countEnd'),
    countRun = $('#countRun'),
    countStart = $('#countStart'),
    count = {
      'Cancelled': () => countCancel.text(++cancel),
      'Ended': () => countEnd.text(++end),
      'Run': () => countRun.text(++run),
      'Started': () => countStart.text(++start),
    },
    record = name => e => {
      // console.log(e)
      transitionState.text(name)
      elapsedTime.text(e.originalEvent.elapsedTime)
      count[name]()
    }
  target.on('transitioncancel', record('Cancelled'))
  target.on('transitionend', record('Ended'))
  target.on('transitionrun', record('Run'))
  target.on('transitionstart', record('Started'))
  // example-event end
  // example-transform start
  ;(function() {
    const lines = $('.example-transform .line'),
      transformStyles = $('#example-transform-style')
    lines.each(function(){
      $(this).data('bk', $(this).html())
    })
    lines.click(function() {
      lines.removeClass('active')
      $(this).addClass('active')
      transformStyles.html(`.example-transform #demo-transform {${$(this).text()}}`)
    })
    lines.on('input', function() {
      transformStyles.html(`.example-transform #demo-transform {${$(this).text()}}`)
    })
    $('.example-transform .reset').click(() => lines.each(function() {
      lines.removeClass('active')
      $(this).html($(this).data('bk'))
      transformStyles.html('')
    }))
  })()
  // example-transform end
  // example-transform-origin start
  ;(function() {
    const lines = $('.example-transform-origin .line'),
      transformStyles = $('#example-transform-origin-style')
    lines.each(function(){
      $(this).data('bk', $(this).html())
    })
    lines.click(function() {
      lines.removeClass('active')
      transformStyles.html('')
      $(this).addClass('active')
      setTimeout(()=>
      transformStyles.html(`#demo-transform-origin::before {${$(this).text()}} #demo-transform-origin::after {${$(this).data('origin')}}`)
      ,10)
      setTimeout(()=>
      transformStyles.html(`#demo-transform-origin::before {transition: all .75s ease;${$(this).text()}transform: ${$(this).data('transform')}!important;} #demo-transform-origin::after {${$(this).data('origin')}}`)
      ,100)
    })
    lines.on('input', function() {
      transformStyles.html(`#demo-transform-origin::before {transition: all .75s ease;${$(this).text()}transform: ${$(this).data('transform')}!important;} #demo-transform-origin::after {${$(this).data('origin')}}`)
    })
    $('.example-transform-origin .reset').click(() => lines.each(function() {
      lines.removeClass('active')
      $(this).html($(this).data('bk'))
      transformStyles.html('')
    }))
  })()
  // example-transform-origin end
  // example-transform-multiple start
  ;(function() {
    const lines = $('.example-transform-multiple .line'),
      transformStyles = $('#example-transform-multiple-style')
    lines.each(function(){
      $(this).data('bk', $(this).html())
    })
    lines.click(function() {
      lines.removeClass('active')
      $(this).addClass('active')
      transformStyles.html(`.example-transform-multiple #demo-transform-multiple {${$(this).text()}}`)
    })
    lines.on('input', function() {
      transformStyles.html(`.example-transform-multiple #demo-transform-multiple {${$(this).text()}}`)
    })
    $('.example-transform-multiple .reset').click(() => lines.each(function() {
      lines.removeClass('active')
      $(this).html($(this).data('bk'))
      transformStyles.html('')
    }))
  })()
  // example-transform-multiple end
})
</script>
]]></content>
      <categories>
        <category>study</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器如何渲染网页？- DOM，CSSOM &amp; Render Tree</title>
    <url>/post/study/html/How-the-Browser-Renders-HTML-CSS/</url>
    <content><![CDATA[<p>使用浏览器打开一个网页，你会发现有一部分网页资源在加载完之前会阻塞浏览器的渲染进程，还有一部分网页资源可以被异步加载。前端开发时你偶尔会遇到这些问题：资源下载速度<strong>缓慢</strong>？首屏等待<strong>多余的文件</strong>下载和初始化？未应用 CSS 的内容<strong>一闪而过</strong>（flash of unstyled content，<code>FOUC</code>）？要避免它们，开发一个用户体验优秀的网站，你需要的是理解浏览器渲染网页的逻辑与顺序。</p>
<p>当浏览器发送请求到服务器以获取 HTML，服务器用<strong>二进制流（<code>binary stream</code>）</strong>形式返回 HTML 的文本内容，在响应中，服务器将 header 部分的 <code>Content-Type</code> 属性的值设置为 <code>text/html; charset=UTF-8</code>。其中 <code>text/html</code> 部分告诉浏览器响应数据是一份 HTML 文本；<code>charset=UTF-8</code> 部分告诉浏览器响应数据使用的字符集。有了这些信息，浏览器就可以正常的解析 HTML 标签并对网页进行渲染了。相反，如果响应的 header 部分中缺少了 <code>Content-Type</code> 属性，浏览器会因为缺少对响应数据的描述信息而将其数据以纯文本的方式展现给用户。</p>
<p>浏览器要渲染的网页主体由 HTML 文本构成，通常有额外的 CSS 文件提供样式，有 JS 文件提供脚本操作。不过浏览器到底是如何从一堆文本信息中知道如何渲染一个网页？讨论这件事情之前，我们需要理解什么是 <strong>DOM</strong>、<strong>CSSOM</strong> 和 <strong>Render Tree</strong>。</p>
<span id="more"></span>

<p>本文以下面这个简单的 HTML 为例来解释浏览器渲染网页的过程。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Rendering Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- stylesheet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./style.css&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a sample paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- script --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Document-Object-Model-DOM"><a href="#Document-Object-Model-DOM" class="headerlink" title="Document Object Model (DOM)"></a>Document Object Model (DOM)</h2><p>浏览器会将所有 HTML 元素转换为 JavaScript 的 <strong>Node</strong> 对象。因为 HTML 元素存在不同的标签和不同的属性，浏览器在转换过程中会将它们变成不同的 Node 子类。</p>
<blockquote>
<p>💡 比如 <code>div</code> 元素会被转换为<strong>继承</strong> <code>Node</code> 的子类 <code>HTMLDivElement</code>。随便找一个网页，打开开发者控制台，输入下面代码来来看看结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">div <span class="keyword">instanceof</span> HTMLDivElement;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">div <span class="keyword">instanceof</span> Node;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>除此之外，浏览器给每一个 HTML 元素创建了对应的类，比如 <code>HTMLScriptElement</code> 等。</p>
</blockquote>
<p>由于 HTML 中的元素是相互嵌套的，浏览器创建每个元素的 Node 对象之后会将它们按照 HTML 中的关系来创建一个树形数据，以此来在网页的整个生命周期内有效的渲染和管理元素。而这个树形数据也就是所谓的 <strong>DOM 树</strong>。例子中的 HTML 解析成 DOM 树之后会变成下面这个样子。</p>
<pre class="text-center"><code class="d-inline-block mt-0 mb-3 text-start">
                                +-----------------+
                                |      html       |
                                | HTMLHtmlElement |
                                +-----/-----\-----+
                                /------       -------\
                        /------                      -------\
            +-----------------+                         +-----------------+
            |      head       |                         |     body        |
            | HTMLHeadElement |                         | HTMLBodyElement |
            +-------/-\-------+                         +-------/-\-------+
                 /--   --\                                   /--   --\
               /-         -\                               /-         -\
            /--             --\                         /--             --\
+------------------+   +-----------------+  +------------------+  +-------------------+
|       title      |   |      link       |  |       div        |  |       script      |
| HTMLTitleElement |   | HTMLLinkElement |  |  HTMLDivElement  |  | HTMLScriptElement |
+------------------+   +-----------------+  +--------/-\-------+  +-------------------+
                                                  /--   ---\
                                              /---          --\
                                          /--                 ---\
                              +--------------------+    +----------------------+
                              |         h1         |    |           p          |
                              | HTMLHeadingElement |    | HTMLParagraphElement |
                              +----------|---------+    +-----------|----------+
                                         |                          |
                                         |                          |
                              +----------|---------+    +-----------|----------+
                              |     (TextNode)     |    |       (TextNode)     |
                              |      Hello...      |    |       This is...     |
                              +--------------------+    +----------------------+
</code><div>DOM Tree</div></pre>

<p>DOM 树的结构如其所示，从最上面的根节点 <code>html</code> 元素开始，按照每个元素出现的顺序和嵌套的关系向下分支。每当浏览器遇到一个 HTML 元素时，就会在 DOM 树上用这个元素的类创建一个对应的节点。不过 DOM 树的节点不仅包括 HTML 元素，其他诸如注释、属性、文本等类型的数据也会被创建成一个节点存在于 DOM 树的数据结构之中。但是简单起见，本文中我们只关注 DOM 树中的 HTML 元素节点，也就是所谓的 DOM 元素。（你可以从<a href="https://www.w3schools.com/jsref/prop_node_nodetype.asp">这个列表</a>了解一共 12 种不同的节点类型。）</p>
<p>你可以在浏览器开发者控制台的 Elements 标签页看到 DOM 树的可视化表现。从可视化的视图中你可以看到 DOM 元素的层级关系和每个元素的属性。DOM 并非 JavaScript 的规格实现的一部分，它是由浏览器提供的高级 Web API，目的是为了高效地渲染网页，同时公开给开发者根据需求动态地操作 DOM 元素。</p>
<blockquote>
<p>💡 通过 DOM API，开发者可以对 HTML 元素进行添加和删除操作，可以改变 HTML 元素的外观，或者监听相应的事件。使用 DOM API 时，HTML 元素可以不影响已渲染的 DOM 树，在内存中进行创建和复制操作。这个特性让前端开发可以设计出用户体验更好的动态页面。</p>
</blockquote>
<h2 id="CSS-Object-Model-CSSOM"><a href="#CSS-Object-Model-CSSOM" class="headerlink" title="CSS Object Model (CSSOM)"></a>CSS Object Model (CSSOM)</h2><p>通过提供 CSS 样式我们可以设计出美观的网页。我们知道 CSS 全称为 <strong>Cascading Style Sheets</strong>，使用 CSS <strong>选择器</strong>可以给指定的 DOM 元素设定像 <code>color</code> 或 <code>font-size</code> 之类的属性。提供 CSS 样式也有几个不同的方法，比如使用外部文件，使用内嵌在 HTML 的 <code>&lt;style&gt;</code> 标签，或者对单个 HTML 元素使用行内属性 <code>style</code>，亦或者使用 JavaScript。但是这里最困难的工作是将这些所有的 CSS 样式应用到对应的 DOM 元素上，浏览器必须要完成这个工作。</p>
<p>假设之前的例子中 <code>style.css</code> 中定义了以下 CSS 样式属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器在创建完 DOM 树后会开始读取各种来源提供的 CSS，据此来创建 CSSOM，也就是所谓的 <strong>CSS Object Model</strong>。这个数据结构和 DOM 树相似，同样是一个树形数据。CSSOM 树上的每一个节点包含对应 DOM 元素的所有 CSS 信息，这个对应元素通过 CSS 选择器来指定。CSSOM 树不包含不会显示在屏幕上的 DOM 元素信息，比如 <code>&lt;meta&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;title&gt;</code> 等元素。</p>
<p>我们需要理解浏览器计算 CSS 属性的规则。每个浏览器都会提供一套用户代理样式（<strong>User Agent Stylesheets</strong>）来设定一些 CSS 属性的默认值，浏览器通过将开发者提供的 CSS 属性根据特定规则覆盖用户代理样式来计算最终的 CSS 属性值，并且依此创建 CSSOM 树的节点。如有 CSS 属性在用户代理样式和开发者指定的样式中都没有定义，浏览器将根据 W3C CSS 标准指定的<strong>默认值</strong>来设定这个属性。</p>
<p>使用默认值时，如果该属性在 W3C 文档中被标识为可继承的属性，默认值将根据某些继承规则来决定。例如一个 HTML 元素的 <code>color</code> 和 <code>font-size</code> 属性在未作具体定义时，默认值会从其父元素继承。因此当你给一个 HTML 元素设定这些属性，这个元素的所有子代元素都会继承这些属性作为默认值。这个规则就是<strong>样式层叠（cascading of styles）</strong>，这也是为什么 CSS 叫作层叠样式表（cascading style sheets）的原因所在，同样这也是为什么浏览器要将 CSSOM 构建成一个树形结构的原因，浏览器可以根据其父节点的样式和继承规则来计算每个元素的最终的 CSS 样式属性。</p>
<blockquote>
<p>💡 浏览器的开发者控制台中，在 Elements 标签中有一个 Computed 面板中会显示元素所有最终计算出来的属性值。</p>
</blockquote>
<p>我们可以将上面的 CSS 构建成 CSSOM 树的结果可视化表达为下面的树状图表。这里简单起见，我们先无视由浏览器定义的所有用户代理样式，只关注开发者提供的 CSS 样式。</p>
<pre class="text-center"><code class="d-inline-block mt-0 mb-3 text-start">
            +-----------------+
            |       html      |
            |  padding: 0px;  |
            |   margin: 0px;  |
            +---------\-------+
                        --\
                          ---\
                              --\
                        +-------------------+
                        |       body        |
                        |  font-size: 14px; |
                        +--------/----------+
                              /--
                            /--
                        /--
          +-----------------------+
          |          div          |
          |      width: 300px;    |
          |     height: 200px;    |
          |      color: black;    |
          |  <span class="text-danger">font-size: 14px;</span>     |
          +----------/-\----------+
                  /--   ---\
                /--          --\
            /--                ---\
+--------------------+   +----------------------+
|         h1         |   |           p          |
|      color: gray;  |   |  font-size: 12px;    |
|  <span class="text-danger">font-size: 14px;</span>  |   |    display: none;    |
+--------------------+   |      <span class="text-danger">color: black;</span>   |
                         +----------------------+
</code><div>CSSOM Tree</div></pre>

<p>与之前的 DOM 树图表相比，你会发现 CSSOM 树上不存在 <code>&lt;meta&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;title&gt;</code> 等不在屏幕上显示的元素。图表中红色的属性表示是从上层继承来的层叠样式，这些样式在当前元素没有设定相应的属性时作为默认值被浏览器设定。而如果当前元素设定了对应的属性，比如 <code>h1</code> 元素的 <code>color</code> 属性被设为了 <code>gray</code>，从上层继承而来的 <code>black</code> 就不再起作用，但是 <code>p</code> 元素没有设定这个属性，<code>black</code> 就作为从上层元素层叠下来的式样被浏览器设置给了它。</p>
<h2 id="Render-Tree"><a href="#Render-Tree" class="headerlink" title="Render Tree"></a>Render Tree</h2><p>Render-Tree 顾名思义，同样是一个树形结构的数据，通过组合 DOM 树和 CSSOM 树创建而成。Render-Tree 的作用在于帮助浏览器计算每个可见元素的<strong>布局（Layout）</strong>并在屏幕上进行<strong>绘制（Paint）</strong>。不过也因为如此，在 DOM 树和 CSSOM 树被创建出来之前，屏幕上不会渲染任何内容。</p>
<p>Render-Tree 是一种底层表达，用来决定哪些元素最终会输出到屏幕上，那些不占据任何像素面积的节点不包括在 Render-Tree 中。比如 <code>display: none;</code> 的元素使用 <code>0px x 0px</code> 的面积，它们不会出现在 Render-Tree 中。</p>
<pre class="text-center"><code class="d-inline-block mt-0 mb-3 text-start">
             +-----------------+
             |       html      |
             |  padding: 0px;  |
             |   margin: 0px;  |
             +---------\-------+
                        --\
                           ---\
                               --\
                         +-------------------+
                         |       body        |
                         |  font-size: 14px; |
                         +--------/----------+
                               /--
                            /--
                         /--
           +-----------------------+
           |          div          |
           |      width: 300px;    |
           |     height: 200px;    |
           |      color: black;    |
           |  <span class="text-danger">font-size: 14px;</span>     |
           +----------/------------+
                   /--
                /--
             /--
+--------------------+
|         h1         |
|      color: gray;  |
|  <span class="text-danger">font-size: 14px;</span>  |
+----------|---------+
           |
           |
           |
+----------|---------+
|     (TextNode)     |
|      color: gray;  |
|  <span class="text-danger">font-size: 14px;</span>  |
+--------------------+
</code><div>Render-Tree</div></pre>

<p>上面的图表是 DOM 树和 CSSOM 树构成 Render-Tree 的结果。如你所见，Render-Tree 选择性的仅保留了会显示在屏幕上的内容作为节点构成这棵树。比如 CSSOM 树中 <code>p</code> 元素的属性是 <code>display: none;</code>，所以它被排除在 Render-Tree 之外。不过，如果某个元素是 <code>visibility: hidden;</code> 或 <code>opacity: 0;</code>，这个元素还是会占据屏幕空间，所以同样会出现在 Render-Tree 中。</p>
<p>浏览器提供 DOM API 让开发者可以直接的访问到 DOM 树上的元素，但是没有提供直接操作 CSSOM 的接口。不过介于最终浏览器要合并 DOM 树和 CSSOM 树来创建 Render-Tree，浏览器在 DOM 元素身上暴露了一套高级 API 来让开发者可以操作元素对应的 CSSOM 的 CSS 属性。</p>
<h2 id="渲染顺序"><a href="#渲染顺序" class="headerlink" title="渲染顺序"></a>渲染顺序</h2><p>现在我们理解了什么是 DOM、CSSOM 和 Render-Tree，下一步就是理解浏览器如何使用它们渲染网页。理解这个过程对于前端开发者设计和开发一个高用户体验和高性能的网站至关重要。</p>
<p>网页加载后，浏览器首先读取 HTML 文本，从中创建 DOM 树。其次浏览器处理行内、内嵌或者外部文件中的 CSS 样式，据此创建 CSSOM 树。在 DOM 树和 CSSOM 树创建完成之后，浏览器接着合并它们，创建 Render-Tree。一旦 Render-Tree 创建完成，浏览器通过下面的步骤开始向屏幕上输出 Render-Tree 中的所有元素。</p>
<h3 id="布局操作"><a href="#布局操作" class="headerlink" title="布局操作"></a>布局操作</h3><p>首先浏览器为 Render-Tree 中的每一个节点生成布局。生成的布局包括<strong>每个元素的尺寸</strong>以及输出到屏幕上的位置。这个过程中浏览器会计算每个节点的布局信息，所以称作布局操作。这个过程也称作<strong>重排（Reflow）</strong>或<strong>浏览器重排（Browser Reflow）</strong>，当你<strong>滑动滚动条</strong>、<strong>调整窗口大小</strong>或者<strong>操作 DOM 元素</strong>时也会触发重排操作。</p>
<blockquote>
<p>💡 重排操作会计算页面布局。一个元素进行重排会重新计算它的尺寸和位置关系，并且一个元素的重排会进一步触发其子代元素、父代元素和临近元素的重排。最终重排会导致重绘（Repaint）。重排是很重的操作，但不幸的是重排操作可以被轻易触发。</p>
<p>下面这些情况都会触发重排操作：</p>
<ul>
<li>插入、移除或更新一个 DOM 元素</li>
<li>修改页面内容，比如修改输入框的文本</li>
<li>移动 DOM 元素</li>
<li>动画操作一个 DOM 元素</li>
<li>测量元素，使用 <code>offsetHeight</code> 或 <code>getComputedStyle</code></li>
<li>改变 CSS 属性</li>
<li>改变元素的 Class 属性</li>
<li>添加或移除样式表</li>
<li>调整窗口大小</li>
<li>操作滚动条</li>
</ul>
</blockquote>
<h3 id="绘制操作"><a href="#绘制操作" class="headerlink" title="绘制操作"></a>绘制操作</h3><p>现在我们有一堆几何图形需要输出到屏幕上。浏览器会给 Render-Tree 中的每个元素创建<strong>图层（Layer）</strong>，来处理这些元素可能会出现的相互覆盖，或者受元素的 CSS 属性的变化而引起的对元素的外观、位置或尺寸的频繁改变。</p>
<p>图层可以让浏览器在网页的生命周期中高效率的执行绘制操作，来处理诸如滚动条动作或调整窗口大小行为造成的重绘。图层也能让浏览器根据元素的 <code>z-index</code> 属性正确的根据开发者的意图堆叠元素。</p>
<p>现在我们有图层了，浏览器会合并它们，并且在屏幕上进行绘制。不过浏览器不会一次性绘制所有图层，每个图层会先分开绘制。在每个图层中，浏览器会将所有可见属性填充像素，比如元素的边框、背景颜色、阴影和文本等属性。这个过程也被叫做<strong>删格化（Rasterization）</strong>。浏览器会用不同的<strong>线程</strong>完成删格化过程来提升性能。</p>
<blockquote>
<p>💡 浏览器对网页中的图层的处理和 <strong>Photoshop</strong> 对图层的处理是类似的。你可以从浏览器的开发者工具中可视化观察图层处理，打开开发者工具，选择“<strong>更多</strong>”选项，然后选择“<strong>图层</strong>”。你也可以在“<strong>渲染</strong>”面板可视化观察图层的边界。删格化通常在 CPU 中完成，这也造成删格化处理缓慢且消耗资源，不过现在有新技术用 GPU 执行删格化过程来强化性能。</p>
</blockquote>
<h3 id="合成操作"><a href="#合成操作" class="headerlink" title="合成操作"></a>合成操作</h3><p>目前为止我们还未在屏幕上绘制任何内容。现在有的是不同的图层的位图，我们需要按照指定的顺序在屏幕上绘制。在<strong>合成</strong>操作中，这些图层会经由 GPU 处理，最终在屏幕上绘制出来。但是将整个图层发送出去绘制是低效的，因为每次<strong>重排（Reflow）</strong>或<strong>重绘（Repaint）</strong>时这个过程都会发生一次。因此，每个图层被分解成不同的<strong>贴图</strong>，然后才被绘制到屏幕上。在浏览器开发者工具的渲染面板中你可以可视化观察到这些贴图。</p>
<p>从上面的信息中，我们可以构建一个路径串联这些事件来描述浏览器如何从网页的 HTML 和 CSS 的文本信息中向屏幕上渲染内容。这个一系列事件也被称作<strong>关键渲染路径（Critical Rendering Path）</strong>。</p>
<pre class="text-center"><code class="d-inline-block mt-0 mb-3 text-start">
    +----------------+   +----------------+   +----------------+
    |       DOM      |   |     CSSOM      |   |   Render-Tree  |
    |  construction  |-> |  construction  |-> |  construction  | --+
    +----------------+   +----------------+   +----------------+   |
                                                                   |
 +-----------------------------------------------------------------+
 |
 |  +----------------+   +----------------+   +----------------+
 |  |     Layout     |   |      Paint     |   |   Compositing  |
 -> |    operation   |-> |    operation   |-> |    operation   |
    +----------------+   +----------------+   +----------------+
</code><div>Critical Rendering Path</div></pre>

<h2 id="浏览器引擎"><a href="#浏览器引擎" class="headerlink" title="浏览器引擎"></a>浏览器引擎</h2><p>浏览器中的<strong>浏览器引擎（Browser engines）</strong>，也叫做<strong>渲染引擎</strong>或<strong>视图引擎</strong>，负责创建 DOM 树、CSSOM 树，处理渲染逻辑。浏览器引擎中存在所有必要的元素和逻辑来将网页 HTML 代码渲染到屏幕上的实际的像素点。如果你有听过人们在讨论 <strong>WebKit</strong>，实际上人们讨论的是浏览器引擎。<strong>WebKit</strong>是 Apple 的 Safari 浏览器使用的渲染引擎，也是谷歌 Chrome 浏览器曾经使用过的渲染引擎。目前 <strong>Chromium</strong> 项目使用 <strong>Blink</strong> 作为默认渲染印象。</p>
<blockquote>
<p>下面是流行的浏览器和其使用的渲染引擎。</p>
<ul>
<li>IE<ul>
<li>Engine: Trident</li>
<li>CSS-prefix: <code>-ms</code></li>
</ul>
</li>
<li>Edge<ul>
<li>Engine: <del>EdgeHTML</del> → Blink</li>
<li>CSS-prefix: <code>-ms</code></li>
</ul>
</li>
<li>Firefox<ul>
<li>Engine: Gecko</li>
<li>CSS-prefix: <code>-moz</code></li>
</ul>
</li>
<li>Opera<ul>
<li>Engine: <del>Presto</del> → Blink</li>
<li>CSS-prefix: <code>-o</code> (Presto) and <code>-webkit</code> (Blink)</li>
</ul>
</li>
<li>Safari<ul>
<li>Engine: WebKit</li>
<li>CSS-prefix: <code>-webkit</code></li>
</ul>
</li>
<li>Chrome<ul>
<li>Engine: <del>WebKit</del> → Blink</li>
<li>CSS-prefix: <code>-webkit</code></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h2><p>冷知识：JavaScript 实际上是一个注册商标，它的语言标准由 ECMAScript 制定。</p>
<p>JavaScript 存在 V8、Chakra 和 Spider Monkey 等不同的语言引擎，ECMAScript 制定的语言标准让不同的引擎遵守相同的规则，保持 JavaScript 在浏览器、Node 或 Deno 等不同运行环境之下的行为和体验的一致性，这个特性非常有利于面向多平台的 JavaScript 应用的开发。</p>
<p>不过，关于浏览器该如何渲染网页却是另一种情况。HTML、CSS 或 JavaScript 的语言标准由一些实体或组织制定标准。但是，到了关于浏览器该如何管理和渲染网页这块目前还没有任何标准化出现。Chrome 的浏览器引擎可能会采取与 Safari 浏览器引擎不同的方式处理网页。</p>
<p>我们很难预测特定浏览器的渲染顺序和其背后的机制。不过 HTML5 的规格对理论上浏览器该如何做渲染的标准化上做出了一些努力，但浏览器支持这个标准到何种程度完全取决于其自身。</p>
<p>尽管存在如此的不一致性，但是浏览器之间还是存在一些通用原则。</p>
<h3 id="解析和外部资源"><a href="#解析和外部资源" class="headerlink" title="解析和外部资源"></a>解析和外部资源</h3><p><strong>解析（Parsing）</strong>是浏览器读取 HTML 内容并且创建 DOM 树的过程。因此这个过程也称作 <strong>DOM 解析（Parsing）</strong>，解析 DOM 的程序叫做 <strong>DOM 解析器（Parser）</strong>。大多数浏览器提供 <code>DOMParser</code> 接口从 HTML 代码创建 DOM 树。使用时先创建 <code>DOMParser</code> 的实例对象，调用它的 <code>parseFromString</code> 方法，我们可以将原始 HTML 代码文本解析为 DOM 树。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parser = <span class="keyword">new</span> DOMParser();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">parser.parseFromString(<span class="string">&quot;&lt;p&gt;Hello World!&lt;/p&gt;&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line"><span class="comment">// #document</span></span><br><span class="line"><span class="comment">// &lt;html&gt;</span></span><br><span class="line"><span class="comment">//  ​&lt;head&gt;​&lt;/head&gt;​</span></span><br><span class="line"><span class="comment">//  &lt;body&gt;</span></span><br><span class="line"><span class="comment">//    ​&lt;p&gt;​Hello World!​&lt;/p&gt;​</span></span><br><span class="line"><span class="comment">//  &lt;/body&gt;</span></span><br><span class="line"><span class="comment">// ​&lt;/html&gt;​</span></span><br></pre></td></tr></table></figure>

<p>浏览器向网站的服务器发出请求，服务器随之响应请求并返回 HTML 文本，服务器通过将响应 Header 的 <code>Content-Type</code> 设为 <code>text/html</code> 告诉浏览器响应数据的类型，然后只要 HTML 有部分内容被读取到，浏览器就可以开始<strong>解析</strong>。因此浏览器可以每次一个节点的<strong>增量</strong>创建 DOM 树。由于 HTML 是一个嵌套的树状结构，浏览器会从上而下的解析 HTML 代码。</p>
<p>这个过程表现出来的结果就是，浏览器在后台下载网页内容的时候会逐步解析已经下载完成的内容，所以用户会看到网页的内容依次显示出来——先解析完成的先显示在屏幕上，同时后台在持续下载过程，如果有新的下载完成的部分出现，浏览器会立即将其解析成 DOM 树，并尝试在屏幕上显示出来。</p>
<p>打开开发者工具的<strong>性能</strong>标签页，在 <strong>Timing</strong> 这行可以看到一些<strong>事件</strong>。这些事件是网站的<strong>性能指标</strong>，这些事件<strong>越靠近</strong>并且<strong>出现的越早</strong>，则表示用<strong>户体验</strong>越好。</p>
<blockquote>
<p>💡 使用性能标签页的刷新按钮可以重新采集性能数据。</p>
</blockquote>
<p>来解释一下这些事件。你会看到 <code>FP</code> 事件，它的全称是 <strong>First Paint</strong>，意味着从这个时间点开始浏览器开始向屏幕绘制东西了，这时绘制的可能是 <code>body</code> 的背景颜色。</p>
<p><code>FCP</code> 的全称是 <strong>First Contentful Paint</strong>，意味着从这个时间点开始浏览器开始绘制网页内容，比如文本和图片。<code>LCP</code> 全称为 <strong>Largest Contentful Paint</strong>，意味着从这个时间点开始浏览器已经绘制了大块文本或图片。</p>
<blockquote>
<p>💡 你可能听过 <code>FMP</code>，即 <strong>First Meaningful Paint</strong>，是一个类似 <strong>LCP</strong> 的指标，由于重复已经从 Chrome 中移除了。</p>
</blockquote>
<p><code>L</code> 表示 <code>onload</code> 事件，发生在 <code>window</code> 对象上。<code>DCL</code> 表示 <code>DOMContentLoaded</code> 事件，发生在 <code>document</code> 对象上，但是会向上冒泡到 <code>window</code> 对象，因此你也可以在 <code>window</code> 上监听这个事件。这些事件稍微复杂一点，一会我们会再讨论它们。</p>
<p>当浏览器遇到外部资源，比如 JavaScript 脚本文件，用 <code>&lt;link&gt;</code> 导入的 CSS 文件，一个 <code>&lt;img&gt;</code> 元素导入的图片或其他外部资源，浏览器会在后台开始下载对应的文件。这个过程不会影响<strong>主线程</strong>。</p>
<p><code>&lt;script&gt;</code> 元素会阻塞解析。浏览器对 DOM 的解析过程通常只会发生在<strong>主线程</strong>上。所以如果主线程忙碌，DOM 解析就会等待主线程释放。</p>
<h3 id="解析阻塞的脚本"><a href="#解析阻塞的脚本" class="headerlink" title="解析阻塞的脚本"></a>解析阻塞的脚本</h3><p><strong>解析阻塞脚本（Parser-blocking Scripts）</strong>是指 JavaScript 脚本代码阻止 HTML 的解析。当浏览器遇到内嵌的 <code>&lt;script&gt;</code> 元素，会<strong>优先执行</strong>脚本内容，然后再继续创建 DOM 树。所以所有内嵌到 HTML 的脚本都属于解析阻塞脚本。如果 <code>&lt;script&gt;</code> 元素是一个外部脚本文件，浏览器会在后台开始下载这个文件，但是依然会<strong>阻止主线程的执行</strong>直到文件下载结束。这意味着 DOM 树的解析过程在脚本文件下载完之前会一直等待。</p>
<p>一旦脚本文件下载完成，浏览器会首先在主线程执行这个脚本文件，接着继续 DOM 的解析过程。这个过程在浏览器遇到的每个 <code>&lt;script&gt;</code> 元素时都会重复一次。或许你要问为什么浏览器要等这些 JavaScript 文件下载和执行？浏览器公开 DOM API 给 JavaScript 意味着我们可以用 JavaScript 访问和操作 DOM 元素。如果浏览器要并行处理 DOM 树解析和脚本执行的话，也就是说有一个线程进行 DOM 解析，另一个线程执行脚本，这里就会出现一个<strong>竞态条件</strong>，因为解析和脚本执行都需要访问和修改 DOM 树。</p>
<p>不过，让 DOM 解析停止转而等待脚本文件的下载在大多数场景来说都是不必要的。因此 HTML5 给 <code>&lt;script&gt;</code> 添加了 <code>async</code> 属性告诉浏览器这个脚本文件在下载过程中不需要停止 DOM 解析，但是一旦脚本文件下载结束，还是会立即阻止 DOM 继续解析，优先执行这个脚本文件。</p>
<p>同时还有另一个魔法属性 <code>defer</code> 与其类似，浏览器在遇到脚本带有这个属性时不会停止 DOM 解析，但与 <code>async</code> 的不同之处在于文件下载完成之后也不会立即执行。所有 <code>defer</code> 属性的脚本将在浏览器解析完所有 HTML 元素，也就是 DOM 树创建完成之后，按照它们在 HTML 结构中出现的顺序依次执行。</p>
<p>总结：所有普通的脚本无论是内嵌到 HTML 中的还是引用外部文件的都是<strong>解析阻塞</strong>的，因为它们都会阻止继续构建 DOM 树。所有 <code>async</code> 脚本，也就是所谓的异步脚本在下载完成之前不会阻塞解析，但是一旦 <code>async</code> 脚本下载完成，它们就会变成解析阻塞脚本。然而，<code>defer</code> 脚本，也就是所谓的延迟执行脚本，是<strong>非解析阻塞</strong>的，它们在下载时不会阻塞 DOM 树的构建，下载完成后会等到 DOM 树创建完成之后才开始执行。</p>
<blockquote>
<p>💡 如果一个网页上存在 <code>async</code> 和 <code>defer</code> 脚本，网页加载后你可以在开发者工具的<strong>性能</strong>标签页观察到 <code>FP</code> 和 <code>FCP</code> 会非常靠近，因为浏览器不会等待脚本下载完成，而是继续解析 DOM 元素。但是 <code>LCP</code> 事件可能会与之前的事件有段间隔，这个间隔的期间 <code>async</code> 加载结束开始阻塞 DOM 树构建。</p>
<p>💡 <strong>解析阻塞</strong>也被引用为<strong>渲染阻塞</strong>，因为渲染在 DOM 树之后才会发生。不过两者之间有一定区别，在稍后我们会继续讨论它们。</p>
</blockquote>
<p>一些浏览器引入了<strong>推测解析（Speculative Parsing）</strong>的策略将 HTML 解析（并非 DOM 树构建）的过程卸载到独立的线程中完成，这让浏览器可以更早的读取到 CSS 文件、脚本文件、图片文件并且开始下载这些资源。</p>
<p>假如你有 3 个 <code>&lt;script&gt;</code> 依次存在于 HTML，浏览器在结束第一个脚本的加载和执行之前都不会去下载第二个脚本，因为浏览器这时还未读取到第二脚本。你可以给脚本添加 <code>async</code> 属性让浏览器同时开始 3 个脚本的下载，但是异步脚本不保证执行的顺序。也就是说先下载完的脚本会被优先执行。这时推测解析将起到作用，这个策略被称作推测解析的原因在于浏览器会推测资源在未来会被加载，所以最好现在就在后台去加载它们。</p>
<p>对于这个情况，推测解析会提前加载 3 个脚本，并且在他们需要执行的时候依次执行脚本。不过如果 JavaScript 操作 DOM 对外部资源进行移除或者隐藏操作的话，就会造成无效的推测，让提前加载的资源派不上用场。</p>
<blockquote>
<p>💡 每个浏览器都有自己的想法，所以推测解析什么时候发生和会不会发生都是无法保证的。不过你可以用 <code>&lt;link ref=&quot;preload&quot;&gt;</code> 要求浏览器预先加载某些需要的资源。</p>
</blockquote>
<h3 id="渲染阻塞的-CSS"><a href="#渲染阻塞的-CSS" class="headerlink" title="渲染阻塞的 CSS"></a>渲染阻塞的 CSS</h3><p>前面我们提到除了解析阻塞脚本以外，其他的外部资源请求不会阻塞 DOM 解析过程。因此，CSS 不会阻塞 DOM 解析吗？答案是否定的，CSS 会间接阻塞 DOM 解析。这里需要引入渲染过程。</p>
<p>浏览器引擎根据从服务器接收到的 HTML 文本创建 DOM 树。与之相同，浏览器从 HTML 中引入的 CSS 文件或内嵌的 CSS 样式内容中创建 CSSOM 树。DOM 树和 CSSOM 树的创建<strong>同时</strong>发生在主线程上。由它们共同组成的 <strong>Render-Tree</strong> 在 DOM 树构建完成后也会开始增量式地构建。</p>
<p>我们有提到 DOM 树的生成是<strong>增量式</strong>的，也就是说浏览器读取 HTML 后会将新的 DOM 元素添加到 DOM 树上。但是 CSSOM 树不是这个套路。CSSOM 树<strong>无法做到增量式</strong>构建，其必须以特定的方式构建。原因也很简单，因为 CSS 的内容没有嵌套关系，CSS 文件中最后一行的设定有可能覆盖其第一行的设定。如果浏览器按照增量式的创建 CSSOM 树，就有可能由于后面遇到的 CSS 属性<strong>覆盖</strong>了前面的设定，导致同一个 CSSOM 节点更新了多次，其这个更新行为会造成 <strong>Render-Tree</strong> 多次渲染，其最直接的结果就是让用户看到屏幕上的内容因为 CSS 的解析过程一直发生样式的改变，最终变成糟糕的用户体验。由于 CSS 样式属于<strong>层叠式</strong>的，一个规则的变化可能影响到很多元素，增量式创建 CSSOM 树很大可能会造成这种后果。</p>
<p>因此 CSSOM 树只会在所有 CSS 规则都处理完之后被更新。而一旦 CSSOM 树更新完，接着就会去更新 <strong>Render-Tree</strong> 将结果渲染到屏幕上。</p>
<p>所以 CSS 是渲染阻塞资源。一旦浏览器请求了外部样式表，<strong>Render-Tree</strong> 的构建就会被停止。这会导致<strong>关键渲染路径</strong>卡住，屏幕上不会渲染任何内容。但是 DOM 树的构建不受影响，在 CSS 文件下载过程中会继续构建过程。</p>
<p>浏览器如果在 HTML 增量式解析到足够开始向屏幕渲染东西时就使用 CSSOM 树的某个时间点的状态来生成 Render-Tree 的话，会有一个巨大的弊端，这种情况一旦 CSS 下载完并解析后，CSSOM 就会被更新，这会让 Render-Tree 同步更新造成重绘，最终导致无样式的元素闪烁，带来很糟糕的用户体验。</p>
<p>因此浏览器在 CSS 文件下载和解析结束之前会一直等待。一旦样式解析了，CSSOM 得到更新，Render-Tree 同步更新，然后关键渲染路径解锁，让 Render-Tree 在屏幕上开始绘制元素。也正因如此，外部 CSS 越早加载越好，通常在 <code>head</code> 标签内加载最好。</p>
<p>让我们来设想这样一个场景。浏览器开始解析 HTML 了，它遇到一个外部 CSS 文件。浏览器阻塞关键渲染路径，开始在后台下载这个文件，然后继续 DOM 解析。但是当浏览器遇到 <code>&lt;script&gt;</code> 标签，它阻塞 DOM 解析，开始下载外部脚本文件。现在浏览器主线程空闲，等待 CSS 文件和 JS 文件的下载。</p>
<p>这时，外部 JS 文件下载结束了，但是 CSS 文件仍然在后台继续下载。浏览器应该开始执行这个脚本文件吗？继续执行的话会造成什么弊端？</p>
<p>浏览器通过在 DOM 元素上暴露 <code>style</code> 对象提供一套操作 CSSOM 的高级 API 让 JavaScript 可以对其进行操作。比如你可以读取和修改 <code>elem.style.backgroundColor</code> 属性来获取和修改元素的背景色。</p>
<p>如果 CSS 仍然在后台下载，但 JavaScript 不受影响可以在主线程开始执行的话，这时我们通过 JavaScript 访问 DOM 元素的 CSS 属性，将会得到 CSSOM 当前状态下的值。一旦 CSS 下载解析结束，造成 CSSOM 更新，我们之前拿到的值就已经不是最新的值了。基于这个原因，在 CSS 还在下载时开始执行 JavaScript 脚本是不安全的。</p>
<p>根据 HTML5 规格，浏览器可以下载脚本文件，但是在之前出现的所有 CSS 文件解析结束之前都不应该开始执行脚本。而 CSS 文件阻塞脚本的执行时，这个文件就变成了<strong>脚本阻塞 CSS</strong> 了。</p>
<blockquote>
<p>💡 <code>&lt;script&gt;</code> 标签有 <code>async</code> 和 <code>defer</code> 属性告诉浏览器<strong>不要阻塞解析</strong>，外部 CSS 文件也可以使用 <code>media</code> 属性告诉浏览器<strong>不要阻塞渲染</strong>。浏览器会根据 <code>media</code> 属性的值来智能的决定何时加载这个 CSS。</p>
</blockquote>
<h3 id="document-的-DOMContentLoaded-事件"><a href="#document-的-DOMContentLoaded-事件" class="headerlink" title="document 的 DOMContentLoaded 事件"></a>document 的 <code>DOMContentLoaded</code> 事件</h3><p><code>DOMContentLoaded</code> （<strong>DCL</strong>）事件表示浏览器读取完了 HTML，并且完成了 DOM 树的创建。不过有很多因素会改变 <code>DCL</code> 事件发生的时间点。</p>
<p>假如我们的 HTML 不存在任何脚本，DOM 解析过程就不会被阻塞，<code>DCL</code> 事件会在浏览器解析完整个 HTML 后立即发生。不过如果 HTML 中存在任何解析阻塞的脚本，<code>DCL</code> 会在所有这些脚本下载执行结束之后发生。</p>
<p>当把 CSS 文件纳入考虑的范围时，事情就更加复杂了。就算 HTML 没有任何外部脚本，<code>DCL</code> 仍然会等到 CSS 加载结束才会发生。原因在于 <code>DCL</code> 表示 DOM 树准备好了，但是如果 CSSOM 没有构建完成，任何对 DOM 元素的 CSS 信息的访问都是不安全的。因此大部分浏览器会等待所有外部 CSS 文件的加载和解析。</p>
<p>结果就是脚本阻塞的 CSS 显然会推迟 <code>DCL</code> 事件。DOM 树在 CSS 加载完成之前不会构建结束。</p>
<p><code>DCL</code> 是网站性能指标之一，对其的优化目标是越早出现越好。最佳实践其一是尽可能给 <code>&lt;script&gt;</code> 设定 <code>defer</code> 或 <code>async</code> 属性让其不要阻塞 HTML 的解析，其二是优化<strong>脚本阻塞</strong>和<strong>渲染阻塞</strong>的 CSS。</p>
<h3 id="window-的-load-事件"><a href="#window-的-load-事件" class="headerlink" title="window 的 load 事件"></a>window 的 <code>load</code> 事件</h3><p>JavaScript 会阻塞 DOM 树的生成，而 CSS 和图片、视频等外部文件不会阻塞。<code>DOMContentLoaded</code> 事件标记 DOM 树完全创建完成并且可以安全访问的时间点，<code>window.onload</code> 则标记外部 CSS 和文件都下载完成，应用结束所有下载的时间点。</p>
<blockquote>
<p>✏️ 这里本来应该还有一个例子，准备一个网页加载几个 JS、CSS 和一些图片，然后看看 Performance 下 <code>FP</code>，<code>FCP</code>，<code>DCL</code> 以及 <code>load</code> 事件发生的顺序和时机。然后观察 3 个 JS 分别需要 3 秒、6 秒和 9 秒下载，按照浏览器读取 HTML 的顺序一共需要 <strong>18 秒</strong>来完成下载，但是又发现浏览器采用了<strong>推测解析</strong>的方法提前下载了 JS 文件，最终下载脚本的时间只用了 <strong>9 秒</strong>。然后第 <strong>9.1</strong> 秒 <code>DCL</code> 发生了。这时还有一些图片文件还在下载，到了第 10 秒它们都下载结束了，第 <strong>10.2 秒</strong> window 上 <code>load</code> 事件发生了。到此为止页面加载结束了。</p>
</blockquote>
<p>后来又觉得没有必要了，你现在看的网页就是一个很好的例子，你可以打开开发者控制台，切到性能标签页，点击标签页左上角的刷新图标，等页面加载结束，再观察一下各种事件发生的情况吧！</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>这篇文章主要对下面资料进行了整理和翻译。</p>
<ul>
<li><a href="https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969">How the browser renders a web page? — DOM, CSSOM, and Rendering</a></li>
</ul>
<p>下面是一些拓展资料。</p>
<ul>
<li><a href="https://medium.com/@mustafa.abdelmogoud/how-the-browser-renders-html-css-27920d8ccaa6">How the browser renders HTM &amp; CSS</a></li>
<li><a href="https://www.w3schools.com/jsref/prop_node_nodetype.asp">HTML DOM nodeType Property</a></li>
<li><a href="https://css-tricks.com/an-introduction-and-guide-to-the-css-object-model-cssom/">An Introduction and Guide to the CSS Object Model (CSSOM)</a></li>
<li><a href="https://developers.google.com/web/updates/2018/03/cssom">Working with the new CSS Typed Object Model</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing">Avoid Large, Complex Layouts and Layout Thrashing</a></li>
<li><a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3">Inside look at modern web browser (part 3) </a></li>
</ul>
]]></content>
      <categories>
        <category>study</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Browser</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 语法标准整理 - ES6 及以后版本</title>
    <url>/post/study/js/JavaScript-Specifications-ES6-and-beyond/</url>
    <content><![CDATA[<p>我们通常说的 JavaScript 其实指的是 ECMAScript 的子集。JavaScript 遵从 ECMAScript 定义的语言标准提供接口，但是内部实现则完全取决于运行环境。根据 ECMAScript 规格实现的语言还有 ActionScript、JScript 等等。这些实现了同一个规范的语言可以类比做使用了同一种引擎的不同汽车，每辆车的外观都不尽相同，而每种语言都有其独特的风格。</p>
<p>ECMAScript 是 Netscape 的 Brendan Eich 所开发的一个脚本语言的标准化规格，这个脚本语言最初叫 Mocha，随后改名为 LiveScript，最后改名为我们熟知的 JavaScript。可以说 ECMAScript 就是当时的 “JavaScript”，但是因为种种原因这个名称没能保留下来，我们现在经常使用的 JavaScript 主要是各浏览器实现的版本。</p>
<p>ECMAScript 的作用在于定义 JavaScript 语言的核心标准和 API，经过多个版本的迭代之后，ECMAScript 如今稳定每一年会发布一个新版本，给 JavaScript 添加一些新的语言特性以及改善。这篇文章将主要讨论 ECMAScript 第 6 个版本（即 ES6）及往后版本中推出的新特性和推出这些特性的缘由。</p>
<blockquote>
<p>内容包括<strong>更新时间截止</strong>的所有已添加的特性。</p>
</blockquote>
<span id="more"></span>

<h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><p>ECMAScript 也叫 ECMA-262，是 JavaScript 的语言规范。下面是截止本文更新时间 ECMAScript 的版本列表。整体上来说，ECMAScript 在 ES3 为止都是对初版的修补，但到了第 4 版（ES4）时，由于提案的很多特性的引入会导致与先前版本的不兼容，被 Netscape、Mozilla 和微软等方面指责为“breaking the web”。随后雅虎、微软和谷歌牵头构成了工作小组在 ES3 的基础上做了一些安全方面、库的更新方面的工作，并且着重强调了兼容性。这两个小组并行工作了一段时间后做出了妥协，ES4 的版本被废止，后来的这个版本作为 ES5 发布。ES4 中的部分特性在 ES6 以后得到引入。并且从 ES6 开始，ECMAScript 每一年会发布一个新版本，添加一些新特性和做出一些改善。</p>
<table>
<thead>
<tr>
<th>Edition</th>
<th>Date Published</th>
<th>Name</th>
<th>Changes</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1997 年 6 月</td>
<td></td>
<td>初版</td>
</tr>
<tr>
<td>2</td>
<td>1998 年 6 月</td>
<td></td>
<td>修改以符合 ISO/IEC 16262 国际标准</td>
</tr>
<tr>
<td>3</td>
<td>1999 年 12 月</td>
<td></td>
<td>加入正则表达式、更好的字符串处理、新的流程控制语句、Try Catch 异常处理、更细致的 Errors 定义、数值输出以及其他改善。</td>
</tr>
<tr>
<td>4</td>
<td>（废弃）2003 年 6 月</td>
<td></td>
<td>由于语言复杂度上的策略分歧而被分歧，其中的部分提案被完全抛弃，另一部分在第 6 版中发布。</td>
</tr>
<tr>
<td>5</td>
<td>2009 年 12 月</td>
<td>ECMAScript 2015 (ES2015)</td>
<td>加入严格（<code>strict</code>）模式；解决了第 3 版中的很多模糊定义，并且包容与规格有所不同的实际语言实现；添加了 setter 和 getter、JSON 支持以及更加完整的对象属性的反射。</td>
</tr>
<tr>
<td>5.1</td>
<td>2011 年 6 月</td>
<td></td>
<td>修改以符合 ISO/IEC 16262:2011 国际标准</td>
</tr>
<tr>
<td>6</td>
<td>2015 年 6 月</td>
<td>ECMAScript 2016 (ES2016)</td>
<td>*见下文</td>
</tr>
<tr>
<td>7</td>
<td>2016 年 6 月</td>
<td>ECMAScript 2016 (ES2016)</td>
<td>*见下文</td>
</tr>
<tr>
<td>8</td>
<td>2017 年 6 月</td>
<td>ECMAScript 2017 (ES2017)</td>
<td>*见下文</td>
</tr>
<tr>
<td>9</td>
<td>2018 年 6 月</td>
<td>ECMAScript 2018 (ES2018)</td>
<td>*见下文</td>
</tr>
<tr>
<td>10</td>
<td>2019 年 6 月</td>
<td>ECMAScript 2019 (ES2019)</td>
<td>*见下文</td>
</tr>
<tr>
<td>11</td>
<td>2020 年 6 月</td>
<td>ECMAScript 2020 (ES2020)</td>
<td>*见下文</td>
</tr>
<tr>
<td>12</td>
<td>2021 年 6 月</td>
<td>ECMAScript 2021 (ES2021)</td>
<td>*见下文</td>
</tr>
</tbody></table>
<h3 id="脚本引擎的支持情况"><a href="#脚本引擎的支持情况" class="headerlink" title="脚本引擎的支持情况"></a>脚本引擎的支持情况</h3><p>ECMA 国际标准化组织为 ECMAScript 语言规格开发了一套测试代码集 Test262，用来检验每一种 JavaScript 实现遵守语言标准的程度。下面是目前为止各个主流的脚本引擎对新语言特性的支持情况。可见对于主流浏览器来说，就算是最新推出的语言标准也能得到快速适配。</p>
<blockquote>
<p>数据来自<a href="https://en.wikipedia.org/wiki/ECMAScript#Conformance">维基百科</a>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Scripting engine</th>
<th>Reference application(s)</th>
<th>ES5</th>
<th>ES6 (2015)</th>
<th>ES7 (2016)</th>
<th>Newer (2017+)</th>
</tr>
</thead>
<tbody><tr>
<td>Chakra</td>
<td>Microsoft Edge 18</td>
<td>100%</td>
<td>96%</td>
<td>100%</td>
<td>33%</td>
</tr>
<tr>
<td>SpiderMonkey</td>
<td>Firefox 79</td>
<td>100%</td>
<td>98%</td>
<td>100%</td>
<td>100%</td>
</tr>
<tr>
<td>V8</td>
<td>Google Chrome 84, Microsoft Edge 84, Opera 70</td>
<td>100%</td>
<td>98%</td>
<td>100%</td>
<td>100%</td>
</tr>
<tr>
<td>JavaScriptCore</td>
<td>Safari 13.1</td>
<td>99%</td>
<td>99%</td>
<td>100%</td>
<td>84%</td>
</tr>
</tbody></table>
<h3 id="ES12（ES2021）"><a href="#ES12（ES2021）" class="headerlink" title="ES12（ES2021）"></a>ES12（ES2021）</h3><h4 id="字符串实例：-replaceAll"><a href="#字符串实例：-replaceAll" class="headerlink" title="字符串实例：.replaceAll()"></a>字符串实例：<code>.replaceAll()</code></h4><p>或许你注意到 JavaScript 中的字符串实例上的置换方法一次只能替换一个值。现在可以一次置换所有匹配值了。方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str =</span><br><span class="line">  <span class="string">&quot;ES2021 was published in June 2021, and ES2020 was published in June 2020&quot;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">str.replace(<span class="string">&quot;2020&quot;</span>, <span class="string">&quot;11&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;ES2021 was published in June 2021, and ES11 was published in June 2020&quot;</span></span><br><span class="line">str.replaceAll(<span class="string">&quot;2021&quot;</span>, <span class="string">&quot;2019&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;ES2019 was published in June 2019, and ES2020 was published in June 2020&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise .any()"></a>Promise <code>.any()</code></h4><p>Promise 机制中有几个 API 用来处理一系列 Promise 的结果，ES2021 添加了 <code>.any()</code> 方法，有些类似于 <code>.race()</code>，但是不会再发生错误时立刻中止。基本覆盖了所有使用场景。</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>promise.all([p1, p2, p3])</code></td>
<td>等待所有 promise 完成，在发生错误时中止</td>
</tr>
<tr>
<td><code>promise.race([p1, p2, p3])</code></td>
<td>等待直到第一个 promise 完成或发生错误</td>
</tr>
<tr>
<td><code>promise.allSettled([p1, p2, p3])</code></td>
<td>等待所有 promise 完成</td>
</tr>
<tr>
<td><code>promise.any([p1, p2, p3])</code></td>
<td>等待直到第一个 promise 完成，无视发生的错误</td>
</tr>
</tbody></table>
<h4 id="逻辑赋值运算符-Logical-Assignment-Operator"><a href="#逻辑赋值运算符-Logical-Assignment-Operator" class="headerlink" title="逻辑赋值运算符 Logical Assignment Operator"></a>逻辑赋值运算符 Logical Assignment Operator</h4><p>逻辑赋值运算符让以往的写法更加简洁易读。参考下面的代码例子。算是语法糖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以往的写法</span></span><br><span class="line">a || (a = <span class="string">&quot;default&quot;</span>);</span><br><span class="line"><span class="comment">// 使用逻辑赋值运算符</span></span><br><span class="line">a ||= <span class="string">&quot;default&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>可以做逻辑赋值的运算符如下。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>||=</code></td>
<td>左边为 <code>falsy</code> 时赋值，<code>false</code>、<code>0</code>、<code>&quot;&quot;</code> 都属于 <code>falsy</code></td>
</tr>
<tr>
<td><code>&amp;&amp;=</code></td>
<td>左边为 <code>truthy</code> 时赋值，非 <code>falsy</code> 的值都属于 <code>truthy</code></td>
</tr>
<tr>
<td><code>??=</code></td>
<td>左边为 <code>nullish</code> 时赋值，<code>null</code> 和 <code>undefined</code> 属于 <code>nullish</code></td>
</tr>
</tbody></table>
<h4 id="数值分隔符-Numerical-Separator"><a href="#数值分隔符-Numerical-Separator" class="headerlink" title="数值分隔符 Numerical Separator"></a>数值分隔符 Numerical Separator</h4><p>数值中添加下划线进行分隔，提高数值的可读性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> billion = <span class="number">1_000_000_000</span>;</span><br></pre></td></tr></table></figure>

<h4 id="WeakRef-amp-Finalization-Registry"><a href="#WeakRef-amp-Finalization-Registry" class="headerlink" title="WeakRef &amp; Finalization Registry"></a>WeakRef &amp; Finalization Registry</h4><p><code>WeakRef</code> 会创建一个对象的弱引用，这种引用不会影响对象被垃圾回收（GC），如果目标对象不存在弱引用以外的引用的话，在脚本引擎执行垃圾回收时会销毁该对象。</p>
<p>弱引用在处理大文件缓存和映射的场景时比较有用，比如有一组图片文件，你想给每个图片进行命名但又不希望名称的映射让其无法被垃圾回收机制销毁，这时使用弱引用可以满足这个需求。用弱引用将字符串与图片一一绑定，而图片在不再被使用时会随时被 GC。</p>
<blockquote>
<p>不过也因为弱引用的目标对象可能随时被 GC，使用时需要慎重考虑。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An object to reference weakly</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">favColor</span>: <span class="string">&quot;pink&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// creating a WeakRef of this object</span></span><br><span class="line"><span class="keyword">const</span> weakRefObj = <span class="keyword">new</span> WeakRef(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// To read the weak ref object</span></span><br><span class="line"><span class="keyword">const</span> weakRefInstance = weakRefObj.deref();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(weakRefInstance.age);</span><br><span class="line"><span class="comment">// Output: 18</span></span><br></pre></td></tr></table></figure>

<p>Finalization Registry 是配合 <code>WeakRef</code> 使用的一个机制。<strong>Finalization</strong> 指的是一个对象不再使用后执行清除操作的过程。而 Finalization Registry 本质上就是一个对象被 GC 之后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create a registry</span></span><br><span class="line"><span class="keyword">const</span> registry = <span class="keyword">new</span> FinalizationRegistry(<span class="function">(<span class="params">heldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Do something here</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register any objects you want a cleanup callback for</span></span><br><span class="line">registry.register(theObject, <span class="string">&quot;some value&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="ES11（ES2020）"><a href="#ES11（ES2020）" class="headerlink" title="ES11（ES2020）"></a>ES11（ES2020）</h3><h4 id="全局对象-globalThis"><a href="#全局对象-globalThis" class="headerlink" title="全局对象 globalThis"></a>全局对象 <code>globalThis</code></h4><p>在浏览器中 <code>globalThis</code> 实际指向 <code>window</code> 对象，但是 Worker 中我们无法直接使用全局对象，而是需要通过 <code>self</code> 访问，这造成在对不同程序进行开发时全局对象的名称不同。为了解决这个问题，ES2020 引入了 <code>globalThis</code> 统一了每个环境下的全局对象名称。</p>
<h4 id="新数据类型：BigInt"><a href="#新数据类型：BigInt" class="headerlink" title="新数据类型：BigInt"></a>新数据类型：<code>BigInt</code></h4><p>JavaScript 中的 <code>Number</code> 类型数据以双精度 64 位浮点数（float64）表示，这表示其对整数值来说只保证能正确显示 -2^53 ～ 2^53 的值。</p>
<blockquote>
<p>From Wikipedia</p>
<ul>
<li>Integers from −253 to 253 (−9,007,199,254,740,992 to 9,007,199,254,740,992) can be exactly represented</li>
<li>Integers between 253 and 254 = 18,014,398,509,481,984 round to a multiple of 2 (even number)</li>
<li>Integers between 254 and 255 = 36,028,797,018,963,968 round to a multiple of 4</li>
</ul>
</blockquote>
<p>看下面的例子，我们先拿到能保证安全操作的最大数字，然后尝试对比这个值加 1 和加 2 的结果，你会发现结果是 <code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">num;</span><br><span class="line"><span class="comment">// 9007199254740991</span></span><br><span class="line">num + <span class="number">1</span> === num + <span class="number">2</span>;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>ES2020 中引入了 <code>BigInt</code> 数据类型来处理任意长度的数字，你可以使用其构造函数声明，也可以在数字后添加后缀 <code>n</code> 实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="built_in">BigInt</span>(<span class="built_in">Number</span>.MAX_SAFE_INTEGER);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">num;</span><br><span class="line"><span class="comment">// 9007199254740991n</span></span><br><span class="line">num + <span class="number">1n</span> === num + <span class="number">2n</span>;</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>BigInt</code> 使用时需要注意下面限制：</p>
<ul>
<li><code>BigInt</code> 不能直接与 <code>Number</code> 进行运算；</li>
<li><code>BigInt</code> 可以与 <code>Number</code> 进行比较，但严格比较（<code>===</code>）就算字面量相等也会返回 <code>false</code>；</li>
<li>由于一元加号运算符（<code>+</code>）在 JavaScript 中存在隐式数值转换，<code>BigInt</code> 使用 <code>+1n</code> 的形式表达时会报类型转换错误；</li>
<li><code>BigInt</code> 与 <code>Number</code> 之间换算会损失精度，使用时需要避免频繁换算；</li>
<li><code>BigInt</code> 的运算非常量时间，不适合用于密码学计算。</li>
</ul>
<h4 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise .allSettled()"></a>Promise <code>.allSettled()</code></h4><p>新的 Promise 方法。等待到所有 Promise 都结束后触发。适合等待所有依赖都完成后立即执行的场景。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve());</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">200</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled([p1, p2]).then(<span class="function">(<span class="params">res</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(res.map(<span class="function">(<span class="params">a</span>) =&gt;</span> a.status))</span><br><span class="line">);</span><br><span class="line"><span class="comment">// (2) [&quot;fulfilled&quot;, &quot;rejected&quot;]</span></span><br></pre></td></tr></table></figure>

<h4 id="空值结合运算符-Nullish-Coalescing-Operator"><a href="#空值结合运算符-Nullish-Coalescing-Operator" class="headerlink" title="空值结合运算符 Nullish Coalescing Operator"></a>空值结合运算符 Nullish Coalescing Operator</h4><p>首先要解释 <strong>Nullish</strong>，在 JavaScript 中 <code>undefined</code> 和 <code>null</code> 属于 <strong>Nullish</strong>，空值结合运算符的意义在于判断变量是否是空值（Nullish），如果是的话则返回右边的值，通常用来做默认值赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对比 `||` 运算符，只要左边是 falsy 就返回右边的的结果</span></span><br><span class="line"><span class="literal">undefined</span> || <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="comment">// &quot;some string&quot;</span></span><br><span class="line"><span class="literal">null</span> || <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="comment">// &quot;some string&quot;</span></span><br><span class="line"><span class="literal">false</span> || <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="comment">// &quot;some string&quot;</span></span><br><span class="line"><span class="number">0</span> || <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="comment">// &quot;some string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空值结合运算符 `??`，仅在 nullish 时返回右边的的结果</span></span><br><span class="line"><span class="literal">undefined</span> ?? <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="comment">// &quot;some string&quot;</span></span><br><span class="line"><span class="literal">null</span> ?? <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="comment">// &quot;some string&quot;</span></span><br><span class="line"><span class="literal">false</span> ?? <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> ?? <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h4 id="可选链运算符-Optional-Chaining-Operator"><a href="#可选链运算符-Optional-Chaining-Operator" class="headerlink" title="可选链运算符 Optional Chaining Operator"></a>可选链运算符 Optional Chaining Operator</h4><p>可选链运算符在链式调用中处理空值非常有用，可以完美避免空指针问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">info</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">17</span> &#125; &#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">obj?.info?.name;</span><br><span class="line"><span class="comment">// &quot;John&quot;</span></span><br><span class="line">obj?.any?.name;</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="ES10（ES2019）"><a href="#ES10（ES2019）" class="headerlink" title="ES10（ES2019）"></a>ES10（ES2019）</h3><h4 id="数组实例：-flat-和-flatMap"><a href="#数组实例：-flat-和-flatMap" class="headerlink" title="数组实例：.flat() 和 .flatMap()"></a>数组实例：<code>.flat()</code> 和 <code>.flatMap()</code></h4><p>ES2019 给数组添加了扁平化方法 <code>.flat(depth=1)</code>，这个方法接收一个参数 <code>depth</code> 表示需要提取的嵌套层数，默认为 1 层。这个方法会返回新的数组，不会影响原数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认只提取一层嵌套数组进行扁平化</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>, [<span class="number">8</span>], <span class="number">9</span>], <span class="number">10</span>]].flat();</span><br><span class="line"><span class="comment">// (7) [1, 2, 3, 4, 5, Array(4), 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以指定层数，或者使用 `Infinity` 表示提取所有嵌套层数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>, [<span class="number">8</span>], <span class="number">9</span>], <span class="number">10</span>]].flat(<span class="literal">Infinity</span>);</span><br><span class="line"><span class="comment">// (10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>

<p>ES2019 还给数组添加了另一个方法 <code>.flatMap(func[, thisArg])</code>，这个方法与 <code>.map()</code> 类似，但是会将返回的数组结果进行扁平化。同 <code>.map()</code> 一样，这个方法会返回新的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">&quot;it&#x27;s Sunny in&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;California&quot;</span>];</span><br><span class="line"></span><br><span class="line">arr1.map(<span class="function">(<span class="params">x</span>) =&gt;</span> x.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">// [[&quot;it&#x27;s&quot;,&quot;Sunny&quot;,&quot;in&quot;],[&quot;&quot;],[&quot;California&quot;]]</span></span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> x.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">// [&quot;it&#x27;s&quot;,&quot;Sunny&quot;,&quot;in&quot;, &quot;&quot;, &quot;California&quot;]</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串实例：-trimStart-和-trimEnd"><a href="#字符串实例：-trimStart-和-trimEnd" class="headerlink" title="字符串实例：.trimStart() 和 .trimEnd()"></a>字符串实例：<code>.trimStart()</code> 和 <code>.trimEnd()</code></h4><p>字符串的新方法 <code>.trimStart()</code> 和 <code>.trimEnd()</code> 执行如字面意思相同的处理，算是语法糖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;    hello!    &quot;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">str.trimStart();</span><br><span class="line"><span class="comment">// &quot;hello!    &quot;</span></span><br><span class="line">str.trimEnd();</span><br><span class="line"><span class="comment">// &quot;    hello!&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="ES9（ES2018）"><a href="#ES9（ES2018）" class="headerlink" title="ES9（ES2018）"></a>ES9（ES2018）</h3><h4 id="扩展运算符-Spread-Operator"><a href="#扩展运算符-Spread-Operator" class="headerlink" title="扩展运算符 Spread Operator"></a>扩展运算符 Spread Operator</h4><p>ES2018 引入了针对对象的扩展运算符。扩展运算符之前只能对数组使用，现在也能对对象进行方便的复制和合并。对对象使用时类似 <code>Object.assign()</code> 的效果，但是扩展运算符不会调用属性的 setter 而 <code>Object.assign()</code> 会。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> c = [...a, <span class="number">3.5</span>, ...b];</span><br><span class="line"><span class="comment">// (7) [1, 2, 3, 3.5, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">17</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> result = &#123; ...obj, <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// &#123;name: &quot;John&quot;, age: 17, gender: &quot;male&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Rest-参数"><a href="#Rest-参数" class="headerlink" title="Rest 参数"></a>Rest 参数</h4><p>扩展运算符用在方法参数上有相反的效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;many&quot;</span>, <span class="string">&quot;args&quot;</span>, <span class="string">&quot;here&quot;</span>);</span><br><span class="line"><span class="comment">// (3) [&quot;many&quot;, &quot;args&quot;, &quot;here&quot;]</span></span><br></pre></td></tr></table></figure>

<h4 id="异步迭代-Asynchronous-Iteration"><a href="#异步迭代-Asynchronous-Iteration" class="headerlink" title="异步迭代 Asynchronous Iteration"></a>异步迭代 Asynchronous Iteration</h4><p>我们知道对象是不能用 <code>for of</code> 语句遍历的，因为这个语句会调用目标的迭代器来完成便利。ES2015 引入的迭代器让我们通过给对象定义迭代器 Symbol 后可以对其使用迭代方法 <code>next()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iterableObject = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">17</span>,</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">this</span>) <span class="keyword">yield</span> <span class="built_in">this</span>[key];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = iterableObject[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// &#123;value: &quot;John&quot;, done: false&#125;</span></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// &#123;value: 17, done: false&#125;</span></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>在 ES2018 中添加了<strong>异步迭代去</strong>，与普通迭代器返回一个包含 <code>value</code> 和 <code>done</code> 的对象不同，异步迭代器返回 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iterableObject = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">17</span>,</span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">this</span>) <span class="keyword">yield</span> <span class="built_in">this</span>[key];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = iterableObject[<span class="built_in">Symbol</span>.asyncIterator]();</span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// Promise &#123;&lt;fulfilled&gt;: &#123;…&#125;&#125;</span></span><br><span class="line">it.next().then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="comment">// &#123;value: 17, done: false&#125;</span></span><br><span class="line">it.next().then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>与此配套还有 <code>for await of</code> 循环语句可以用来迭代异步生成器和异步函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iterableObject = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">17</span>,</span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">this</span>) <span class="keyword">yield</span> <span class="built_in">this</span>[key];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> x <span class="keyword">of</span> iterableObject) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// John</span></span><br><span class="line"><span class="comment">// 17</span></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise .finally()"></a>Promise <code>.finally()</code></h4><p>这是 Promise 的新方法，类似 <code>try catch</code> 语句中的 <code>finally</code> 语句。以前我们想执行一些 cleanup 操作需要将逻辑分别写在 <code>.then()</code> 和 <code>.catch()</code> 中，现在可以统一在 <code>.finally()</code> 中了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(API)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* clean up */</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="正则表达式的更新"><a href="#正则表达式的更新" class="headerlink" title="正则表达式的更新"></a>正则表达式的更新</h4><p>ES2018 对正则表达式做出了一些更新，让 JavaScript 对字符串的处理能力进一步提升。</p>
<p>ES2018 添加了 <strong>Unicode 属性转义</strong>，可以使用 <code>\p&#123;PropertyName&#125;</code> 和 <code>\P&#123;PropertyName&#125;</code> 分别表示匹配的结果匹配或者不匹配某个 Unicode 属性，要注意使用这两个转义符时需要配合使用正则修饰符 <code>u</code> 声明处理 Unicode。Unicode 属性多种多样，所以这个特性的添加实际上很有用处，比如以往我们想要匹配汉字字符时会使用 Unicode 的码点范围来判断，但是随着汉字字符的增加，码点的范围也在不断扩大。现在可以通过下面这个属性 <code>Unified_Ideograph</code> 来判断了，这样这个正则就不需要维护了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/^\p&#123;Unified_Ideograph&#125;+$/u.test(<span class="string">&quot;这是汉字吗&quot;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="regexp">/^\P&#123;Unified_Ideograph&#125;+$/u</span>.test(<span class="string">&quot;这是汉字吗&quot;</span>);</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unified_Ideograph 指表意文字，匹配中日韩越多汉字</span></span><br><span class="line"><span class="comment">// 这个属性外还有些属性可以针对匹配汉字，但是在范围上有一定差异</span></span><br><span class="line"><span class="regexp">/^\p&#123;Ideographic&#125;+$/u</span>.test(<span class="string">&quot;这是汉字吗&quot;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="regexp">/^\p&#123;Script=Han&#125;+$/u</span>.test(<span class="string">&quot;这是汉字吗&quot;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="regexp">/^\p&#123;Script_Extensions=Han&#125;+$/u</span>.test(<span class="string">&quot;这是汉字吗&quot;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>ES2018 还给正则添加了<strong>具名捕获分组</strong>的特性。在之前获取分组内的数据只能通过下标完成，这会造成修改正则表达式的分组顺序将造成取值逻辑的修改。现在我们可以给分组命名获取数据了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="regexp">/^(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)$/</span>.exec(</span><br><span class="line">  <span class="string">&quot;2021-09-10&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result.groups.year, result.groups.month, result.groups.day);</span><br><span class="line"><span class="comment">// 2021 09 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名捕获分组可以用对象结构给变量赋值</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">groups</span>: &#123; year, month &#125;,</span><br><span class="line">&#125; = <span class="regexp">/^(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)$/</span>.exec(<span class="string">&quot;2021-09&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Year: <span class="subst">$&#123;year&#125;</span>, Month: <span class="subst">$&#123;month&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// Year: 2021, Month: 09</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名捕获分组也可以在字符串替换中使用</span></span><br><span class="line"><span class="string">&quot;2021/09&quot;</span>.replace(<span class="regexp">/^(?&lt;y&gt;\d&#123;4&#125;)\/(?&lt;m&gt;\d&#123;2&#125;)$/</span>, <span class="string">&quot;Year: $&lt;y&gt;, Month: $&lt;m&gt;!&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;Year: 2021, Month: 09!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名捕获分组可以使用 \k 转义符进行引用，来判断之前被捕获的内容是否重复出现</span></span><br><span class="line"><span class="regexp">/^(?&lt;var&gt;\d&#123;4&#125;)\?\k&lt;var&gt;\!$/</span>.test(<span class="string">&quot;2021?2021!&quot;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="regexp">/^(?&lt;var&gt;\d&#123;4&#125;)\?\k&lt;var&gt;\!$/</span>.test(<span class="string">&quot;2021?2022!&quot;</span>);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>dotAll</strong> 模式。点（<code>.</code>）在正则中匹配所有字符，但是有 4 个字符除外，分别是 <code>\n</code>、<code>\r</code>、<code>U+2028</code>（行分隔符）、<code>U+2029</code>（段分隔符）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般模式下点（.）不匹配换行</span></span><br><span class="line">/^.+$/.test(<span class="string">&quot;abc\ndef&quot;</span>);</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 s 修饰符使用 dotAll 模式，点将匹配换行</span></span><br><span class="line"><span class="regexp">/^.+$/</span>s.test(<span class="string">&quot;abc\ndef&quot;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>ES2018 还添加了<strong>后行断言</strong>特性。在此之前 JavaScript 中的正则只支持先行断言和先行否定断言，也就是说断言放在匹配字符的后面，比如要匹配百分号前面的数字。后行断言和后行否定断言则相反。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先行断言获取百分号前的数字</span></span><br><span class="line">/\d+(?=%)/.exec(<span class="string">&quot;Get the number part of 99%&quot;</span>);</span><br><span class="line"><span class="comment">// [&quot;99&quot;, index: 23, input: &quot;Get the number part of 99%&quot;, groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先行否定断言获取非百分比的数字</span></span><br><span class="line"><span class="regexp">/\d+(?!%)/</span>.exec(<span class="string">&quot;Guess you&#x27;ll get the 123 or the 99%?&quot;</span>);</span><br><span class="line"><span class="comment">// [&quot;123&quot;, index: 21, input: &quot;Guess you&#x27;ll get the 123 or the 99%?&quot;, groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后行断言获取美元符号后的数字</span></span><br><span class="line"><span class="regexp">/(?&lt;=\$)\d+/</span>.exec(<span class="string">&quot;Get the number part of $12345&quot;</span>);</span><br><span class="line"><span class="comment">// [&quot;12345&quot;, index: 24, input: &quot;Get the number part of $12345&quot;, groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后行否定断言获取非金额的数字</span></span><br><span class="line"><span class="regexp">/(?&lt;!\$)\d+/</span>.exec(<span class="string">&quot;Guess you&#x27;ll get the 123 or the $12345?&quot;</span>);</span><br><span class="line"><span class="comment">// [&quot;123&quot;, index: 21, input: &quot;Guess you&#x27;ll get the 123 or the $12345?&quot;, groups: undefined]</span></span><br></pre></td></tr></table></figure>

<h3 id="ES8（ES2017）"><a href="#ES8（ES2017）" class="headerlink" title="ES8（ES2017）"></a>ES8（ES2017）</h3><h4 id="异步操作：async-和-await"><a href="#异步操作：async-和-await" class="headerlink" title="异步操作：async 和 await"></a>异步操作：<code>async</code> 和 <code>await</code></h4><p>ES2017 引入了异步函数 （Async Functions）。其本质上是 Promise 和生成器的组合，以简化 Promise 的调用。异步函数的写法实际上就是用 <code>async</code> 和 <code>await</code> 代替了生成器函数的 <code>*</code> 和 <code>yield</code> 关键字。</p>
<p>与生成器需要执行函数 <code>next()</code> 和 <code>co</code> 模块执行不同。异步函数自带执行器，且自动返回 Promise。<code>async</code> 的主要作用是按照顺序完成操作，使用 Promise 和生成器同样能完成这一点，但是 Promise 需要大量的 Promise API 支持其完成处理，生成器也需要定义执行器去做真正的逻辑执行，而 <code>async</code> 的写法简化了生成器的执行器步骤，让逻辑更加简洁易读。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async 关键字表示函数内有异步操作</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getSomethingByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 异步获取条件</span></span><br><span class="line">  <span class="keyword">const</span> conditions = <span class="keyword">await</span> getSomeConditions(name);</span><br><span class="line">  <span class="comment">// 异步获取结果</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> getSomethingByConditions(conditions);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// await 等待函数执行结果时，如果遇到报错可以使用 try catch 处理</span></span><br><span class="line">  <span class="comment">// 如果不处理，将会转成 reject 状态反应在结果的 Promise 中</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> doSomethingSpecial();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 另一种处理报错的写法</span></span><br><span class="line">  <span class="keyword">await</span> doAnotherThing().catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async 函数返回 Promise</span></span><br><span class="line">getSomethingByName(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">  <span class="comment">// 可以接 .then() 添加回调函数</span></span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  <span class="comment">// 也可以接 .catch() 处理函数中的报错</span></span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>

<h4 id="Object-values-和-Object-entries"><a href="#Object-values-和-Object-entries" class="headerlink" title="Object.values() 和 Object.entries()"></a><code>Object.values()</code> 和 <code>Object.entries()</code></h4><p>ES2017 给 <code>Object</code> 添加了 2 个静态方法用来方便对象的便利。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">17</span>, <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.values(obj);</span><br><span class="line"><span class="comment">// (3) [&quot;John&quot;, 17, &quot;male&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.entries(obj);</span><br><span class="line"><span class="comment">// (3) [Array(2), Array(2), Array(2)]</span></span><br><span class="line"><span class="comment">// 0: (2) [&quot;name&quot;, &quot;John&quot;]</span></span><br><span class="line"><span class="comment">// 1: (2) [&quot;age&quot;, 17]</span></span><br><span class="line"><span class="comment">// 2: (2) [&quot;gender&quot;, &quot;male&quot;]</span></span><br><span class="line"><span class="comment">// length: 3</span></span><br><span class="line"><span class="comment">// [[Prototype]]: Array(0)</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a><code>Object.getOwnPropertyDescriptors()</code></h4><p>ES2017 给 <code>Object</code> 添加了方法 <code>.getOwnPropertyDescriptors()</code> 用来获取对象非继承的所有属性的描述符。与 ES5 中存在的 <code>.getOwnPropertyDescriptor()</code> 功能类似，但是这次添加的方法返回<strong>所有</strong>属于对象自身的 property 的 attribute 数组。</p>
<p>在 JavaScript 的对象中，每个 property 都有一组 attribute 描述这个属性的一些特性。由于这俩个词的中文含义相似，所以在一起出现时通常不做翻译，但如果遇到需要翻译时通常翻译为属性（property）和特性（attribute）。</p>
<p>目前存在以下描述符（Descriptor）：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>value</code></td>
<td>属性值</td>
</tr>
<tr>
<td><code>writable</code></td>
<td>属性值是否可写入</td>
</tr>
<tr>
<td><code>get</code></td>
<td>属性的 getter</td>
</tr>
<tr>
<td><code>set</code></td>
<td>属性的 setter</td>
</tr>
<tr>
<td><code>configurable</code></td>
<td>属性是否可以配置，影响属性能否被删除以及其他属性能不能被修改</td>
</tr>
<tr>
<td><code>enumerable</code></td>
<td>属性是否可以可枚举</td>
</tr>
</tbody></table>
<p>这个方法的添加是因为 <code>Object.assign()</code> 在复制对象时不会考虑属性的描述符，也就是说将定义了 <code>setter</code> 的 property 使用 <code>Object.assign()</code> 方式赋值给另一个对象时只有值（<code>value</code>）会被复制，<code>setter</code> 处理会被丢失。在 <code>.getOwnPropertyDescriptors()</code> 被添加后，可以使用 <code>Object.defineProperties()</code> 来配合复制描述符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = str;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Name: <span class="subst">$&#123;<span class="built_in">this</span>._name&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 定义了 name 的 setter，在设置这个属性时会编辑字符串</span></span><br><span class="line">obj.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">obj.name;</span><br><span class="line"><span class="comment">// &quot;Name: John&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Object.assign() 将 obj 的属性拷贝给 copied</span></span><br><span class="line"><span class="keyword">const</span> copied = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="comment">// obj 已经编辑过的值被保留了</span></span><br><span class="line">copied.name;</span><br><span class="line"><span class="comment">// &quot;Name: John&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试给 copied 的 name 重新复制</span></span><br><span class="line">copied.name = <span class="string">&quot;Howard&quot;</span>;</span><br><span class="line"><span class="comment">// obj 的 setter 没有被复制，所以属性被直接赋值</span></span><br><span class="line">copied.name;</span><br><span class="line"><span class="comment">// &quot;Howard&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试给 obj 的 name 赋值</span></span><br><span class="line">obj.name = <span class="string">&quot;Howard&quot;</span>;</span><br><span class="line"><span class="comment">// setter 生效并编辑了字符串</span></span><br><span class="line">obj.name;</span><br><span class="line"><span class="comment">// &quot;Name: Howard&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 .getOwnPropertyDescriptors() 进行复制并保留 setter</span></span><br><span class="line"><span class="keyword">const</span> kept = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</span><br><span class="line">kept.name = <span class="string">&quot;Sheldon&quot;</span>;</span><br><span class="line">kept.name;</span><br><span class="line"><span class="comment">// &quot;Name: Sheldon&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串实例：-padStart-和-padEnd"><a href="#字符串实例：-padStart-和-padEnd" class="headerlink" title="字符串实例：.padStart() 和 .padEnd()"></a>字符串实例：<code>.padStart()</code> 和 <code>.padEnd()</code></h4><p>ES2017 添加了字符串实例方法 <code>.padStart()</code> 和 <code>.padEnd()</code>，两功能就如字面意思。提升了字符串处理的能力。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Test String&quot;</span>;</span><br><span class="line"><span class="comment">// Test String</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只指定长度时将用空格填充</span></span><br><span class="line"><span class="built_in">console</span>.log(str.padStart(<span class="number">15</span>));</span><br><span class="line"><span class="comment">//     Test String</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者指定填充字符</span></span><br><span class="line"><span class="built_in">console</span>.log(str.padStart(<span class="number">15</span>, <span class="string">&quot;-&quot;</span>));</span><br><span class="line"><span class="comment">// ----Test String</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// padEnd 相同</span></span><br><span class="line"><span class="built_in">console</span>.log(str.padEnd(<span class="number">15</span>, <span class="string">&quot;!&quot;</span>));</span><br><span class="line"><span class="comment">// Test String!!!!</span></span><br></pre></td></tr></table></figure>

<h3 id="ES7（ES2016）"><a href="#ES7（ES2016）" class="headerlink" title="ES7（ES2016）"></a>ES7（ES2016）</h3><h4 id="数组实例：-includes"><a href="#数组实例：-includes" class="headerlink" title="数组实例：.includes()"></a>数组实例：<code>.includes()</code></h4><p>ES2016 给数组实例添加了 <code>.includes()</code> 方法判断数组中是否存在目标对象。以往我们会用 <code>.indexOf() &gt; -1</code> 来完成这个判断。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">arr.includes(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个参数可以指定搜索开始的位置</span></span><br><span class="line">arr.includes(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="指数运算符："><a href="#指数运算符：" class="headerlink" title="指数运算符：**"></a>指数运算符：<code>**</code></h4><p>指数运算符提供了一个方便的方式计算数值的求幂结果。相当于 <code>Math.pow()</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span>; <span class="comment">// 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span>; <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指数运算符优先计算，所以如果运算符右边的表达式依然是一个指数运算的话</span></span><br><span class="line"><span class="comment">// 将优先计算右边的结果，这里格式化工具自动给右边加上括号提示这部分将优先被计算</span></span><br><span class="line"><span class="number">2</span> ** (<span class="number">3</span> ** <span class="number">2</span>); <span class="comment">// 512</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6（ES2015）"><a href="#ES6（ES2015）" class="headerlink" title="ES6（ES2015）"></a>ES6（ES2015）</h3><p>ES6 是 ECMAScript 自 97 年的初版发布以来的最大的一次拓展性更新。ES6 的目标在于为大型应用开发、库的创建和以 ECMAScript 为标准的各种语言提供更好的支持。ES6 主要的更新内容包括模块化特性、类的声明、块级作用域、迭代器和生成器、非同步的 Promise、解构模式和尾调用优化。内置的库被扩展为支持新增的 map、set 和二进制数值数组结构，同时字符串和正则表达式支持新增的 Unicode 补充字符。这些内置库现在可以通过子类进行拓展。</p>
<h4 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a><code>let</code> 和 <code>const</code></h4><p>在 ES5 中我们只能使用 <code>var</code> 关键字声明变量，受到 JavaScript 解释器机制影响，这样定义变量存在<strong>变量提升（Variable Hoisting）</strong>现象。变量的声明被提升到当前函数作用域的顶部，下面这个例子可以直观的看到这个现象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// do something here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>在 for 循环中我们定义了循环变量 <code>i</code> 在循环体中使用，逻辑上这个变量只属于这个循环体，结束循环之后我们不应该能访问到这个变量。但是由于这里使用了 <code>var</code> 关键字，存在变量提升，变量 <code>i</code> 的声明被提升到了当前函数作用域的顶部，在全局作用域中就是执行所有命令之前的位置。这造成这个变量在循环体结束之后仍然能被访问，这里我们看到 <code>i</code> 最终变成了 <code>4</code>，结束了循环。</p>
<p>ES6 中我们可以使用 <code>let</code> 关键字来声明变量，这样声明的变量将在块级作用域中有效。比如使用 <code>let</code> 改写上面的循环时，在循环体结束之后变量 <code>i</code> 将不再存在。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// do something here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>

<p>同时，ES6 还引入了一个新的关键字 <code>const</code> 来标记常量。它有和 <code>let</code> 相同的作用域，但是 <code>const</code> 一旦声明后将不能重新赋值。对基本类型来说这个限制可以有效防止值的修改，但是对于引用类型来说这个限制只能保证指针不会被修改，但是对象的属性依然可以被修改。在使用中推荐能使用 <code>const</code> 声明的场合都使用 <code>const</code>，如果变量需要重新赋值则使用 <code>let</code>，尽量不要使用 <code>var</code> 声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">test</span>: <span class="string">&quot;abc&quot;</span> &#125;;</span><br><span class="line">b.test = <span class="string">&quot;def&quot;</span>;</span><br><span class="line">b.test; <span class="comment">// &quot;def&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="模版字符串-Template-Literals"><a href="#模版字符串-Template-Literals" class="headerlink" title="模版字符串 Template Literals"></a>模版字符串 Template Literals</h4><p>在 JavaScript 中存在大量操作 HTML、CSS 等内容的字符串操作，这些字符串操作通过加号链接各种变量和表达式，让整个字符串变得难以阅读。ES6 添加了模版字符串来解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="string">&quot;2021/09/11&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`Today is <span class="subst">$&#123;date&#125;</span>! Good day!`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"><span class="comment">// Today is 2021/09/11! Good day!</span></span><br></pre></td></tr></table></figure>

<h4 id="对象解构-数组解构-Objects-Arrays-Destructuring"><a href="#对象解构-数组解构-Objects-Arrays-Destructuring" class="headerlink" title="对象解构/数组解构 Objects/Arrays Destructuring"></a>对象解构/数组解构 Objects/Arrays Destructuring</h4><p>ES6 允许通过数组和对象形式给目标对象解构（Destructuring）来给变量赋值。使用数组形式解构时会默认调用目标对象的迭代器方法遍历数据，给相应位置的变量赋值，变量数组的长度决定了迭代器的 <code>next()</code> 方法调用的次数，如果变量数组长度超过目标数据的可迭代长度，迭代器仍然会被调用，但是会返回 <code>undefined</code> 作为值赋予给变量，你可以在解构赋值时给变量指定默认值来处理 <code>undefined</code> 的情况。数组解构可以嵌套，但是因为解构需要迭代器实现，如果嵌套解构的目标没有实现迭代器接口的话将会报错，而不是给变量赋值为 <code>undefined</code>。</p>
<p>使用对象形式解构赋值时根据变量名称来从目标数据中获取属性赋值。对象解构赋值的写法 <code>const &#123; foo &#125; = obj;</code> 实际上是 <code>const &#123; foo: foo &#125; = obj;</code> 的简写，所以如果你想将属性的值以另一个名称赋值给变量可以使用 <code>const &#123; foo: bar &#125; = obj;</code> 的形式，这也叫定义别名（Alias）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组解构赋值，需要目标对象是可迭代的（Iterable），变量通过迭代顺序赋值</span></span><br><span class="line"><span class="keyword">const</span> [str1, str2, str3, str4] = [<span class="string">&quot;This&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;cool&quot;</span>, <span class="string">&quot;!&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(str1, str2, str3, str4); <span class="comment">// This is cool !</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套数组也可以根据嵌套关系解构赋值</span></span><br><span class="line"><span class="keyword">const</span> [out1, [inner1, inner2], out2] = [<span class="string">&quot;Nested&quot;</span>, [<span class="string">&quot;array&quot;</span>, <span class="string">&quot;is also&quot;</span>], <span class="string">&quot;ok&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(out1, inner1, inner2, out2); <span class="comment">// Nested array is also ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象解构赋值，通过属性名称匹配赋值</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">17</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`This person&#x27;s name is <span class="subst">$&#123;name&#125;</span> and age is <span class="subst">$&#123;age&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// This person&#x27;s name is John and age is 17</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象解构赋值可以使用别名</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">employeeId</span>: id, <span class="attr">jobTitle</span>: job &#125; = &#123; <span class="attr">employeeId</span>: <span class="number">1</span>, <span class="attr">jobTitle</span>: <span class="string">&quot;AD&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`This guy&#x27;s id is <span class="subst">$&#123;id&#125;</span> and job title is <span class="subst">$&#123;job&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// This guy&#x27;s id is 1 and job title is AD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象解构也可以嵌套</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">profile</span>: &#123; <span class="attr">superPower</span>: power &#125;,</span><br><span class="line">&#125; = &#123; <span class="attr">profile</span>: &#123; <span class="attr">superPower</span>: <span class="string">&quot;sleep&quot;</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`This cool guy has &#x27;<span class="subst">$&#123;power&#125;</span>&#x27; as his super power!`</span>);</span><br><span class="line"><span class="comment">// This cool guy has &#x27;sleep&#x27; as his super power!</span></span><br></pre></td></tr></table></figure>

<p>当解构失败时变量将被赋值 <code>undefined</code>。如果嵌套解构失败时会报错。你可以给解构变量设置默认值来处理 <code>undefined</code> 的情况。但是注意，默认值仅对 <code>undefined</code> 有效，如果值为 <code>null</code>，变量会被赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [foo, defaultFoo = <span class="string">&quot;default foo&quot;</span>] = [];</span><br><span class="line"><span class="built_in">console</span>.log(foo, defaultFoo); <span class="comment">// undefined &quot;default foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; bar, defaultBar = <span class="string">&quot;default bar&quot;</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(bar, defaultBar); <span class="comment">// undefined &quot;default bar&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [x = <span class="string">&quot;x will be null because it&#x27;s not undefined&quot;</span>] = [<span class="literal">null</span>];</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套解构失败时会报错</span></span><br><span class="line"><span class="keyword">const</span> [[err]] = [<span class="number">1</span>]; <span class="comment">// Uncaught TypeError: [1] is not iterable</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123; err &#125;,</span><br><span class="line">&#125; = &#123; <span class="attr">bar</span>: <span class="number">1</span> &#125;; <span class="comment">// Uncaught TypeError: Cannot read property &#x27;err&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="对象字面量-Object-Literals"><a href="#对象字面量-Object-Literals" class="headerlink" title="对象字面量 Object Literals"></a>对象字面量 Object Literals</h4><p>ES6 允许在变量名和属性名相等时直接写入变量和函数当作属性。也允许表达式的结果作为对象的属性名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; foo &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: foo &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">doSomething</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> propertyName = <span class="string">&quot;specifiedPropertyName&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; [propertyName]: <span class="string">&quot;some values&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// &#123;specifiedPropertyName: &quot;some values&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="数据结构：Set-和-Map"><a href="#数据结构：Set-和-Map" class="headerlink" title="数据结构：Set 和 Map"></a>数据结构：<code>Set</code> 和 <code>Map</code></h4><p>ES6 提供了新的数据结构 <code>Set</code> 和 <code>Map</code>。<code>Set</code> 是一个类似数组的数据结构，但是成员的值是唯一的。可以理解为一个去重的数组。<code>Set</code> 是这个数据结构的构造函数，需要使用 <code>new</code> 关键字创建数据结构实例。下面是 <code>Set</code> 实例对象的方法。</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>.add(value)</code></td>
<td>添加元素到 Set</td>
</tr>
<tr>
<td><code>.delete(value)</code></td>
<td>删除 Set 中的一个元素</td>
</tr>
<tr>
<td><code>.has(value)</code></td>
<td>检查 Set 中是否存在目标元素</td>
</tr>
<tr>
<td><code>.clear()</code></td>
<td>清空 Set</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>].forEach(<span class="function">(<span class="params">x</span>) =&gt;</span> set.add(x));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// Set(5) &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 构造函数接受可迭代对象（比如数组）作为参数初始化一个 Set 数据结构</span></span><br><span class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="comment">// Set(5) &#123;1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Map</code> 类似 <code>Object</code> 都是键值对储存的数据，不同之处在于 <code>Object</code> 的键只接受字符串，而 ES6 新加入的 <code>Map</code> 数据类型可以接受任何值作为键。这是一种更完善的 Hash 结构实现，所以如果你需要真正的键值对数据类型，<code>Map</code> 比 <code>Object</code> 更合适。当使用对象作为 <code>Map</code> 的键时需要格外注意，<code>Map</code> 使用对象的内存地址作为键关联与之对应的值，2 个对象就算其计算结果完全相等，只要内存地址不同都会当作不同的键处理。</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>.set(key, value)</code></td>
<td>添加一对键值对到 Map 中</td>
</tr>
<tr>
<td><code>.get(key)</code></td>
<td>读取 Map 中对应键的值</td>
</tr>
<tr>
<td><code>.delete(key)</code></td>
<td>删除 Map 中的一个键</td>
</tr>
<tr>
<td><code>.has(key)</code></td>
<td>检查 Map 中是否存在目标键</td>
</tr>
<tr>
<td><code>.clear()</code></td>
<td>清空 Map</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">map.set([<span class="string">&quot;a&quot;</span>], <span class="string">&quot;value2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map(2) &#123;&quot;key1&quot; =&gt; &quot;value1&quot;, Array(1) =&gt; &quot;value2&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get([<span class="string">&quot;a&quot;</span>])); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map 构造函数接受可迭代对象（比如数组）作为参数初始化一个 Map 数据结构</span></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>],</span><br><span class="line">  [[<span class="string">&quot;a&quot;</span>], <span class="string">&quot;value2&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// Map(2) &#123;&quot;key1&quot; =&gt; &quot;value1&quot;, Array(1) =&gt; &quot;value2&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>ES6 还添加了 <code>WeakSet</code> 和 <code>WeakMap</code>。这两个数据类型与 <code>Set</code> 和 <code>Map</code> 基本一致，区别在于 <code>WeakSet</code> 仅接受对象作为值，而 <code>WeakMap</code> 仅接受对象作为键，当对象作为值和键存入这两个数据结构中，储存的是该对象的弱引用，这个引用不会影响对象被垃圾回收。不过也因为垃圾回收前后会造成这两个数据结构中的数据变化，所以不同于 <code>Set</code> 和 <code>Map</code>， <code>WeakSet</code> 和 <code>WeakMap</code> 被规定为不可遍历。这两个数据类型的使用场景主要是为了检查对象是否存在，或为每个存在的对象关联一个数据比如名称，对于 <code>WeakMap</code> 来说，如果作为键的对象被垃圾回收，那么其对应的值也会自动消失，不需要手动处理，这样可以避免因为忘记删除而造成的内存泄漏。</p>
<h4 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h4><p>ES5 表示集合的数据机构有 <code>Array</code> 和 <code>Object</code>，ES6 添加了 <code>Map</code> 和 <code>Set</code> 两种数据类型，所以 JavaScript 中现在存在 4 种数据集合。这些集合数据可以相互嵌套，所以就需要统一的迭代接口来对整个数据进行遍历。</p>
<p>ES6 引入了迭代器机制给所有对象属性提供统一的 API 来遍历数据。迭代器主要给 <code>for of</code> 循环消费。迭代器遍历数据的原理如下：</p>
<ol>
<li>初始化指针指向数据结构的起始位置；</li>
<li>每次调用 <code>next</code> 方法时返回一个对象包含 <code>value</code> 和 <code>done</code> 属性，并将指针指向下一个元素；<ol>
<li><code>value</code>：遍历到当前位置的值</li>
<li><code>done</code>：是否遍历结束</li>
</ol>
</li>
<li>迭代完成时调用 <code>next</code> 方法返回的对象中 <code>done</code> 设为 <code>true</code>。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 通过执行数组上的 Symbol.iterator 方法可以拿到迭代器对象</span></span><br><span class="line"><span class="keyword">const</span> it = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>四个集合数据结构中除了 <code>Object</code> 没有默认的迭代器实现，其他三个数据类型都可以通过 <code>Symbol.iterator</code> 访问到默认的迭代器生成方法。给 <code>Object</code> 实例添加 <code>Symbol.iterator</code> 迭代器生成方法之后也可以让其变成可迭代的数据类型。除了集合数据之外，<strong>字符串也原生具有迭代器接口</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> it = <span class="string">&quot;abc&quot;</span>[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// &#123;value: &quot;a&quot;, done: false&#125;</span></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// &#123;value: &quot;b&quot;, done: false&#125;</span></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// &#123;value: &quot;c&quot;, done: false&#125;</span></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>迭代器除了 <code>for of</code> 循环之外，下面这些情况会自动调用目标对象的 <code>Symbol.iterator</code> 方法。</p>
<ol>
<li>数组解构：<code>const [a, b, c] = iterableObject;</code> 会自动调用 <code>iterableObject</code> 的迭代器来依序给变量赋值；</li>
<li>扩展运算符：<code>[...iterableObject]</code> 会自动调用 <code>iterableObject</code> 的迭代器将对象展开成数组；</li>
<li>生成器关键字 <code>yield*</code>：在生成器中使用 <code>yield* iterableObject;</code> 会自动调用 <code>iterableObject</code> 的迭代器接口；</li>
<li>其他任何接受数组作为参数的方法都可能会调用迭代器接口。</li>
</ol>
<p>如果要自己实现一个迭代器方法，最方便的方法还是使用生成器机制。</p>
<h4 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 Generator"></a>生成器 Generator</h4><p>ES6 引入了类似 Python 中的生成器机制主要用来异步遍历数据。生成器通过 <code>function*</code> 和 <code>yield</code> 关键字实现，可以理解为封装了不同状态的函数，生成器中用 <code>yield</code> 表达式来指向一个状态。生成器需要使用 <code>.next()</code> 方法遍历，每次遍历时指针指向下一个状态，直到每个状态遍历结束为止。换言之生成器是分段执行的，每次 <code>.next()</code> 调用会执行上一次 <code>yield</code> 位置开始到下一次 <code>yield</code> 或 <code>return</code> 为止的命令。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">  <span class="comment">// yield* 是在生成器中调用生成器或迭代对象的语法糖</span></span><br><span class="line">  <span class="comment">// 这一步将在迭代完这个数组之后才会结束</span></span><br><span class="line">  <span class="keyword">yield</span>* [<span class="string">&quot;,&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> genObj = gen();</span><br><span class="line">genObj.next();</span><br><span class="line"><span class="comment">// &#123;value: &quot;Hello&quot;, done: false&#125;</span></span><br><span class="line">genObj.next();</span><br><span class="line"><span class="comment">// &#123;value: &quot;,&quot;, done: false&#125;</span></span><br><span class="line">genObj.next();</span><br><span class="line"><span class="comment">// &#123;value: &quot;world&quot;, done: false&#125;</span></span><br><span class="line">genObj.next();</span><br><span class="line"><span class="comment">// &#123;value: &quot;!&quot;, done: false&#125;</span></span><br><span class="line">genObj.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>生成器是 ES6 对协程（coroutine）的实现，但是由于生成器的执行权由调用者分配，所以是不完全实现，生成器函数被称作“半协程（semi-coroutine）”。生成器产生的环境上下文会在不执行的时候暂时退出调用栈冻结起来，然后执行的时候重新加入调用栈。</p>
<blockquote>
<p>协程是指在同一个线程内不同任务合作分配执行权，每个任务拥有自己独立的调用栈，在获得执行器的时候任务将继续执行，而没有执行权的任务将被暂时挂起（suspended）。</p>
</blockquote>
<p>生成器的 <code>yield</code> 表达式的返回值默认是 <code>undefined</code>，在迭代生成器调用 <code>.next()</code> 时可以传递一个参数，这个参数将作为生成器內 <code>yield</code> 的返回值反馈到生成器中。通过这个机制我们可以设计出在运行过程中改变行为的生成器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">      i = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> genObj = gen();</span><br><span class="line">genObj.next(); <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">genObj.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">genObj.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递参数重置 i</span></span><br><span class="line">genObj.next(<span class="literal">true</span>); <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">genObj.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure>

<p>生成器对象的执行方法除了 <code>.next()</code> 还有 <code>.throw()</code> 和 <code>.return()</code>。其中 <code>.throw()</code> 方法可以通知生成器函数进行异常处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Inside the generator!&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> genObj = gen();</span><br><span class="line">genObj.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// the first error will be catch by the generator</span></span><br><span class="line">  genObj.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Something went wrong!&quot;</span>));</span><br><span class="line">  <span class="comment">// the second error will not be dealt by the generator because it&#x27;s end of execution</span></span><br><span class="line">  genObj.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Something went wrong! Again!&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Outside the generator!&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Inside the generator! Error: Something went wrong!</span></span><br><span class="line"><span class="comment">// Outside the generator! Error: Something went wrong! Again!</span></span><br></pre></td></tr></table></figure>

<p><code>.return()</code> 方法让生成器立刻返回方法指定的参数，并且终结生成器的执行。如果未指定参数，生成器对象将返回 <code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> genObj = gen();</span><br><span class="line">genObj.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">genObj.return(<span class="string">&quot;over&quot;</span>); <span class="comment">// &#123;value: &quot;over&quot;, done: true&#125;</span></span><br><span class="line">genObj.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用生成器给对象实现一个迭代器方法非常方便。可以看到当生成器作为对象属性时，在名称前面加 <code>*</code> 即可标记这个属性是生成器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">17</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">  <span class="comment">// 等价于 [Symbol.iterator]: function* () &#123;&#125;</span></span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> [key, <span class="built_in">this</span>[key]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, val] <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Key: <span class="subst">$&#123;key&#125;</span>, Val: <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">  <span class="comment">// Key: name, Val: John</span></span><br><span class="line">  <span class="comment">// Key: age, Val: 17</span></span><br><span class="line">  <span class="comment">// Key: gender, Val: male</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for of 循环"></a><code>for of</code> 循环</h4><p>ES6 引入了 <code>for of</code> 循环。一个数据结构只要实现了 <code>Symbol.iterator</code> 迭代器接口就可以使用 <code>for of</code> 循环进行遍历。最常用的场景是对数组使用 <code>for of</code> 循环遍历。</p>
<p>JavaScript 原有的 <code>for in</code> 循环只读取属性的名称，在对数组使用时循环变量拿到的是数组的索引，并且在数组定义了额外的属性时还会拿到这些属性的名称。而使用 <code>for of</code> 遍历数组可以直接拿到遍历位置的值，也不会获取到数组实例本身的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line">arr.anotherProperty = <span class="string">&quot;hidden value&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 0, 1, 2, anotherProperty</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// a, b, c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外由于字符串也原生实现了迭代器方法，所以字符串也可以用 <code>for of</code> 循环进行遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="string">&quot;Hello!&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// H, e, l, l, o, !</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="箭头函数-Arrow-Functions"><a href="#箭头函数-Arrow-Functions" class="headerlink" title="箭头函数 Arrow Functions"></a>箭头函数 Arrow Functions</h4><p>ES6 允许使用 <code>=&gt;</code> 定义函数。使用箭头函数来表示函数体只有一行的函数非常简洁。剪头函数的一个用处就是简化回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> af = <span class="function">(<span class="params">x</span>) =&gt;</span> x ** <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> af = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x ** <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>箭头函数使用时需要注意下面几点：</p>
<ol>
<li>箭头函数内的 <code>this</code> 指向定义它的对象，而非使用时的对象；</li>
<li>箭头函数不可当构造函数使用，使用 <code>new</code> 关键字会报错；</li>
<li>箭头函数内不存在 <code>arguments</code> 对象，如需要可使用 rest 参数；</li>
<li>箭头函数不可定义为生成器对象，不能使用 <code>yield</code> 表达式。</li>
</ol>
<p>其中第一点箭头函数中的 <code>this</code> 对实际使用影响最大，一般函数中的 <code>this</code> 指向运行时的作用域的 <code>this</code>，比如下面的 <code>setTimeout()</code> 的回调函数在延迟 <code>100</code> 毫秒后会在全局作用域中执行，如果使用普通函数的写法输出 <code>this</code> 将打印 <code>window</code> 对象，但是箭头函数会打印调用者对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">printThis</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;this in general function:&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;this in arrow function:&quot;</span>, <span class="built_in">this</span>), <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.printThis();</span><br><span class="line"><span class="comment">// this in general function: Window &#123;…&#125;</span></span><br><span class="line"><span class="comment">// this in arrow function: &#123;printThis: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="默认参数-Default-Params"><a href="#默认参数-Default-Params" class="headerlink" title="默认参数 Default Params"></a>默认参数 Default Params</h4><p>ES6 允许对函数的参数设定默认值。这在处理参数为 <code>undefined</code> 时非常有用。虽然默认参数可以写在任何位置，但是如果你希望调用者可以省略这个参数，则你应该考虑把所有默认参数放在最后定义，否则调用者将无法省略默认参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, power = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a ** power;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">2</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果将默认参数放在前面，则无法省略这个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">power = <span class="number">2</span>, a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a ** power;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f2(<span class="number">2</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(f2(<span class="literal">undefined</span>, <span class="number">2</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h4 id="类的声明-Class-Declaration"><a href="#类的声明-Class-Declaration" class="headerlink" title="类的声明 Class Declaration"></a>类的声明 Class Declaration</h4><p>ES6 加入了 <code>class</code> 概念来消除 JavaScript 中实例对象的创建过程与其他语言（比如 Java）的差异。ES6 的类声明在 ES5 中大部分都可以用 <code>prototype</code> 的写法实现，但是使用 <code>class</code> 声明的类更加清晰易懂。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// constructor 是类的保留方法，这个方法将作为构造器被使用</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> john = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, <span class="number">17</span>);</span><br><span class="line"><span class="built_in">console</span>.log(john.toString());</span><br><span class="line"><span class="comment">// John is 17 years old.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以将 class 视作 prototype 的语法糖</span></span><br><span class="line"><span class="comment">// 从下面的结果来看实际上 class 定义会转变成 prototype 上的属性</span></span><br><span class="line"><span class="keyword">typeof</span> Person; <span class="comment">// &quot;function&quot;</span></span><br><span class="line">Person === Person.prototype.constructor; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此我们可以给 class 动态添加方法，并且所有实例对象可以立即使用该方法</span></span><br><span class="line"><span class="built_in">Object</span>.assign(Person.prototype, &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hi!&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">john.sayHi(); <span class="comment">// &quot;Hi!&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用类时需要注意下面的细节：</p>
<ol>
<li>类的定义默认就是严格模式（strict mode）；</li>
<li>类的定义不存在提升（hoisting），先于类定义的实例化命令会报错；</li>
<li>类本质上是构造函数，所以函数的很多特性会被类继承；</li>
<li>类的方法可以定义生成器；</li>
<li>类的 <code>this</code> 指向实例对象，但是根据 JavaScript 的机制只有在实例对象后接方法调用才是如此。</li>
</ol>
<p><strong>实例属性</strong></p>
<p>类的实例属性除了以 <code>this.property</code> 的形式在方法中定义，还可以写在类定义的顶部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">  age = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> john = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// Person &#123;name: &quot;John&quot;, age: 17&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>静态方法与属性</strong></p>
<p>默认类中定义的所有方法和属性都会被实例对象继承，但是如果方法或属性使用了 <code>static</code> 关键字，则该方法或属性将作为类的静态方法或属性存在，不会被实例继承。静态方法中的 <code>this</code> 指向类的定义而非实例对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> type = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">thisIsStaticMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Static method called!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.type); <span class="comment">// person</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.thisIsStaticMethod()); <span class="comment">// Static method called!</span></span><br></pre></td></tr></table></figure>

<p><strong>私有方法与属性</strong></p>
<p>ES6 并未提供定义私有方法和属性的途径。现有的解决方法大致分为 3 种。</p>
<ol>
<li>以下划线开始命名属性和方法，比如 <code>_property</code> 和 <code>_method()</code>，这只是一种约定，外部依然能访问到私有方法和属性；</li>
<li>将私有方法和属性移出模块，让外部无法访问，但是不够优雅；</li>
<li>使用 Symbol 定义方法名称，外部拿不到这个 Symbol 也就无法访问私有方法和属性。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在模块外定义方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类方法名 Symbol</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 约定命名规则定义私有方法，但是外部依然能够访问</span></span><br><span class="line">  <span class="function"><span class="title">_privateMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">publicMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 将私有方法移除模块阻止外部访问</span></span><br><span class="line">    doSomething(<span class="comment">/* ... */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Symbol 组织外部访问</span></span><br><span class="line">    <span class="built_in">this</span>[foo](<span class="comment">/* ... */</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [foo]() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类的继承</strong></p>
<p>类可以通过 <code>extends</code> 关键字实现继承。子类会继承父类的方法和属性，包括静态方法和属性。子类实现 <code>constructor</code> 时要调用 <code>super()</code> 先实例化父类对象后才能访问到 <code>this</code> 的上下文。从这一点来看，子类实例对象只是父类实例对象上的定制化。</p>
<p>子类中可以通过 <code>super</code> 对象访问到父类的方法实现。在 ES5 中使用 <code>prototype</code> 方式无法继承原生属性的构造器，比如你无法定义一个新的 <code>Array</code> 类型。在 ES6 中你可以通过 <code>extends</code> 实现对原生类型的继承。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">  age = <span class="number">17</span>;</span><br><span class="line">  <span class="keyword">static</span> type = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Student &quot;</span> + <span class="built_in">super</span>.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Student.type); <span class="comment">// person</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Student().toString()); <span class="comment">// Student John is 17 years old.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.getPrototypeOf() 可以判断一个类是否继承了另一个类</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(Student) === Person; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="模块-Module"><a href="#模块-Module" class="headerlink" title="模块 Module"></a>模块 Module</h4><p>ES6 实现了静态加载的模块化，结束了 JavaScript 长久以来没有原生模块化机制，只能靠第三方实现依赖管理的历史。模块化通过 <code>export</code> 和 <code>import</code> 命令完成，依赖的导入是静态的，先于模块内容执行，将 <code>import</code> 放在逻辑中会报错。这样的设计会提高编译器的效率，但是也导致不能实现动态加载。另外，ES6 的模块化自动采用严格模式，无论你有没有声明 <code>use strict;</code>。</p>
<p><code>export</code> 负责将模块内的遍历暴露出来，向外提供接口。暴露接口可以指定名称，或者使用 <code>default</code> 关键字不指定名称。<code>export</code> 只能在全局作用域中使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露变量</span></span><br><span class="line"><span class="keyword">export</span> foo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露多个变量</span></span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露默认接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他 export 方式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">AnyClass</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>import</code> 同样只能在全局作用域中使用。使用 <code>export</code> 定义了模块的接口之后，可以通过 <code>import</code> 命令加载这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载默认接口</span></span><br><span class="line"><span class="keyword">import</span> component <span class="keyword">from</span> <span class="string">&quot;./module.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块中的指定接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&quot;./module.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面 2 个方式可以放一块</span></span><br><span class="line"><span class="keyword">import</span> component, &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&quot;./module.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体加载模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">&quot;./module.js&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>ES6 引入 <code>Symbol</code> 来解决对象属性名称冲突的问题。ES5 中的对象属性名称只能是字符串，这在大型应用开发中，如果你使用了一个他人定义的对象，并且像往里面添加属性的话，就存在属性名称冲突的风险。ES6 添加了 <code>Symbol</code> 原始数据类型，用来表示独一无二的值。也就是说现在对象属性名称可以有 2 种类型，一种是字符串，另一种就是这个 Symbol。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s; <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; [s]: <span class="string">&quot;value of symbol&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// &#123;Symbol(): &quot;value of symbol&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[s]); <span class="comment">//value of symbol</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol</code> 可以接受一个字符串参数作为这个 Symbol 的描述。这个描述主要是用来区分不同的 <code>Symbol</code> 的。注意 <code>Symbol</code> 的描述只是用来区分当前的 <code>Symbol</code>，描述信息相同不代表 <code>Symbol</code> 相同。另外 <code>Symbol</code> 的值不能与其他类型做运算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"></span><br><span class="line">s1.toString(); <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br><span class="line">s2.toString(); <span class="comment">// &quot;Symbol(bar)&quot;</span></span><br><span class="line"></span><br><span class="line">s1 === <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol</code> 作为属性名时不会出现在 <code>for in</code> 和 <code>for of</code> 循环中，也不会被 <code>Object.values()</code>、<code>Object.getOwnPropertyNames()</code> 和 <code>JSON.stringify()</code> 方法返回。你可以使用 <code>Object.getOwnPropertySymbols()</code> 获取指定对象的 Symbol 属性名。利用这个特性，我们可以定义一些非私有而又希望仅在内部使用的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; [s1]: <span class="string">&quot;value1&quot;</span>, [s2]: <span class="string">&quot;value2&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"><span class="comment">// (2) [Symbol(foo), Symbol(bar)]</span></span><br></pre></td></tr></table></figure>

<p>有时我们希望重复使用同一个 Symbol 值。<code>Symbol.for()</code> 方法获取的 Symbol 值会现在全局中搜索是否存在对应描述符的 Symbol，如果没有则新建一个 Symbol 并将其注册到全局中，方便之后使用。但是注意 <code>Symbol.for()</code> 拿到的值与 <code>Symbol()</code> 不会相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2; <span class="comment">// true</span></span><br><span class="line">s1 === <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>还有另一个方法 <code>Symbol.keyFor()</code> 配合使用，可以拿到从全局中获取的 Symbol 的键。如果这个 Symbol 没有登记到全局则会返回 <code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1); <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>ES6 提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Symbol.hasInstance</code></td>
<td>使用 <code>instanceof</code> 关键字时实际上会调用对象的 <code>Symbol.hasInstance</code> 方法来进行判断</td>
</tr>
<tr>
<td><code>Symbol.isConcatSpreadable</code></td>
<td>布尔值用来判断对象在使用数组实例的 <code>.concat()</code> 时是否能够展开</td>
</tr>
<tr>
<td><code>Symbol.species</code></td>
<td>属性指向一个构造函数，在创建衍生对象时会使用该属性</td>
</tr>
<tr>
<td><code>Symbol.match</code></td>
<td>当执行 <code>str.match(obj)</code> 时如果对象存在这个属性，则会调用它进行判断</td>
</tr>
<tr>
<td><code>Symbol.replace</code></td>
<td>当执行 <code>str.replace(obj)</code> 时如果对象存在这个属性，则会调用它进行处理</td>
</tr>
<tr>
<td><code>Symbol.search</code></td>
<td>当执行 <code>str.search(obj)</code> 时如果对象存在这个属性，则会调用它进行处理</td>
</tr>
<tr>
<td><code>Symbol.split</code></td>
<td>当执行 <code>str.split(obj)</code> 时如果对象存在这个属性，则会调用它进行处理</td>
</tr>
<tr>
<td><code>Symbol.iterator</code></td>
<td>定义对象的迭代器，在遇到需要迭代对象时会自动调用</td>
</tr>
<tr>
<td><code>Symbol.toPrimitive</code></td>
<td>对象被转为初始类型时会调用该方法</td>
</tr>
<tr>
<td><code>Symbol.toStringTag</code></td>
<td>当调用对象的 <code>.toString()</code> 时会调用，用来替换 <code>[object Object]</code> 中的 <code>Object</code> 表示对象的类型</td>
</tr>
<tr>
<td><code>Symbol.unscopables</code></td>
<td>一系列属性在使用 <code>with</code> 关键字时会被 <code>with</code> 环境排除</td>
</tr>
</tbody></table>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/ECMAScript">ECMAScript - Wikipedia</a></li>
<li><a href="https://262.ecma-international.org/6.0/">ECMA-262 - Ecma International</a></li>
<li><a href="https://www.bookstack.cn/read/es6-3rd/README.md">ES6 入门教程</a></li>
</ul>
]]></content>
      <categories>
        <category>study</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
